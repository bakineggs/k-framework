#!/usr/bin/env perl
use strict;
use File::Basename;
use File::Spec;
use File::Copy;
use File::Path 2.07 qw( make_path remove_tree );
use Switch;
use Cwd;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use English;

BEGIN {
    unshift (@INC, (File::Basename::fileparse($0))[1]);
}

# check installed software
check_perl_packages("XML::DOM");
check_perl_packages("Regexp::Common");
check_perl_packages("XML::LibXML::Reader");
check_perl_packages("Tree::Nary");
check_perl_packages("Text::Diff");

# add common functions file
my $path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'common_functions.pl');
require $path;
# add unquoting functions file
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'unquote.pl');
require $path;

# depending on the options given, different flags can be added here and they will be passed to maude when called
my $additionalMaudeFlags = "";

my $maude_path = 'maude';

# File names for the input to be sent to the Maude compiler, as well as
# file names for the output, errors and temporary files generated by it
# These are useful for debugging
my $k_dir = ".k";
my $kmain = "kmain-";
my $input_file  = fresh("kompile_in", ".maude");
my $error_file  = fresh("kompile_err", ".txt");
my $output_file = fresh("kompile_out", ".txt");
my $temp_file   = fresh("kompile_tmp", ".txt");
my $maude_xml_file   = fresh("kompile_xml", ".xml");


my $k_license="Copyright (C) This file is generated by K-framework.\n";
my $verbose = 0;
my $help = 0;
my $maudify_only = 0;
my $k_prelude_loaded = 0;

# K tags variables
my $flag_structural = "structural=()";
my $flag_computational = "computational=()";
my $flag_nd_strict = "ndstrict=()";
my $structural = 0;
my $computational = 0;
my $nd_strict = 0;

# keep all autogenerated files
my @generated_files = ();
# here we trap control-c (and others) so we can clean up when that happens
$SIG{'INT'} = 'interruptHandler'; # handle control-c 
$SIG{'QUIT'} = 'interruptHandler';
$SIG{'HUP' } = 'interruptHandler';
$SIG{'TRAP'} = 'interruptHandler';
$SIG{'ABRT'} = 'interruptHandler';
$SIG{'STOP'} = 'interruptHandler';


sub interruptHandler {
	finalCleanup(); # call single cleanup point
	exit(1); # since we were interrupted, we should exit with a non-zero code
}

# this block gets run at the end of a normally terminating program, whether it simply exits, or dies.  We use this to clean up.
END {
	my $retval = $?; # $? contains the value the program would normally have exited with
	finalCleanup(); # call single cleanup point
	exit($retval);
}

# this subroutine can be used as a way to ensure we clean up all resources whenever we exit.  This is going to be mostly temp files.  If the program terminates for almost any reason, this code will be executed.
sub finalCleanup {
	# clean(); # delete normal kompile files
	unlink("cfg_temp.tmp");
	unlink("xml-parser.pl");
	unlink($maude_xml_file); # we don't want to put this in clean, since clean gets called before the xml file is used
	compilation_cleanup();
}


sub compilation_cleanup
{
	# finish the execution

	# move .maude files into .k folder
	# print "GENERATED: @generated_files\n\n";

	# remove .k if there
	unlink($k_dir);

	#create directory
	mkdir $k_dir;

	foreach(@generated_files)
	{
#		print "$_ -- $kmain\n";
	
#		if (m/kmain\-/sgi)
		if (m/\Q$kmain\E/sgi)
		{
			unlink($_);
		}
		# ignore -compiled.maude files
		elsif ( !m/\-compiled\.maude/sg )
		{
			my $content = get_file_content($_);

			# solve paths
			foreach my $iter (@generated_files)
			{
				my($filename, $path, $suffix) = fileparse($iter); $filename =~ s/\..+?$//sg;
				$content =~ s!^\s*(in|load)(\s+)(.*?\Q$filename\E)(?=\s)!{"$1$2$filename"}!gme;
			}

			# save content
			open F, ">", $_ or die "Cannot open $_\n";
			print F $content;
			close F;

			# move file in directory
			my($filename, $path, $suffix) = fileparse($_);
			rename($_, "$k_dir/$filename");
		}
	}

	

	# move temp files in $k_dir too
	rename($input_file, "$k_dir/$input_file");
	rename($error_file, "$k_dir/$error_file");
	rename($output_file, "$k_dir/$output_file");
	rename($temp_file, "$k_dir/$temp_file");
	rename($maude_xml_file, "$k_dir/$maude_xml_file");

}

# add configuration parser
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'configuration_parser.pl');
require $path;


my $short_help_message = 
"
  General options
  -h (or -help) : print this message and exit
  -v (or -verbose) : verbose mode
  -m (or -maudify) : only maudify, do not kompile
  -c (or -compile) : only compile, do not maudify
  -lint : only maudify and sanity checks, do not kompile
  -l (or -lang or -language) <module_name> : start module
  -file : the input source file (optional)
  -nd : compile for full non-determinism in heating/cooling
  -prelude file.m(aude) : specifies the k-prelude file
  -flat : slurp all k or kmaude files into one k file 
  -u (or -unquote) : unquote the maude meta-terms to increase speed
  
  Latex options
  -latex : maudifies/compiles for generating latex output
  -pdf : maudifies/compiles for generating pdf output
  -ps : maudifies/compiles for generating ps output
  -eps : maudifies/compiles for generating eps output
  -png : maudifies/compiles for generating png output
  -crop : maudifies/compiles for generating a nice crop-pdf output
  
  The following options make sense only when Latex options are used:
  -style : useful for typesetting (optional)
  -output output_file : specifies the name of the generated (latex) file
  -draft : include [draft] in\ documentclass
  -topmatter : includes the content of the argument file
	after \\begin{document} but before first \\begin{module}
	in the latex file

  Compile only one program options
  -pgm <filename> : specify the file where the program macro is
  -cmod <compiled module name> : specify the compiled module 
			where the language is
  -pmod <module name> : specify the module where the macro is
     If this is missing, <module name> will be considered ALLCAPS(pgm)
  -pname <macro name> : specify the name of the macro
     If this is missing, <macro name> will be considered as being pgm
  \n";

# next subroutine prints the usage message;
# $0 is initially bound to the program name, as typed
sub terminate {
    print "\nERROR: $_[0]\n\n" if defined $_[0];
    print "Usage: 
  $0 (-option)* <source_file>[.k|.kmaude|.maude] (-option)*

  $short_help_message" if (!$verbose && !$help);

    print "Usage:
  $0 (-option)* <source_file>[.k|.kmaude|.maude] (-option)*
  
  This program takes a K language definition and translates
  it into a Maude executable specification.  The input K
  definition can be spread over several files and modules,
  all reachable from <source_file>[.k|.kmaude|.maude], and the
  generated output will be saved in <source_file>-compiled.maude.

  <source_file> must be a K-Maude or a Maude file, expected
  to directly or indirectly (by loading other files) include
  the entire definition of the language.  It is highly
  recommended that one omits the (.maude or .kmaude or .k) extension
  of the loaded files, to let this program choose the appropriate
  one depending upon the compilation stage or parameters.

  <source_file> is assumed to be a K-Maude file whenever it
  has the extension \".kmaude\" or \".k\" and a Maude file whenever
  it has the extension \".maude\".  If none of these extensions
  is provided, then the K-Maude file <source_file>.kmaude (or 
  <source_file>.k) is  considered if it exists; if <source_file>.kmaude 
  (or <source_file>.k) does not exist, then the Maude file 
  <source_file>.maude is considered instead.
  If none of the files <source_file>.kmaude (<source_file>.k) or 
  <source_file>.maude is found, then this program stops with an error message.

  The same name resolution principle as above is recursively
  applied on files directly or indirectly loaded by <source_file>.

  As part of the Maude-ification process, a corresponding
  file.maude file will be associated to each file.kmaude
  file directly or indirectly loaded by <source_file>.
  Note that these are only intermediate representation files,
  which are not executable.

  If an error occurs in the compilation process (including
  any Maude warnings), this program will stop, displaying the
  input, the (possibly partially) generated output, and the
  error/warning messages reported by Maude.  Files containing
  intermediate compilation results are also kept for debugging.

  $short_help_message

  The option -m generates all the Maude files file.maude
  corresponding to all the files file.kmaude reachable from
  <source_file>.  Note that Maude files are also allowed to
  load K-Maude files, which, as explained above, is the default
  choice whenever an extension is not given for the loaded file.
  This option is fast (since it does not compile the Maude-ified
  K language definition), so it is generally good for debugging.

  The option -c assumes that the K definition is already
  Maude-ified (either manually or using the above -m option).
  In particular, files with the extension .kmaude cannot be
  loaded anymore: the program terminates with an error if one
  attempts to do so, and the default extension is .maude.
   
  The option -lint checks that the definitions satisfies somes typing
  requirements whose failure would make compilation likely to fail.
  More precisely, it checks that the arguments of all operations whose
  result sort is K are either subsorted to K or have injections (\"builtin
  wrapper\"s) into K and that all (sub)terms appearing in rules have a least 
  sort (i.e., they do not parse into a kind).  This steps does the maudification
  before checking for consistency.

  If the -l option is used, then <source_file> must
  contain a module called <module_name>.  If the option
  -l is not used, then <source_file> must include a module
  with the same root name, but capitalized.

  Technically, the command \"kompile lang.kmaude\" is equivalent to
  \"kompile -m lang.kmaude\" followed by \"kompile -c lang.maude\".
  Since \"kompile -m lang.kmaude\" associates a corresponding .maude
  file to each reachable .kmaude file while it does not modify
  any of the reachable .maude files, in order for
  \"kompile -c lang.maude\" to work one is advised to not use
  extensions for the loaded file names; in other words, write, e.g.,
  \"in/load lang-syntax\" instead of \"in/load lang-syntax.kmaude\".

  The option -latex is used for typesetting a K definition.  It can
  be used in combination with any of the other options above.  If
  used with -m, then it only maudifies the (entire) given input file,
  adding for each operation a special latex attribute inside the
  operation's metadata.  If used with -c, it assumes that the input
  file is already maudified as above and generates a latex and a
  PDF file corresponding to a list of specified module names.  The list
  of module names should be given following the -latex option.  If used
  wihout any of -m or -c, it first applies the -m and then the -c, as
  explained in the paragraph above but with the additional option -latex.

  The optional parameter passed to -style (which only makes sense when
  the -latex option is used) can alter the style used for typesetting.
  Currently, there are two style options available, bb, for typesetting
  via tikz graphical cells, and mm, for typesetting using the simple
  mathematical notation.  The default option is bb.

  If a file <source_file>.sty is provided by the user in the current
  directory, it will be included in the generated latex file after the
  above mentioned style, and thus could be used to alter the default
  typesetting macros.
 
  Examples

  kompile lang.kmaude : compiles the K language definition
  found in file lang.kmaude into an executable Maude
  specification saved in file lang-compiled.maude.
  The file lang.kmaude must contain a module named LANG.

  kompile lang3.kmaude -l LANG : compiles the K language
  definition reachable from module LANG of file lang3.kmaude
  into a Maude specification saved in file lang3-compiled.maude.

  kompile -v -m lang3.kmaude : it only (verbosely) Maude-ifies
  the K language definition reachable as above, saving it in
  file lang3.maude (and similarly for loaded files). To further
  compile the Maude-ified K definition, use the following:

  kompile lang3.maude -l LANG : it compiles the K definition
  starting with module LANG of file lang3.maude into an
  executable Maude specification saved in file
  lang3-compiled.maude.  lang3.maude is still allowed to load
  K-Maude files, which will be Maude-ified.

  kompile -l LANG lang3 -c : it compiles the already
  Maude-ified K definition starting with module LANG of file
  lang3.maude.  lang3.maude cannot load any K-Maude files; the
  default extension of loaded files is set to .maude.

  kompile -latex LANG LANG-SEMANTICS LANG-SYNTAX -f lang3
  or
  kompile lang3 -latex LANG LANG-SEMANTICS LANG-SYNTAX
  It typsets the specified modules reachable from the input
  file lang3.
  
  kompile lang -latex LANG LANG-SEMANTICS LANG-SYNTAX 
  -title \"MyLang Name\" -author \"LangAuthor anotherAuthor\"
  -output out
  will generate a latex file called out.tex and
  will also set the title and the author via \\maketitle.
  Note that after option -title you can have a string which
  can include latex code but only latex commands (like \"\\Huge\",
  etc. ). Also, note that -author will not count if -title is not used.

  The -pdf, -png, -ps, -eps and -crop options can be used in 
  the same way the -latex option is used in the example above.

  kompile lang -flat -m 
  or
  kompile lang -m -flat 
  If -m and -flat options are given in the same time
  then the tool will output two files: 
  lang-flat.k which contains all the defintion of the language
  and
  lang-flat.maude which is lang-flat.k maudified.

" if ($verbose || $help); 
    print "\nERROR: $_[0]\n\n" if defined $_[0];
    exit(1);
}


########################
# <TOOL CONFIGURATION> #
########################

# Special chars, strings and patterns, for configuring/tuning the tool  
# Since these special chars will be used as patterns in matching        
# and since some of them have special matching meaning, we use \Q \E    

my $parentheses = "\Q{}[]()\E";

########
# PERL #
########
my $special_perl_chars  = "$parentheses\Q\\^|*+?.\$\E";

#########
# Maude #
#########
my $maude_special = "[ $parentheses\\s_\\,\\`]";
my $maude_unspecial = "[^$parentheses\\s_\\,\\`]";
my $maude_backquoted = "(?:`\\(|`\\)|`\\{|`\\}|`\\[|`\\]|`\\,|_|[^$parentheses\\s\\,\\`])*";

#########
# Latex #
#########
#my $latex_special = "[\\#\\$\\{\\}\\[\\]\\&\\^\\_\\%\\~\\\\]";
my $latex_special = '[\\#\\$\\{\\}\\[\\]\\&\\^\\_\\%\\~\\\\]';

#####
# K #
#####
# Pattern matched by K variables
my $kvar  = "[A-Za-z][A-Za-z0-9]*[']*";

# Pattern matched by K sorts
my $ksort = "[A-Z][A-Za-z0-9\\`\\+\\?\\!#]*(?:\\{[A-Z][A-Za-z0-9\\`\\+\\?\\!]*\\})?";
# TODO: test exhaustively :-)

# Pattern matched by K variables
my $klabel_body = "$maude_backquoted\_$maude_backquoted";
my $klabel = "\'$klabel_body(?:[$parentheses\\s\\,])|$klabel_body(?=\\()";

# Builtin tokens
my @builtin_tokens = qw(=> = -> id: .K .List .Set .Bag .Map);

# A default freezer name, to be used as a prefix of frozen strings
my $default_freezer = "FREEZER";

# A special string that will be used for freezing substrings that need not be modified
# Choose a symbol which will never appear in any programming language or program
my $specialSymbol = "K";

my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_base =  File::Spec->catfile((File::Basename::fileparse($0))[1], "..");
my $k_all_tools = File::Spec->catfile($k_tools_dir,"all-tools");
my $k_to_latex = File::Spec->catfile($k_tools_dir,"k-to-latex");
my $k_latex_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'latex');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");

my @kmaude_keywords = qw(context rule macro eq ceq configuration op ops syntax kvar sort sorts subsort subsorts including kmod endkm mb);
my $kmaude_keywords_pattern = join("|",map("\\b$_\\b",@kmaude_keywords));
my $kmaude_kwds_pattern = join("|", @kmaude_keywords);

my @k_attributes = qw(strict metadata prec format assoc comm id: hybrid gather ditto seqstrict structural large latex );           
my $k_attributes_pattern = join("|",  @k_attributes);   

my $k_sorts = "#Bag#BagItem#Bool#Builtins#CellLabel#CellKey#CellAttribute#Char#Int#K#KAssignments#KHybridLabel#KLabel#KResult#KResultLabel#KSentence#List#ListItem#List{KResult}#List{K}#Map#MapItem#Nat#NeBag#NeK#NeList#NeList{KResult}#NeList{K}#NeMap#NeSet#NzInt#NzNat#Set#SetItem#String#Zero";

my $comment = join("|", (
        "\\/\\/.*?\n",
        "\\/\\*.*?\\*\\/",
		"---\\(.*?---\\)",
		"---.*?\n",
		"\\*\\*\\*\\(.*?\\*\\*\\*\\)",
		"\\*\\*\\*.*?\n"
));

# my $string_pattern = quotemeta("(?<![^\\]\\)\".*?(?<![^\\]\\)\"");
my $string_pattern = "\(?<![^\\\\]\\\\\)\".*?\(?<![^\\\\]\\\\\)\"";

# Top level patterns
my $top_level_pattern = join("|", (
		"kmod(?:.*?)endkm",
		"mod(?:.*?)endm",
		"fmod(?:.*?)endfm",
		"set\\s.*?\$",
		"(?:in|load|require)\\s+\\S+"
));

# Latex top level patterns
my $latex_top_level_pattern = join("|", (
		"\\/\\/@(before|after)=([a-zA-Z\\-]+)(\\s.*?)(?=\\n)",
		"\\/\\*@(before|after)=([a-zA-Z\\-]+)(\\s.*?)\\*\\/"
));

# storage for module specific latex comments 
my %module_before = ();
my %module_after = ();



# Configuration pattern: excludes, for the spacing, from the above all those substrings matching $exclude
my $exclude = join("|",
		   "\^\\s*(?:in|load|require)\\s+\\S+\\s*(?=(in|load|require|kmod))",   # in/load of a file
		   "kmod\\s+(?:\\S*(?=\\s))",                               # kmodule name
		   "including(?:.*?(?=\\s+(?=$kmaude_keywords_pattern)))",  # included module expressions
		   "(?<!:):$ksort",                                         # sort declarations for other than ordinary $kvar
		   "(?<=\\s)ops?\\s+.*?(?=\\s+(?=$kmaude_keywords_pattern))",       # operation declarations
		   "$klabel",                                               # K labels
		   "rule\\s*\\[[^\\[\\]]*\\]\\s*:",                         # rule labels
		   "\\d+\\.\\d+",                                           # real numbers
		   "-\\d+"                                                  # negative integer
		   );

my $modules_list = "[A-Z\\-\\s]+[A-Z]";
# my $modules_list = "[a-zA-Z\\-\\+]+(?:\\-(latex|pdf|crop|ps|eps|png|h|v|m|c|l|file|nd|flat|u|style))";

# @all_sorts will hold all defined sorts
my @all_sorts = ();

# @all_tokens will hold all defined tokens
my @all_tokens = @builtin_tokens;

# a map with frozen strings
my %freeze_map = ();

# variables to store command line arguments
my $style = "bb";
my $compile_only = 0;
my $language_module_name = "";
my $language_file_name = "";
my $lang_name = "";
my $output_latex_file = "";
my $topmatter = "";
my $unquote = 0;
my $flat = 0;
my $shared = 0;
my $k_auto_incl = 0;
my $require_k_main = 0;
my $k_nd = 0;

# latex, pdf, eps, ps, png, crop
my $pdf = 0;
my $latex = 0;
my $eps = 0;
my $ps = 0;
my $png = 0;
my $crop = 0;
my $draft = 0;

# used for generating modules for KLabels
my $klabels = "";

my $kshared = File::Spec->rel2abs(File::Spec->catfile(File::Spec->curdir(), "shared.maude"));
my $mset = 0;

# variables to compile only one program
my $compileProgram = 0;
my $pgm   = "0";	# source file
my $cmod  = "0";	# compiled module name
my $pmod  = "0";	# program module name
my $pname = "0";	# program name

my $begin_compiled_module = "---K-MAUDE-GENERATED-OUTPUT-BEGIN---";
my $end_compiled_module   = "---K-MAUDE-GENERATED-OUTPUT-END---";

#########################
# </TOOL CONFIGURATION> #
#########################

my @kmodules = ();

my @newcommands = ();
my $newcommand_prefix = "ksyntax";
my $newcommand_counter = 0;
my $newcommand_base = 6;

# modules to be 
my @latexify_modules =();
my @pdf_modules = ();
my @ps_modules = ();
my @eps_modules = ();
my @png_modules = ();
my @crop_modules = ();

# clean the old temporary files
erase_temp();

# Process the command arguments
foreach (@ARGV) {
    if (($language_file_name eq "?") && !/^-/) {
#	$language_file_name = $_;
	$language_file_name = getFullName($_);
    }
    elsif (($language_module_name eq "?") && !/^-/) {
	$language_module_name = $_;
    }
    elsif (($style eq "?") && !/^-/) {
	$style = $_;
    }
    elsif (($topmatter eq "?") && !/^-/) {
	$topmatter = $_;
    }
    elsif (($output_latex_file eq "?") && !/^-/) {
	$output_latex_file = $_;
    }
    elsif (($pgm eq "?") && !/^-/) {
		$_ =~ s/\.k$//;
		$pgm = $_;
	}
	elsif (($pname eq "?") && !/^-/) {
		$pname = $_;
	}
	elsif (($cmod eq "?") && !/^-/) {
		$cmod = $_;
	}
	elsif (($pmod eq "?") && !/^-/) {
		$pmod = $_;
	}
    elsif (/^--?h(elp)?$/) {
# Terminates with usage info when asked for help
	$help = 1;
	terminate;
    }
    elsif (/^--?v(erbose)?$/) {
# By default, it is not verbose
	$verbose = 1;
    }
    elsif (/^--?m(audify)?$/) {
# By default, it maudifies and compiles
	$maudify_only = 1;
    }
    elsif (/^--?c(ompile)?$/) {
# By default, it maudifies and compiles
	$compile_only = 1;
    }
    elsif (/^--?l(ang|anguage)?$/) {
	$language_module_name = "?";
    }
    elsif (/^--?file$/) {
	$language_file_name = "?";
    }
    elsif (/^--?topmatter$/) {
	$topmatter = "?";
    }
    elsif (/^--?nd$/) {
       # $k_all_tools .= "-nd";
       $k_nd = 1;
    }
    elsif (/^--?lint$/) {
       $k_all_tools =  File::Spec->catfile($k_tools_dir,"lint");
    }
    elsif (/^--?draft$/)
    {
		$draft = 1;
    }
    elsif (/^--?flat$/) {
		$flat = 1;
    }
    elsif (/^--?output$/) {
		$output_latex_file = "?";
    }
    elsif (/^--?latex$/) {
		$latex = 1;
    }
    elsif (/^--?pdf$/) {
		$pdf = 1;
    }
    elsif (/^--?ps$/) {
		$ps = 1;
    }
    elsif (/^--?eps$/) {
		$eps = 1;
    }
    elsif (/^--?png$/) {
		$png = 1;
    }
    elsif (/^--?crop$/) {
		$crop = 1;
    }
    elsif (/^--?structural$/) {
		$structural = 1;
    }
    elsif (/^--?computational$/) {
		$computational = 1;
    }
    elsif (/^--?ndstrict$/) {
		$nd_strict = 1;
    }
 	elsif (/^--?pgm$/) { # start compile program param check
		$compileProgram = 1;
		$pgm = "?";
    }
	elsif (/^--?cmod$/) {
		$compileProgram = 1;
		$cmod = "?";
    }
	elsif (/^--?pmod$/) {
		$compileProgram = 1;
		$pmod = "?";
    }
	elsif (/^--?pname$/) {
		$compileProgram = 1;
		$pname = "?";
    } # end compile program param check
    elsif (/^--?style$/) {
		$style = "?";
    }
    elsif (/^--?u(nquote)?$/)
    {
		$unquote = 1;
		$additionalMaudeFlags .= " -xml-log=$maude_xml_file "
    }
    elsif (/^-prelude$/)
    {
		$shared = 1;
    }
    elsif ($shared)
    {
		$k_prelude = File::Spec->rel2abs($_);
		$shared = 0;
	}
    elsif (/^-/) {
		terminate("Unknown option $_");
    }
    elsif (($latex || $pdf || $ps || $eps || $png || $crop) && /[A-Z\-]+/)
    {
	# do nothing
	#	print "MODULES: $_\n";
    }
    elsif ($structural || $computational || $nd_strict)
    {
    	# do nothing
    }
    else {
		$language_file_name = getFullName($_);
    }
}

# print "LANG: $language_file_name\n";

# remove .k dir when a new compilation starts
File::Path->remove_tree($k_dir) if !$compileProgram;

# if I want to compile only a program
compile_program() if $compileProgram;

# Extract only language name without path
$lang_name = basename($language_file_name);
$lang_name =~ s/\..*?$//;

# Set latex out file name
$output_latex_file = $lang_name if $output_latex_file eq "";

#print "MODULES:\n   PDF $pdf\n   LATEX $latex\n   PS: $ps\n   EPS: $eps\n   PNG: $png\n   CROP: $crop\n\n";
# print "LANG: $language_module_name\nStyle:$style\nFile: $language_file_name\n\n";
# print "Latex header $topmatter\n";

my $args = "@ARGV";
# print "ARGS: $args\n";
# exit(1);


# get latex modules
if ($args =~ /--?latex\s+($modules_list)/)
{
    @latexify_modules = split(/\s+/, $1);
#    print "LATEX M: |@latexify_modules|\n"; 
}

# get pdf modules
if ($args =~ /--?pdf\s+($modules_list)/)
{
    @pdf_modules = split(/\s+/, $1);
#    print "PDF M: |@pdf_modules|\n"; 
}

# get ps modules
if ($args =~ /--?ps\s+($modules_list)/)
{
    @ps_modules = split(/\s+/, $1);
    # print "PS M: |@ps_modules|\n"; 
}

# get eps modules
if ($args =~ /--?eps\s+($modules_list)/)
{
    @eps_modules = split(/\s+/, $1);
#    print "EPS M: |@eps_modules|\n"; 
}

# get png modules
if ($args =~ /--?png\s+($modules_list)/)
{
    @png_modules = split(/\s+/, $1);
#    print "PNG M: |@png_modules|\n"; 
}

# get crop modules
if ($args =~ /--?crop\s+($modules_list)/)
{
    @crop_modules = split(/\s+/, $1);
#    print "CROP M: |@crop_modules|\n"; 
}

# get tags
if ($args =~ /\-\-?structural\s(.*)/s)
{
	$flag_structural = process_tags($1);
}

if ($args =~ /\-\-?computational\s(.*)/s)
{
	$flag_computational = process_tags($1);
}

if ($args =~ /\-\-?ndstrict\s(.*)/s)
{
	$flag_nd_strict = process_tags($1);
}

#print "STRUCT: $flag_structural\n";
#print "COMP: $flag_computational\n";
#print "ND: $flag_nd_strict\n";


# Check if an input file was given and exit if not
if ($language_file_name eq "") {
    terminate("No input file given");
}

# Check if both -m and -c are given together
if ($maudify_only && $compile_only) {
    terminate("Options -m and -c cannot be given together\n(-m/-c means \"only maudify/compile, do not compile/maudify\")");
}

# Check if the -c option is given together with a .k or .kmaude file
if ($compile_only && $language_file_name =~ /(?:.k|.kmaude)$/) {
    terminate("Option -c only works with a .maude file");
}

# Check that a $language_file_name was indeed given if -f option was used
if ($language_file_name eq "?") {
    terminate("Option -f|-file requires that a file name be given right after");
}

# Check that a $language_module_name was indeed given if -l option was used
if ($language_module_name eq "?") {
    terminate("Option -l|-lang|-language requires that a module name be given right after");
}

# Check that a $style was indeed given if -style option was used
if ($style eq "?") {
    terminate("Option -style requires that a style be given right after");
}

# Check that at least one module name was given with -latex option
if ($latex == 1 && !@latexify_modules) {
    terminate("At least one module name must be given right after -latex");
}

# Check that at least one module name was given with -pdf option
if ($pdf == 1 && !@pdf_modules) {
    terminate("At least one module name must be given right after -pdf");
}

# Check that at least one module name was given with -ps option
if ($ps == 1 && !@ps_modules) {
    terminate("At least one module name must be given right after -ps");
}

# Check that at least one module name was given with -eps option
if ($eps == 1 && !@eps_modules) {
    terminate("At least one module name must be given right after -eps");
}

# Check that at least one module name was given with -png option
if ($png == 1 && !@png_modules) {
    terminate("At least one module name must be given right after -png");
}

# Check that at least one module name was given with -crop option
if ($crop == 1 && !@crop_modules) {
    terminate("At least one module name must be given right after -crop");
}
# Create the module name, if not already given, by capitalizing the file name
    if ($language_module_name eq "") {
	$language_module_name = uc($language_file_name);
	$language_module_name =~ s/\.K$|\.KMAUDE$|\.MAUDE$|\.M$//;
    }


# Check the file for syntax errors
    setVerbose() if $verbose;
    
# build inclusion trees
appendFileInTree("$language_file_name", "");
recurseIntoFiles($language_file_name);

# flatten and maudify
if ($flat && $maudify_only)
{
    $language_file_name =~ s/\.k(maude)?$//;
	flattening($language_file_name);
    $language_file_name .= "-flat.k";
}

# flatten if only $flat is set
if ($flat && !$maudify_only)
{
    $language_file_name =~ s/\.k(maude)?$//;
	flattening($language_file_name);
	exit(0);
}

# Following is executed whenever the option -c was not selected
if (!$compile_only) {
# Maudify the .k|.kmaude files reachable from file "$language_file_name"
    print_header("Maudifying $language_file_name") if $verbose;

    # maudify
    maudify_file("$language_file_name","");
#    print "Maudification: $language_file_name\n\n";
    
    if ($klabels ne "")
    {
		my @tmp = split(/\s+/, $klabels);
		@tmp = uniq(@tmp);
		my $tmp = "ops @tmp : -> KLabel [metadata \"generated-label=()\"] . ";
		my $dir = cwd;
		open FILE,">",$kshared or die "Cannot create $kshared\n";
		my $prelude = basename($k_prelude);
#		print FILE "\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n";
		print FILE "mod K-SHARED is including K . \n\t$tmp\nendm";
		close FILE;
		push(@generated_files, $kshared);

		# add shared in language_file_name.maude
		my $top_file = $language_file_name;
		$top_file =~ s!\..+?$!!sg; # delete extension
		if ( -e "$top_file.maude" )
		{
			my $maudified = get_file_content("$top_file.maude");
		
			$maudified =~ s/^/in shared\.maude\n/sg;	

			open FILE,">", "$top_file.maude" or die "Cannot open $top_file.maude\n";
			print FILE $maudified;
			close FILE;
		}
	}

    
#    print_header("Done with maudifying $language_file_name") if $verbose;
    print_header("Data resulting from maudifying $language_file_name") if $verbose;
    print "Sorts:\n------\n@all_sorts\n\n" if $verbose;
    print "Tokens:\n-------\n@all_tokens\n" if $verbose;
    $language_file_name =~ s/(\.k|\.kmaude)$//;
    print "\n" if $verbose;

    print_header("New commands that will be added to the generated latex file") if $verbose && ($latex || $pdf || $crop || $ps || $eps || $png);
    print join("\n",@newcommands)."\n" if $verbose && ($latex || $pdf || $crop || $ps || $eps || $png);

}

# Following is executed whenever the option -m was not selected
if (!$maudify_only) {

# Remove .maude extension if there
    $language_file_name =~ s/\.maude$//;
    $language_file_name =~ s/\.k(maude)?$//;

# Since we eventually call Maude on $language_file_name, $language_file_name.maude must exist
    if (! -e "$language_file_name.maude") {
		print "HERE!\n\n";
#		terminate("File $language_file_name.maude does not exist");
    }



# Checking whether Maude is available
    # run_maude("Detecting Maude ... ", "quit\n");
	check_maude_instalation();	


	# Check incompatible sorts
	check_incompatible($language_file_name, $language_module_name) if (!($latex || $pdf || $ps || $eps || $crop || $png || $maudify_only));


# Calling either the maude compiler or the latex/pdf compiler, depending upon $latex/$pdf

    # add missing subsortations to K
    add_subsorts();

    if ($latex || $pdf || $ps || $eps || $png || $crop) 
    {
		make_latexify() if $latex;
		make_pdf() if $pdf;
		make_eps() if $eps;
		make_ps() if $ps;
		make_png() if $png;
		make_crop() if $crop;
    }
    else {
		compile();
    }
}




# Prints a visible message, like
# *************************
# *** Here is a message ***
# *************************
sub print_header {
    my $starred_line = my $text = "*** $_[0] ***";
    $starred_line =~ s/./*/g;
    print "\n$starred_line\n$text\n$starred_line\n\n";
}


sub latexify {
    
    my ($format, @modules) = @_;
  
    foreach(@modules)
    {
	if (!exist($_))
	  {
	      print "Module $_ doesn't exist in your defintion.\n" if emptyModuleList();
	      exit(1) if emptyModuleList();
	  }
    }
    
# Assumes $language_file_name is a file name with no extension

    print_header("Generate $format version for module $language_module_name from language definition $language_file_name") if $verbose;

# 
    $_ = run_maude("Getting modules META-MODULE and K-TECHNIQUE ... ",
		   "load $k_prelude\n",
#		   "show module META-MODULE .\n",
		   "show module K-TECHNIQUE .\n",
		   "quit\n");
    
    s/^Bye.//gms;
    s/(\[[^\[\]]*?)comm([^\[\]]*?\])/$1$2/gms;

    open FILE,">",$temp_file or die "Cannot create $temp_file\n";
    print FILE;
    close FILE;
    print "Temporary modules META-MODULE and K-TECHNIQUE written in $temp_file\n" if $verbose;

    my $latex_output = $_ =
	run_maude("Calling the Maude Latex-ifier ... ",
		  "load $k_prelude\n",
		  "load $language_file_name\n",
		  "set show advisories off .\n",
		  "load $temp_file\n",
		  "select META-LEVEL .\n",
		  "select $language_module_name .\n",
		  "set show advisories on .\n",
		  "load $k_to_latex\n",
		  "--- set print attribute on .\n",
		  "loop latex-print .\n",
		  map("(print $_ .)\n", @modules),
#		  "(print $language_module_name .)\n",
		  "quit\n");
    
    s/\\begin{module}.*?\\end{module}//gms;
    my @l_modules = ($latex_output =~ /(\\begin{module}.*?\\end{module})/gms);
    if (@l_modules && !/\\begin{module}/) {
	print "Latex style used: $style\n" if $verbose;
	

# File name where the compiled output will be stored:
	my $output_file_name = "$lang_name-$format.tex";
	open FILE,">",$output_file_name or die "Cannot create $output_file_name\n";
	print FILE "\\documentclass{article}\n" if !$draft;
	print FILE "\\documentclass[draft]{article}\n" if $draft;
	print FILE "\\usepackage{import}\n";
	print FILE "\\import{$k_latex_dir/}{k2latex.$style.sty}\n";
	
	my $abs_filename = $language_file_name;
	$abs_filename =~ s/\..*?$//;
    if (-e "$abs_filename.sty") {
	   print FILE "\\input{$abs_filename.sty}\n";
    }
	print FILE join("\n",@newcommands)."\n";

	print FILE "\n\n\\begin{document}\n";
	print FILE "\\begin{kdefinition}\n\n";
	
	# insert $topmatter here
	if ($topmatter ne "")
	{
		my $header = get_file_content($topmatter);
	        print FILE "% begin latex header \n";
		print FILE "$header\n";
		print FILE "% end latex header \n\n";
	}

	my $latex_temp = join("\\newpage", @l_modules)."\n";
	# $latex_temp = restore_intermodule_latex($latex_temp);
	
	print FILE $latex_temp;
	print FILE "\\end{kdefinition}\n";
	print FILE "\\end{document}\n";
	close FILE;
	
	# call the post-processor for latex
	my $postprocessor = File::Spec->catfile((File::Basename::fileparse($0))[1], 'postprocess_texcmds.pl');
	my $stat = system("perl $postprocessor $output_file_name thistemp");
	if (($stat >>= 8) != 0)
	{
	    print "Warning: cannot expand latex macros!\n";
	    unlink("thistemp");
	}
	else
	{  
	    # rename("thistemp.tex", "$lang_name-$format.tex");

	    # this is an ugly fix. Perl inserts sometimes whitespaces before
	    # each line
	    
	    my $elim_spaces = get_file_content("thistemp.tex");
	    unlink("thistemp.tex");
	    open F,">", "$lang_name-$format.tex" or die "Cannot create $lang_name-$format.tex\n";
	    $elim_spaces =~ s/\n\s*\\begin{verbatim}/\n\\begin{verbatim}/sgmi;
	    $elim_spaces =~ s/\n\s*\\end{verbatim}/\n\\end{verbatim}/sgmi;
	    print F $elim_spaces;;
	    close F;
	    
	    
	    print "Latex version written in $lang_name-$format.tex\n" if $verbose;
	}
    }
    else {
	print "ERROR: \\begin{module} ... \\end{module} not found in generated output\n";
	print "This error most likely due to wrong latex attributes\n";
	print "Check generated output in $output_file\n";
	open FILE,">",$output_file or die "Cannot create $output_file\n";
	print FILE $latex_output;
	close FILE;
	print "Aborting the compilation\n";
	exit(1);
    }
}

# run latex
sub run_latex
{
    my $tex_file = shift;
    
    # get approx pdf file
    my $latex_out = get_file_content("$tex_file.tex");
    $latex_out =~ s/^\\documentclass\[landscape\]/\\documentclass/;
    $latex_out =~ s/\\begin{document}/\\geometry{papersize={1400mm,11in},textwidth=1380mm}\\begin{document}\\thispagestyle{empty}/;
    $latex_out =~ s/\\newpage/\\bigskip/g;
    # print $latex_out;
    
    open FILE,">", "$tex_file-temp.tex" or die "Cannot create $tex_file-temp.tex\n";
    print FILE $latex_out;
    close FILE;

    # create pdf
    my $status = system("latex -interaction=nonstopmode $tex_file-temp.tex > out");
    if (($status >>= 8) != 0)
    {
		throw_error("Failed to run latex. Exit status $status.\nRun 'latex $tex_file-temp.tex' to see the error generated by latex.\n");
    }
    # get number of pages
    my $pages = 0;
    
    # latex acts weird.. it generates all the temp files in the same directory 
    # but the tex file in other directory
    # $tex_file =~ s/\.\.\///g;
    
    my $log = get_file_content("$tex_file-temp.log");
#    my $log = get_file_content("$lang_name-temp.log");
    if ($log =~ /(\d+)\s+pages?/)
    {
		$pages = $1;
    }
#    print "PAGES: $pages\n";

    unlink("out");
    unlink("$tex_file-temp.aux");    
    unlink("$tex_file-temp.mrk");    
    unlink("$tex_file-temp.log");    
    unlink("$tex_file-temp.dvi");    
    unlink("$tex_file-temp.tex");    
    return $pages;
}

sub get_file_content
{
    my $filename = shift;
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!";
    my @input = <FILEHANDLE>;
    close FILEHANDLE;
    
    return join("", @input);
}

# generates latex if $latex
sub make_latexify
{
    latexify("latex", @latexify_modules);
    rename("$lang_name-latex.tex", "$output_latex_file.tex");
    print "Generated $lang_name.tex which contains modules: @latexify_modules\n";
}

sub get_pdf_crop
{
    
    my ($format, @modules) = @_;

    latexify("$format", @modules);

    # Generate pdf
    for (my $run = 0; $run < 2; $run++) {
        my $status = system("latex -output-format=pdf -interaction=nonstopmode $lang_name-$format.tex> out");
        throw_error("Failed to run latex. Exit status $status.\nRun 'latex $lang_name-$format.tex' to see the error generated by latex.\n") if (($status >>= 8) != 0);

# Always run twice for now: the page width computation won't issue a rerun hint
# even if the computed width changed.
#        my $log = get_file_content("$lang_name-$format.log");
#        # Skip unnecessary extra runs.
#        unless ($log =~ /Rerun to get cross-references right/)
#        {
#            $run = 100;
#        }
    }
    
    unlink("$lang_name-$format.aux") if !$verbose;
    unlink("$lang_name-$format.mrk") if !$verbose;
    unlink("$lang_name-$format.log") if !$verbose;
    unlink("$lang_name-$format.tex") if !$verbose;
    unlink("$lang_name-$format.out") if !$verbose;
    unlink("out");
}

# generates pdf if $pdf
sub make_pdf 
{
    # Generate eps
    get_pdf_crop("pdf", @pdf_modules);
    rename("$lang_name-pdf.pdf", "$output_latex_file.pdf");
    print "Generated $lang_name.pdf which contains modules: @pdf_modules\n";
}

# generate ps if $ps
sub make_ps
{
    get_pdf_crop("ps", @ps_modules);

    # Generate ps
    my $status = system("pdf2ps $lang_name-ps.pdf 2>/dev/null");
    throw_error("Failed to generate ps. Exit status $status.\n") if (($status >>= 8) != 0);
    
    # rename ps file
    rename("$lang_name-ps.ps", "$output_latex_file.ps");
    print "Generated $lang_name.ps which contains modules: @ps_modules\n";
    
    # delete auxialiary files if not verbose
    unlink("$lang_name-ps.pdf") if !$verbose;
}

sub make_eps
{
    get_pdf_crop("eps", @eps_modules);

    # Generate ps
    my $status = system("pdf2ps $lang_name-eps.pdf 2>/dev/null");
    throw_error("Failed to generate ps temporary file for generating eps. Exit status $status.\nRun 'pdf2ps $lang_name-eps.pdf' to see the error generated by pdf2ps.\n") if (($status >>= 8) != 0);

    # Generate eps
    $status = system("ps2eps $lang_name-eps.ps 2>/dev/null");
    throw_error("Failed to generate eps. Exit status $status.\nRun 'ps2eps $lang_name-eps.tex' to see the error generated by ps2eps.\n") if (($status >>= 8) != 0);
    
    # rename eps file
    rename("$lang_name-eps.eps", "$output_latex_file.eps");
    print "Generated $lang_name.eps which contains modules: @eps_modules\n";

    unlink("$lang_name-eps.pdf") if !$verbose;
    unlink("$lang_name-eps.ps") if !$verbose;
}

sub make_png
{
    get_pdf_crop("png", @png_modules);

    # Generate png
    my $status = system("gs -q -dNOPAUSE -sDEVICE=pngalpha -dBATCH -dEPSCrop -r150 -sOutputFile=$lang_name-png.png $lang_name-png.pdf");
    throw_error("Failed to generate png. Exit status $status.\nRun 'gs -q -dNOPAUSE -sDEVICE=pngalpha -dBATCH -dEPSCrop -r150 -sOutputFile=$lang_name-png.png $lang_name-png.pdf' to see the error generated by gs.\n") if (($status >>= 8) != 0);

    # rename png file
    rename("$lang_name-png.png", "$output_latex_file.png");
    print "Generated $lang_name.png which contains modules: @png_modules\n";

    # delete auxialiary files if not verbose
    unlink("$lang_name-png.eps") if !$verbose;
    unlink("$lang_name-png.pdf") if !$verbose;
}

# generates a nice - pdf if $crop
sub make_crop
{
print "Calling make_crop\n";
    latexify("crop", @crop_modules);

    # modify page and save it
    my $latex_out = get_file_content("$lang_name-crop.tex");

    # Find number of pages
    my $pages = run_latex("$lang_name-crop");
    my $h = 9 * $pages;
    my $ph = $h + 1;
    $latex_out =~ s/^\\documentclass\[landscape\]/\\documentclass/;
    my $settings = "\\geometry{papersize={1400mm,".$ph."in},textheight=".$h."in,textwidth=1380mm}\\begin{document}\\thispagestyle{empty}\\noindent\\hspace{-2px}\\rule{1px}{1px}";
    $latex_out =~ s/\\begin{document}/$settings/;
    
    # initial settings
    open FILE,">", "$lang_name-crop.tex" or die "Cannot create $lang_name-crop.tex\n";
    print FILE $latex_out;
    close FILE;    

    # Generate pdf
    my $status = system("latex -output-format=pdf $lang_name-crop.tex > out");
    throw_error("Failed to run latex. Exit status $status.\nRun 'pdflatex $lang_name-crop.tex' to see the error generated by latex.\n") if (($status >>= 8) != 0);
    
    # Generate pdf-crop
    $status = system("pdfcrop $lang_name-crop.pdf > out");
    throw_error("Failed to generate crop pdf. Exit status $status.\nRun 'pdfcrop $lang_name-crop.pdf' to see the error generated by pdfcrop.\n") if (($status >>= 8) != 0);

    # print message
    rename("$lang_name-crop-crop.pdf", "$output_latex_file-crop.pdf");
    print "Generated $lang_name-crop.pdf which contains modules: @crop_modules\n";
    
    # delete auxialiary files if not verbose
    unlink("$lang_name-crop.pdf") if !$verbose && ($lang_name ne $output_latex_file);
    unlink("$lang_name-crop.tex") if !$verbose;
    unlink("$lang_name-crop.aux") if !$verbose;
    unlink("$lang_name-crop.dvi") if !$verbose;
    unlink("$lang_name-crop.log") if !$verbose;
    unlink("$lang_name-crop.tex") if !$verbose;
    unlink("out");
    
}


# Next routine compiles the language definition in $language_file_name
# It also performs some sanity checks
sub compile {
# Assumes $language_file_name is a file name with no extension
    

#    print "FILES: " . getFileList() . "\n\n";
#    exit(1);
# Testing whether the input module $language_module_name exists
    run_maude("Testing if the input module $language_module_name exists ... ",
			"load $k_prelude\n",
	      "load $language_file_name\n",
	      "show module $language_module_name .\n",
	      "quit\n");

    print_header("Compiling $language_file_name, starting with module $language_module_name") if $verbose;

# File name where the compiled output will be stored:
    my $output_file_name = "$language_file_name-compiled.maude";

	my $old_language_file = $language_file_name;
	my $old_language_module = $language_module_name;
	if ($require_k_main)
	{
		$language_file_name = $kmain . $language_file_name . ".maude";
		$language_module_name = uc($kmain) . $language_module_name;
		
		open TEMP, ">", $language_file_name or die "Cannot open $language_file_name";
		print TEMP "in $old_language_file\n";
		print TEMP "mod $language_module_name is including K + $old_language_module . endm\n";
		close TEMP;
		push(@generated_files, $language_file_name);
	}

# # Compiling the input module $language_module_name
    if ($unquote) {
       
		# If unquote is set then do some changes
		$_ = run_maude("Compiling the definition ... ",
			"load $k_prelude\n",
			"load $language_file_name\n",
			"load $k_all_tools\n",
			"set print attribute off .\n",
			"rew compile('$language_module_name, structurals(metadataParse(\"$flag_structural\")) computationals(metadataParse(\"$flag_computational\")) supercools(metadataParse(\"$flag_nd_strict\"))) .\n",
			"quit\n");
		
		my @lines = split(/\n/, $_);
		shift @lines;
		shift @lines;
		shift @lines;
		pop @lines;
		my $errorSet = 0;
		if ($lines[0] =~ s/result \[ModuleSet\]: (.*)$/$1/) {
			$errorSet = 1;
		}
		if ($errorSet) {
			print "ERROR:\n";
			print "Aborting the compilation\n";
			my $unquotedOutput = unquote($maude_xml_file);
			print "$unquotedOutput\n";
			unlink($maude_xml_file);
			exit(1);
		}
		my $unquotedOutput = unquote($maude_xml_file);
		unlink($maude_xml_file);
		$_ = "$begin_compiled_module$unquotedOutput$end_compiled_module";
    }
    else
    {
    my $compile_structurals = "\"$flag_structural\"";
    my $compile_computationals = "\"$flag_computational\"";
    my $compile_supercools = "\"$flag_nd_strict\"";    
	$_ = run_maude("Compiling the definition ... ",
		"load $k_prelude\n",
	    "load $language_file_name\n",
	    "load $k_all_tools\n",
            "---(\n",
            "red in COMPILE-ONESHOT : partialCompile(upModule('$language_module_name , false),'???,\n",
            "structurals(metadataParse(\"$flag_structural\")) computationals(metadataParse(\"$flag_computational\")) supercools(metadataParse(\"$flag_nd_strict\"))) .\n",
            "quit\n",
            "---)\n",
	    "loop compile .\n",
	    "(compile $language_module_name structurals $compile_structurals computationals $compile_computationals supercools $compile_supercools .)\n",
	    "quit\n");		
		unlink($maude_xml_file);
    }

# If the keyword "Error" begins a line in the output, then extract and report the error message
    if (/^Error: (.*?)Bye/sm) {
		print "ERROR:\n";
		print $1;
		print "Aborting the compilation\n";
		exit(1);
    }

# If the output contains a generated Maude file, then write it in $output_file_name
    if (/$begin_compiled_module(.*?)$end_compiled_module/s) {
		open FILE,">",$output_file_name or die "Cannot create $output_file_name\n";
	#	print FILE "\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n";	
		print FILE "load $k_prelude\n";
		print FILE $1;
		close FILE;
		push(@generated_files, $output_file_name);
		
		print "Compiled version written in $output_file_name.\n";
    }

# Otherwise there must be some error that the script is now aware of, so show the whole thing
    else {
		print "Unknown ERROR: cannot parse the output below (returned by the compiler):\n$_\n" if $_ ne "-1";
		print "Aborting the compilation\n";
		exit(1);
    }
}


# This is called whenever everything went fine, to clean up the temporary files
sub clean {
    unlink($input_file);
    unlink($output_file);
    unlink($error_file);
    unlink($temp_file);
}


# Running Maude (cross platform)
sub run_maude {
    my ($message,@commands) = @_;
    print $message if $verbose;
    open FILE,">",$input_file or die "Cannot create $input_file\n";
    print FILE "\n@commands\n";
    close FILE;

	# clean error file and output file
	unlink($output_file);
	unlink($error_file);

    # call maude
    my $status = system("$maude_path -no-banner -no-wrap $additionalMaudeFlags $input_file >$output_file 2>$error_file");
    
    my $err = get_file_content($error_file);
    my $out = get_file_content($output_file);
    
#    print "ERR: " . get_file_content($error_file) . "\n\n";
#    print "OUT: " . get_file_content($output_file) . "\n\n";
    
    if ($err =~ /\[ERROR\](.*?)\[ENDERROR\]/sg || $out =~ /\[ERROR\](.*?)\[ENDERROR\]/sg)
    {
		print "[ERROR] $1\n";
		print "Check $k_dir/$error_file to find all errors.\n";
		return -1;
    }
	elsif ($err =~ /[^\s]/)
	{
		if (countlines($err) > 5)
		{
			print "$&" if $err =~ /(.*?\n)(.*?\n)(.*?\n)(.*?\n)(.*?\n)/sg;
			print "Check $k_dir/$error_file to find all errors.\n";
		}
		else { print $err; }
#		return -1;
	}
    if ($out =~ /\[ERROR\](.*?)\[ENDERROR\]/sg)
    {
		print "[ERROR] $1\n";
		return -1;
    }


    
    if (($status >>= 8) != 0)
    {
		$err = get_file_content($error_file);
		$err =~ s/\n.*?$//sg;
		# print "$err\nFailed to run maude.\nExit status $status.\n" ;
		return -1 ;
		# exit(1);
    }

    if ($? == 0) {
	if (-s $error_file) {
	    open FILE,"<",$error_file or die "Cannot open $k_dir/$error_file\n";
	    print "ERROR:\n";
	    my $i = -1;
	    while (<FILE>) {
		++$i;
		my $err_msg = "";
		my $size = 180;
		$err_msg = "... (check /$k_dir\/$error_file to find the complete error)\n" if length($_) > $size;
		if ($i < 10) {
		    print substr($_, 0, $size) . $err_msg;
		}
		else {
		    $_ = substr($_, 0, $size) . $err_msg;
		    last;
		}
	    }
	    if (<FILE>) {++$i;}
	    close FILE;
	    print "...\nCheck /$k_dir\/$error_file for the remaining errors\n" if $i==11;
	    print printErrorFromOut();
	    print "Aborting the compilation\n";
	    exit(1);
	}
	print "DONE\n" if $verbose;
	local $/=undef;
	open FILE,"<",$output_file or die "Cannot open $output_file\n";
	local $_ = <FILE>;
	close FILE;
	clean();
	return $_;
    }
    else {
	print "\nMaude cannot be detected: the command $maude_path does not execute\n";
	print "Aborting the compilation\n";
	clean();
	exit(1);
    }
}


# The function maudify($file) does the following operations:
# 1) Maude-ifies $file in case it is a .k|.kmaude file, generating a .maude file
# 2) It does the same recursively on each included file
# 3) Updates the global variables @all_sorts and @all_tokens
# - one to the list of sorts that are declared in the $file or in its included files
# - another to the list of tokens that appear in operations declared in the $file or its included files
sub maudify_file {
# Bind $file and $indent (the latter used for pretty printing when$verbose
    my ($file,$indent) = @_;
# If $file has extension .k, .kmaude or .maude then tests if $file exists and errors if not
    
    # print "Process file: $file\n";
	$file = getFullName($file);
    
    addFile(File::Spec->rel2abs($file));
    print $indent."Processing file $file\n" if $verbose;
    $indent .= "|   ";

    # hardcoded for avoiding maudification for shared.maude
    if ($file =~ /shared\.maude/)
    {
		return;
    }
    
# Slurp all $file into $_;
    local $/=undef; open FILE,"<",$file or die "Cannot open $file\n"; local $_ = <FILE>; close FILE;

	# freeze
	s/($comment)/Freeze($&, "CMTS")/sge;

	# replace module with kmod and 
	# endmodule with endkm
	s/(module)(.*?\s)(end\s+?module)/kmod$2endkm/sg;
	
	# replace including with imports
	s/(?<!\S)imports(?!\S)/including/sg;


	# append "is" if necessary
	s/(kmod\s+\S+)(\s+)(?!is)/$1 is$2/sg;
	
	# unfreeze
	$_ = Unfreeze("CMTS", $_);

# Step: resolve latex comments
	# store_intermodule_latex($_);
    $_ = solve_latex($_) if ($latex || $png || $pdf || $ps || $crop || $eps);

    # save comments
    my ($noComments, $myComments) = remove_comments($_);
    $_ = $noComments;
    
    # Parse the configuration
    if (/configuration\s+(.*?)\s+(?=$kmaude_keywords_pattern)/sg)
    {
		# print "FILE: $file\n";
		parse_configuration($1, countlines($`), $file);
    }
    
    # resolve rule tags
	$_ = rule_tags($_);    
    
#    print ;
    
# add line numbers metadata
    $_ = add_line_numbers($_, $file);

#    print ;
    
# dots issue: change <cell>.</cell> into <cell> . </cell>
    s!<(.*?)>\.</\1>!<$1> \. </$1>!g;
    
# solve modules in imports
    s!^(\s*)(in|load|require)(\s+)(\S+)!
    {
		my ($spaces1, $imp, $spaces2, $path_imp) = ($1, $2, $3, $4);
		if ( $path_imp =~ m/modules/ )
		{
			$path_imp =~ s/^\///sg;
			$path_imp = File::Spec->catfile($k_base, $path_imp);
		}
		"$spaces1$imp$spaces2$path_imp";
    }
    !sgme;
    
# Replacing dots    
    $_ = replace_dots($_);
	my $temporary = $_;

    my $maudified = "";
    while ( s!^(\s*)($top_level_pattern)(\s*)!!sm ) 
	{
		(my $before, local $_, my $after) = ($1,$2,$3);
		if ( m!^kmod\s+(\S+)! ) 
		{
			print $indent."K module $1 ... " if $verbose;
			push(@kmodules,$1);
			my $mno = countlines($`) if ($temporary =~ /\Q$_\E/);
		    # print "$_\n\n$mno\n\n";
		    
			$_ = maudify_module($file, $mno, $_);
			print "DONE\n" if $verbose;
		}
		elsif ( m!^f?mod\s+(\S+)! ) 
		{
			print $indent."Maude module $1 ... " if $verbose;
			add_sorts($_);
			add_tokens($_);
			print "DONE\n" if $verbose;
		}
		elsif ( m!^(?:in|load)\s+(\S+)! ) 
		{
			maudify_file(maudify($1, $file), $indent);

			# store imported module
			store_import($1);

			s!\.k(maude)?\s*$!\.maude!s;
		}
		elsif ( m!^(?:require)\s+(\S+)! ) 
		{
			# print "File $file require: $1\n";
			my $import = $1;
			if (required($import))
			{
				maudify_file(maudify($1, $file), $indent);

				# store imported module
				store_import($import);

				s!\.k(maude)?\s*$!\.maude!s;
				s!require!in!sg;
			}
			else
			{
				s!require\s+\S+!!;
			}
		}
		else 
		{
		#	    print "Top level pattern:\n$_\n" if $verbose;
		}
        $maudified = "$maudified$before$_$after";
    }

    if (/\S/) 
    {
#        print "ERROR: Cannot finish processing $file\n";
#        print "ERROR: The following text does not parse:\n$_";
		print generate_error("ERROR", 1, $file, "unknown line", "Cannot finish processing $file\n");
		print generate_error("ERROR", 1, $file, "unknown line", "The following text does not parse:\n$_");
        exit(1);
    }
    
    $indent =~ s/\|   //;
    print $indent."Done with processing file $file\n" if $verbose;
    
    if ($file =~ /\.maude/) { return; }
    
    my $maude_file = ($file =~ /^(.*)\.k(?:maude)?$/)[0].".maude";
	print generate_error("WARNING", 1, $file, "unknown line", "Unbalanced parentheses in file $maude_file\nMaude might not finish...\n") if (!balanced($maudified, '(', ')', '`'));
#    print "Warning: Unbalanced parentheses in file $maude_file\nMaude might not finish...\n" if (!balanced($maudified, '(', ')', '`'));

	# put comments back
#	$maudified = put_back_comments($maudified, $myComments);

	# add k_license to it
#	$maudified =~ s!^!\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n!;

    open FILE,">",$maude_file or die "Cannot write $maude_file\n";
    print FILE $maudified;
    close FILE;

	push(@generated_files, $maude_file);
}


sub maudify_module {
    (my $file,my $mno, local $_) = @_;

	# add K or K-LATEX automatically.
    $_ = addKandKLATEX($_, $file, $mno);

    build_module_tree($file, $_);
#    print "Maudifying module with tokens @all_tokens\n";

	my $mname = $1 if /kmod\s+(\S+)/sg;
	
	if (!$k_auto_incl && $mname eq $language_module_name && !includesK($language_module_name))
	{
#		print "[Warning] K could not be automatically included in module $language_module_name ($file:$mno)\n";
		$require_k_main = 1;
	}

# Step: resolve macros
    s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTR")/gse;
    s!((?:$kmaude_keywords_pattern).*?)(?=(?:$kmaude_keywords_pattern|$))!resolve_where_macro($1)!gse;
	$_ = Unfreeze("ATTR", $_);

# Step: desugar latex newline <br/>
    $_ = desugar_latex($_);

# Step: Add whitespace between cell and Klabel
    s!(<\s*\/?\s*[^\s<]+\s*>)(')!$1 $2!g;

    # get KLabels
	# freeze strings :-D
#	print "$_\n\n";
    s/($string_pattern)/Freeze($&,"STRINGS")/sge;	
#	print "$_\n\n";
    my $decl = getKLabelDeclarations($_);
	# unfreeze strings
	$_ = Unfreeze("STRINGS", $_);

# Step: Add to @all_sorts all sorts defined in  k-prelude
	add_kprelude_sorts($k_prelude, dirname($k_prelude)) if !$k_prelude_loaded;
	$k_prelude_loaded = 1;

# Step: Add to @all_sorts all sorts defined a la Maude, with "sort(s)"
    add_sorts($_);
    
# Step: Freeze on-the-fly anonymous variable declarations
    s!_(:$ksort)!?$1!sg;
    s!(\?:$ksort)!Freeze($1,"ANONYMOUS")!ge;
    # print  "Stage:\n$_\n\n";
    
# Step: Desugar syntax N ::= Prod1 | Prod2 | ... | Prodn
# At the same time, also declare N as a sort if it is not declared already
	# freeze strings and attributes
   	s/($string_pattern)/Freeze($&,"MYSTRINGS")/sge;
    s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTRIBUTES")/gse;
    s!(syntax\s+.*?)(?=$kmaude_keywords_pattern)!make_ops( (countlines($`) == 0 ? $mno : countlines($`) + $mno - 1), $file, $1)!gse;

	# unfreeze attributes if any
    $_ = Unfreeze("ATTRIBUTES", $_);
	$_ = Unfreeze("MYSTRINGS", $_);
#     print  "Stage:\n$_\n\n";
    
# Step: Declare the on-the-fly variables
    $_ = on_the_fly_kvars($_);
    # print  "Stage:\n$_\n\n";
    
# Step: Reduce cell notation with _ to cell notation with ...
    s/\sops?\s(.*?):/Freeze($&,"OPS")/gse;
    s!<(\s*[^\s<]+\s*)_\s*>!<$1>... !gs;
    s!<\s*_(\s*/\s*[^\s>]+\s*)>! ...<$1>!gs;
    $_ = Unfreeze("OPS", $_);
#    print  "Stage:\n$_\n\n";
    
# Step: Declare cell labels as operations
    $_ = add_cell_label_ops($_);
#    print  "Stage:\n$_\n\n";
    
# Step: Add the module's newly defined tokens to @tokens
    add_tokens($_);
#     print  "Stage:\n$_\n\n";
    
# Step: Add missing spaces around tokens
	# freeze all attributes
	s/((?<!`)\[\s*($k_attributes_pattern).*?(?<!`)\])(\s*)(?=$kmaude_keywords_pattern)/{Freeze($1, "ATTR").$3;}/gse;

#print "FROZEN: $_\n\n";

    # freeze all strings before spacifying
	s/($string_pattern)/Freeze($&,"STRINGS")/sge;
	my $klabelss = $decl;		
	$klabelss =~ s/\s+$//s;		
	my @kls = split(/\s+/, $klabelss);		
	foreach my $kl (@kls)		
	{		
		s/(\Q$kl\E)/Freeze($kl, "KLABEL")/sge;		
	}

	$_ = spacify($_);

	$_ = Unfreeze("ATTR", $_);
	$_ = Unfreeze("STRINGS", $_);
	$_ = Unfreeze("KLABEL", $_);

#	print "$_\n\n";
#	print "============================\n\n\n";
    
# Step: Change .List into (.).List , etc.
    s!\.(K|List|Set|Bag|Map)([^\w\{])!(.).$1$2!gs;
#    print  "Stage:\n$_\n\n";
    
# Step: Replace remaining _ by ? (spaces were put around _ by spacify)
    s! _ ! ? !gs;
#     print  "Stage:\n$_\n\n";
    

# Step: Change K statements into Maude statements
	# freeze attributes first.. because sending parameters is dangerous: see ":"!!!
	s/((?<!`)\[\s*($k_attributes_pattern).*?(?<!`)\])(\s*)(?=$kmaude_keywords_pattern)/{Freeze($1, "ATTR").$3;}/gse;
#	s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTR")/gse;
	
	# also freeze rule names
	s!(?<=rule\s)(\s*\[.*?\])!Freeze($&, "NAMES")!sge;

	# maudify
    s!((?:$kmaude_keywords_pattern).*?)(?=(?:$kmaude_keywords_pattern|$))!k2maude($1)!gse;

	# unfreeze if there are still frozen attributes
	$_ = Unfreeze("ATTR", $_);
#	print  "Stage:\n$_\n\n";
   
# Step: add line numbers for mb configuration and latex 
	$_ = add_line_no_mb($file, $mno, $_);
#	print "Stage: \n$_\n\n";
	
# Step: Unfreeze everything still frozen
    $_ = Unfreeze("ANONYMOUS", $_);
#    $_ = unfreeze($_);
    # print  "Stage:\n$_\n\n";

# Step: Add KLabel generated definitions - do that in shared.k for now
    if ($decl ne "")
    {
		$klabels .= $decl;
		s!mod(\s+)([\S]+)(\s+)is(\s+)!"mod$1$2$3is including K-SHARED .$4"!se;
		$mset = 1;
    }
#    print  "Stage:\n$_\n\n";

# Step: register all subsort relations
    register_subsorts($_);

# Step: check balanced parentheses - maude specific
    my $module_name = $1 if (/k?mod\s+([a-zA-Z\-]+)\s+is/);

	print generate_error("WARNING", 1, $file, "unknown line", "Unbalanced parentheses in module $module_name\nMaude might not finish.\n") if (!balanced($_, '(', ')', '`'));

    return $_;
}


# Takes a syntax statement and extracts sorts, subsorts and operations
sub make_ops {
    my $sno = shift;
    my $file = shift;
    local ($_) = @_;
    
#    print "$_\n\n$sno\n\n\n";
    
#	print "Frozen: $_\n";
    $_ = Unfreeze("ATTRIBUTES", $_);
    $_ = Unfreeze("MYSTRINGS", $_);
#	print "Unfrozen: $_\n";
#    print "make_ops:\n$_\nat line $sno\n";

# 	keep temporary four counting lines
	my $temporary = $_;

# Grab the result sort and the productions, as well as all spacing
 	my ($spaces1,$result_sort,$spaces2,$bnf,$productions,$spaces3) =  /^syntax(\s+)(\S*)(\s*)(::=)(.*?\S)(\s*)$/s;
#	print "$result_sort\n";
#	print "\$productions\n$productions\n";

# Report error and stop if the BNF form is not respected
	if (!defined($bnf)){
#		print "ERROR: Syntactic categories must contain \"::=\" at line:\n$_\n";
		print generate_error("ERROR", 1, $file, "unknown line", "Syntactic categories must contain \"::=\" at line:\n$_\n");
		exit(1);
	}

# Report error and stop if the sort name does not match $ksort
	if ($result_sort !~ /^$ksort$/) {
	    print generate_error("ERROR", 1, $file, "unknown line", "Sort \"$result_sort\" does not match the pattern \"$ksort\" in\n$_\nSyntactic categories must currently match this pattern\n");
	    exit(1);
	}

# Add $result_sort to @all_sorts if not already there
	my $sort_decl = "";
	if ( ! (grep { "$_" eq "$result_sort" } @all_sorts) ) {
	    $sort_decl = "sort $result_sort";
	    push(@all_sorts, $result_sort);	    
	}

        my $result = "$spaces1 $sort_decl $spaces2";

# Extract all productions in @productions
	my @productions = ($productions =~ /(.*?\S.*?(?:\s\|\s|$))/gs);

#        print "PRODS: ".join("#",@productions)."\n";
	foreach my $production (@productions) {
	    
		# count line numbers
		my $absolute_line = countlines($PREMATCH) + $sno - 1 if ($temporary =~ /\Q$production\E/);

# Removing the | separator
		$production =~ s/(\s)\|(\s)/$1$2/gs;

# Getting the operation attributes, if any
		my $attributes = "";

		# freeze strings before extracting the attributes because these can contain
		# some [] which will cause a wrong extraction
		$production =~ s/($string_pattern)/Freeze($&,"MYS")/sge;	
		$production =~ s/(\[[^\[\]]*\]\s*)$/
						{
							if (op_attribute($1)) {
								$attributes = $1;
								"";
							} else {$1;}
						}/se;
		$production = Unfreeze("MYS", $production);
#		print "ATTR: $attributes\n";

# Removing the spaces before and after the actual production
		my ($space4,$space5) = ("","");
		$production =~ s/^(\s*)(.*?\S)(\s*)$/
						{
							$space4 = $1;
							$space5 = $3;
							$2
						}/se;

# Extracting the list of sorts in the production, then replacing the sorts by "_"
		my @sorts = ($production =~ m/((?:^|\s)$ksort(?=\s|$))/g);
		$production =~ s/(?:^|\s)$ksort(?=\s|$)/_/g;
		$production =~ s/\s*_\s*/_/gs;

#	    print "==============================\n";
#	    print "Production1:\n$production\n";
	    
# Replacing spaces in the production by "`"
#	        $production =~ s/\s+/`/gs;
	        
	    # Ugly hack: replace all strings with !&!&! 
	    # to avoid replacing spaces inside strings
	    my $strings = "";
	    $production =~ s/(\".*?\")/ { 
			$strings .= "!&!&!$1"; 
	    }
	    "!&!&!"
	    /gse;
	    
	    # replace spaces
	    $production =~ s/\s+/`/gs;

#	    print "Production2:\n$production\n";
	    # put the strings back
	    while ($strings =~ m/!&!&!(\".*?\")/g)
	    {
			my $str = $1;
			$production =~ s/!&!&!/$str/;
	    }
	    
	    
#	    print "Production3:\n$production\n";
#	    print "String:\n$strings\n";
#	    print "==============================\n";

# Removing unnecessary `
		$production =~ s/(^|$maude_special)`/$1/gs;
		$production =~ s/`($|$maude_special)/$1/gs;



#	    print "PROD: $production\n";
# Add a latex attribute in case $latex and there is not already a user-defined one
		if (($latex || $pdf || $png || $ps || $eps || $crop) && ($attributes !~ /latex/)) {
				my $latex_text = $production;
				my $counter = 0;
				$latex_text =~ s/([^_]+)/"\\terminal\{".make_latex($1)."\}"/gse;
				$latex_text =~ s/_/$counter++;"{#$counter}"/ges;
				$latex_text =~ s/"/&!&!&!/g;
				if ($attributes eq "") {
				$attributes = "[]";
		    }
		    $attributes =~ s/^\[/[latex "$latex_text" /;
		}


	
	# unfreeze here what was frozen in $production
	$attributes = Unfreeze("MYS", $attributes);

	$attributes = op_tags($attributes);
	
#	print "Add metadata to: $attributes\n\n";


#		print "PROD: $production\n\n";
# Generate the Maude replacement of the K syntactic construct
		my $random = fresh("a", "b");
		unlink($random);
		$random =~ s/[a-z_]//sg;
		if ($latex || $pdf || $ps || $crop || $eps || $png)
		{
			$result .= ($production eq "_")
						? "$space4 subsort @sorts < $result_sort op k2Latex@sorts"."2$result_sort$random"."_ : @sorts -> $result_sort $attributes $space5 "
						: "$space4 op $production : @sorts -> $result_sort$space5 $attributes ";
		}
		else {
			$result .= ($production eq "_")
						? "$space4 subsort @sorts < $result_sort$space5 "
						: "$space4 op $production : @sorts -> $result_sort$space5 $attributes ";
		}
	}

# print "Done\n";
#        print "RESULT:$result\n";
	return "$result$spaces3";
}


sub op_attribute {
	local ($_) = @_;
	/strict|prec|hybrid|gather|metadata|latex|ditto|format|assoc|comm|id:/;
}


sub make_latex {
    local ($_) = @_;
    s/(\W)`/$1/gsm;
    s/`(\W)/$1/gsm;
    s/`/ /gsm;
    s/($latex_special)/\\$1/gsm;
    return $_;
}

sub k2maude {
    local ($_) = @_;

    $_ = Unfreeze("ATTR", $_);
	$_ = Unfreeze("NAMES", $_);

#	print "TODO: $_\n";

	# macros
    s/macro(\s)/eq$1/gs;
    
    switch ($_) {
	case /^kmod/                    { s/kmod/mod/; }
	case /^endkm/                   { s/endkm/endm/; }
	case /^$default_freezer/        {}
	case /^mb/						{
										s/^mb\s+latex(.*\S)(\s*)$/mb latex $1 .$2/sg;
									}
	case /^kvar/                    { s/k(var.*\S)(?=\s*)/$1 ./; }
 	case /^rule/                    { s/^(.*\S)(\s*)$/mb $1 : KSentence .$2/sg;
									  s!(\[[^\[\]]*\]) : (KSentence)!
									  (rule_attribute($1))?": $2 $1":"$1 : $2"!se;
									  s!^mb(\s+)rule(\s+\[[^\[\]]*\]\s*:)!mb$2$1rule!s;
									}
	case /^context/                 { s/^(.*\S)(\s*)$/mb $1 : KSentence .$2/sg;
									  s!(\[[^\[\]]*\]) : (KSentence)!
									  (rule_attribute($1))?": $2 $1":"$1 : $2"!se;
									  s!^mb(\s+)context(\s+\[[^\[\]]*\]\s*:)!mb$2$1context!s;
							        }
	case /^(configuration)/         { s/^(.*\S)(\s*)$/mb $1 : KSentence .$2/s; }
	else                            { s/(\S)(\s*)$/$1 .$2/s; }
    }
    return $_;
}


sub rule_attribute {
    local ($_) = @_;
    /metadata|label/;  # add more keywords/patterns to recognize rule attributes
}


# Extract the K attributes and make them Maude metadata
sub make_metadata {
    local ($_) = @_;
    my @k_attributes = ();
    my $have_k_attributes = 0;

# Match the K specific attributes below and make them into metadata
# Right now it assumes that no \" can appear inside the metadata string
# Therefore, the latex attribute is expected to be outside

	# unfreeze ...
	$_ = Unfreeze("MPGF", $_);

	# freeze locations
#	s/location\(.*?\)/Freeze($&, "LOCATIONS")/sge;
	
	# this freezes the all string, including those inside latex declarations
   	s/($string_pattern)/Freeze($&,"MTR")/sge;

#	print "=========\nIN: $_\n=============\n";


    s!(ditto|large|structural|hybrid|arity\s+\d+|(?:seq)?strict(?:\s*\((?:\s*\d+)*\s*\))?|latex\s+\w+)|metadata\s+(\w+)!
    my $out = "";
#	print "\tMatched: $&\n\n";
	if (defined $1) {
	    local $_ = $1;
        $have_k_attributes = 1;
		$_ = Unfreeze("MTR", $_);
#		print "\tTDG: $_\n";
		if (/^latex\s+"([^"]*?)"$/gs) 
	    {
#			print "Latex attribute $1\n";
			my $la = $1;
			$la = Unfreeze("M", $la);
			push(@k_attributes, "latex=(renameTo \\\\".get_newcommand($la).")") if ($latex || $pdf || $crop || $ps || $eps || $png);
	    }
	    else {
#			print "Push: $_\n\n";
			push(@k_attributes, $_);
	    }
	    $out = "ditto" if $1 =~ m/ditto/;
	}
    else {
		my $data = $2;
		$data = Unfreeze("MTR", $data);
		$data =~ s/(^")|("$)//sg;
#			print "Here: $data\n";
		push(@k_attributes, $data);
      }
		$out
	!gse;
    
	$_ = Unfreeze("MTR", $_);
#	print "STILL: $_\n";
	
#    print "K attributes: @k_attributes\n==============\n\n";

    if (@k_attributes) 
	{
#	print "->@k_attributes<-\n";

# print "META: $_\n";
		if (/(metadata\s+)($string_pattern)/sg)
		{
			s!(metadata\s+)(\")(.*?)(\")!"$1$2$3 @k_attributes$4"!se;
		}
		else
		{
			s!(.)\]$!"$1".(($1=~/[\s\[]/s) ? "":" ")."metadata \"@k_attributes\"\]"!se;
		}
	#	print "$_\n";
    }
    elsif ($have_k_attributes) {
        s/^\s*\[\s*\]\s*$//gs;
    }

#	print "OUT: $_\n\n";
   return $_;
}


sub get_newcommand 
{
    local ($_) = @_;
    s/&!&!&!/"/g;
#    print "Apelat.\n";
    my $n = $newcommand_counter++;
    my $newcommand = $newcommand_prefix.chr(65 + $n % $newcommand_base);
    while ($n >= $newcommand_base) {
		$n /= $newcommand_base;
		$newcommand .= chr(65 + $n % $newcommand_base);
    }

    my @args = sort /{#(\d+)}/gms;
    my $max = $args[$#args];
    my $args = @args ? "\[$max\]" : "";
    s/\\\[/[/g;
    s/\\\]/]/g;
    s!(\{\#\d+\})(\{\#\d+\})!$1\\mathrel{}$2!g;
    push(@newcommands, "\\newcommand\{\\$newcommand\}$args\{$_\}");
    s/terminal/terminalNoSpace/gs;
    my $newcommandNoSpace = $newcommand."NoSpace";
    push(@newcommands, "\\newcommand\{\\$newcommandNoSpace\}$args\{$_\}");
#    print "Comanda: $newcommand\n";
    return $newcommand;
}


# Extract and declare on-the-fly kvariables
sub on_the_fly_kvars {
    local ($_) = @_;
    my %kvar_decls = ();
    s/\b($kvar):($ksort)/
    {
	if ($kvar_decls{$1}) {
	    if ($kvar_decls{$1} ne $2) {
		print "WARNING: Variable $1 declared with two distinct sorts ($kvar_decls{$1} and $2)\n" if $verbose; 
#		exit(1);
	    }
	} 
#    else {
	    $kvar_decls{$1} = $2;
#	}
	"$1:$2";
    }
    /gse;
    my $kvars = "";
    while (my ($key,$val) = each %kvar_decls) {
	$kvars .= "kvar $key : $val ";
    }
    s/(?=endkm)/$kvars?"$kvars ":""/se;
    return $_;
}

# If there is any configuration, get all its cell labels and declare them at the end of kmodule
sub add_cell_label_ops_ {
    local ($_) = @_;
    my $ops = (/(?<=\s)configuration\s+(.*?)(?:$kmaude_keywords_pattern)/s
	       ? "ops ".join(" ",set($1 =~ /<\s*\/?\s*(.*?)\s*[\*\+\?]?\s*>/gs))." : -> CellLabel " : "");
    s/(?=endkm)/$ops?"$ops ":""/se;

	# switch to old accepted configuration
	my $i = 0;
	while ($i < 20)
	{
		s!<\s*([a-zA-Z\-]+)\s+multiplicity="(.*?)"\s*>(.*?)<\/\1>!<$1$2>$3</$1$2>!s;
		$i++;
	};

    return $_;
}

sub add_cell_label_ops
{
	local $_ = shift;
	if (/(?<=\s)configuration\s+(.*?)(?=$kmaude_keywords_pattern)/s)
	{
		parse_configuration($1, 0, "$language_file_name.k");
		my $label_declarations = get_cell_label_declarations();
		s/(?=endkm)/ $label_declarations /s;

		# switch to old accepted configuration
		# replace multiplicity		
#		my $i = 0;
#		while ($i < 20)
#		{
#			s!<\s*([a-zA-Z\-]+)\s+multiplicity="(.*?)"\s*>(.*?)<\/\1>!<$1$2>$3</$1$2>!s;
#			$i++;
#		};

		# replace color attribute
#		s!<\s*([a-zA-Z\-]+)\s*color=".*?"\s*>!<$1>!sg;
	}

	$_;
}

# This subroutine returns a list of all spacifiable tokens that appear in operations defined (using op) in the argument
# By spacifiable tokens we mean ones that the tool may need to add spaces to their left and/or right
sub add_tokens {
    local $_ = shift;
# Extracting all the defined operations
#    my @ops = grep(split(/\s+/s, $_), /\sops?\s+(.*?)\s+:\s+/gms);
    my @ops = /\sops?\s+(.*?)\s+:\s+/gms;

# Put all operations in one string
    $_ = "@ops";

    # Exclude strings because they can contain whitespaces
    my $strings = "";
    s/(\".*?\")/{$strings .= "$1!&!&!"; } "!&!&!"/gse;
    my @strs = split(/!&!&!/, $strings);
    
# Keep those operation names which have no _ or ` as tokens
    my @tokens = grep(!/[_`]/,split(/\s+/s));

#    print "TOKENS: @tokens\n";
# Extract all tokens that appear in operations
    @tokens = (@tokens, /$maude_special?($maude_unspecial+)/g) ;

    # Put the strings back
    my $index = 0;
    foreach my $token (@tokens)
    {
	while ($token =~ /!&!&!/g)
	{
	    $token =~ s/!&!&!/$strs[$index]/ if defined $strs[$index];
	    $index ++;
	}
    }
    
    
# Add allmeaningful tokens in @tokens to @all_tokens
    @all_tokens = set(@all_tokens, grep(/\W/, set(@tokens)));
}

# This subroutine returns a list of all spacifiable tokens that appear in operations defined (using op) in the argument
# By spacifiable tokens we mean ones that the tool may need to add spaces to their left and/or right
sub add_sorts {
    local $_ = shift;

# Extracting all the defined sorts
    my @sorts = /\ssorts?((?:\s+$ksort)+)\s+(?=\.|$kmaude_keywords_pattern)/gs;

#    print "\nSORTS: @sorts\n";

    @sorts = split(/\s+/, "@sorts");
	
#    print "Adding sorts: @sorts\nModule: $_\n" if $verbose;
# Add these sorts to @all_sorts
    @all_sorts = set(@all_sorts, @sorts);

# Add all sorts with alphanumerics to @all_tokens as well
    @all_tokens = set(@all_tokens, grep /\W/, @sorts);
}

# Next subroutine takes a string (most likely a kmaude module),
# and returns a string obtained from the original one by adding spaces to the left and/or
# to the right of tokens in the string; recall that the global @all_tokens holds all tokens
sub spacify {
    my ($lines) = @_;
    my @dag;
    my %index;     # holds index of each token
    my @array;     # holds token associated to each index
    my $i=0;

    my @all = join("\n", @all_tokens);
#    print "TOKENS: @all\n\n";
    
# First associate each token with a distinct number
    foreach my $token (@all_tokens) {
	$array[$i] = $token;
	$index{$token} = $i++;
    }

# Then create a dag as a an array of arrays over indexes
    for $i (0..$#array) {
	(my $token_pattern = $array[$i]) =~ s/([$special_perl_chars])/\\$1/g;
	$dag[$i] = [map($index{$_}, grep(/.$token_pattern|$token_pattern./, @all_tokens))];
    }

# Freeze all excluded substrings, which we do NOT want to be spacified
    $lines =~ s/($exclude)/freeze($1)/gmse;
    
# Spacify and then freeze each token in reversed topological order
# This way, we are sure that a subtoken of a token will never be spacified
    foreach my $token (map($array[$_], reverse(topological_sort(@dag)))) {
	(my $token_pattern = $token) =~ s/([$special_perl_chars])/\\$1/g;
	$lines =~ s/(.)($token_pattern)((?=.))/add_spaces($1,$2,$3)/gse;
    }
 
# Dirty hack: add spaces around anonymous variables, so that they will be properly
# translated into ? later on
    $lines =~ s/_/ _ /gs;
    
# Next unfreeze all tokens and return the spacified string
    return unfreeze($lines);
}


# Pass it as input a list of array references; these specify that that index into the
# list must come before all elements of its array.  Output is a topologically sorted
# list of indices, or undef if input contains a cycle.  Note that you must pass an array
# ref for every input elements (if necessary, by adding an empty list reference)! 
sub topological_sort {
    my @out = @_;
    my @ret;

# Compute initial in degrees
    my @ind;
    for my $l (@out) {
    ++$ind[$_] for (@$l)
    }

# Work queue
    my @q;
    @q = grep { ! $ind[$_] } 0..$#out;

# Loop
    while (@q) {
	my $el = pop @q;
	$ret[@ret] = $el;
	for (@{$out[$el]}) {
	    push @q, $_ if (! --$ind[$_]);
	}
    }

    return @ret == @out ? @ret : undef;
}


# Adds spaces before and/or after token, if needed
sub add_spaces {
    my ($before,$token,$after) = @_;
#    print "BEFORE: $before\nTOKEN: $token\nAFTER: $after\n\n";
    if ($before =~ /\w$/ && $token =~ /^\w/) { return "$before$token"; }
    if ($after =~ /^\w/ && $token =~ /\w$/) { return "$before$token"; }
    return ($before.(($before =~ /$maude_special/) ? "":" ").freeze($token).(($after =~ /$maude_special/) ? "":" "));
}


# Makes certain (sub)strings special, so that they stay "frozen" until other substitutions are complete
sub freeze {
    my $string = shift;
#    print "Freezing: |$string|\n";
    my $marker = "$default_freezer\b";
    if (@_) {
	$marker = shift;
    }
    
    return "$marker".join("$specialSymbol",map(ord,(split('',$string))))."$specialSymbol";
}

# Makes concrete all the frozen (sub)strings
sub unfreeze {
    my $all = shift;
    my $marker = "$default_freezer\b";
    if (@_) {
	$marker = shift;
    }

    $all =~ s/$marker(\d+(?:$specialSymbol\d+)*)$specialSymbol/join("", map(chr, split("$specialSymbol",$1)))/gse;

    return $all;
}

# a new version of freezing: use digest - md5
sub Freeze
{
    my ($string, $marker) = (shift, shift);
    my $frozen_string = $marker . md5_hex($string); #join("", map(ord, split('',md5($string))));
    $freeze_map{$marker}{$frozen_string} = $string;
    
   return $frozen_string;
}

# unfreezing (newest version) : use digest - md5
sub Unfreeze
{
    my ($marker, $all) = (shift, shift);
    my $marker_map = $freeze_map{$marker};
	if (defined $marker_map)
	{
		my %map = %$marker_map;

		$all =~ s/($marker([a-f0-9]{32}))/defined $map{$1}?$map{$1}:$1/gse;

	#    while (my ($key, $value) = each(%$marker_map)) {
	#        $all =~ s/$key/$value/sg;
	#    }
	}
    return $all;
}

# Takes a list and eliminates duplicates from it
sub set {
    my %hash = map { $_,1 } @_;
    return keys %hash;
}


# Report error and exit
sub throw_error
{
    my $err = shift;
    print "$err\n";
    exit(1);
}


sub add_subsorts
{
    my $supersorts = find_super_sorts();
    my @modules = split(/\s+/, getModuleList());
    my $dir = cwd;
    
    return if (scalar(@modules) == 0);
    return if ($supersorts eq "");
    
    my @sorts = split(/\s+/, $supersorts);
    $supersorts = "";
    foreach(@sorts)
    {
		$supersorts .= "$_ " if ($k_sorts !~ /#$_#/);
    }
    
    return if ($supersorts eq "");
    
    # get all supersorts in an array
    my @ssorts = split(/\s+/, $supersorts);

    # search through all modules
    foreach(@modules)
    {
		my $cmod = $_;
		# get sorts for current module
		my $sortlist = "#" . getModuleSorts($cmod) . "#" if defined(getModuleSorts($cmod));
		$sortlist =~ s/ /#/g if defined($sortlist);
	
#		print "File: " . getModuleFile($_) . ", SORTS: $sortlist\n\n";

		# if this module contains sorts
		# and it is a module which includes K
		# then add apropriate subsortations
		if (defined($sortlist) && includesK($cmod))
		{
			# will collect declared sorts
			my @decllist = ();
			# search through supersorts all sorts contained by this module
			foreach my $ss (@ssorts)
			{
				push(@decllist, $ss) if ($sortlist =~ /#$ss#/);
			}

			if (scalar(@decllist) > 0)
			{
		        # get module file
				my $file = getModuleFile($_);
			
				# access its maude corresponding file
				$file =~ s/\.k$/\.maude/;

				# get content
				my $content = get_file_content("$dir/$file");
		
				my $o = "@decllist";
				$content =~ s/mod(\s+)$_(\s.*?)endm/mod$1$_$2 subsorts $o < K \. endm/sg;

				open FILE,">",$file or die "Cannot create $file\n";
				print FILE $content;
				close FILE;
			}
		}
    }
    
#    print "SUPERSORTS: $supersorts\n";
#    print "MODULES: @modules\n";
}

# compile only a single program
# steps:
# maudify the file
# append the $compile text to the end of the maudified file
# call maude
# remove maude wrappers
# write result to $pgm-comipled.maude
# remove temp files
# exit kompilation (the action is dedicated, the rest of the actions are ignored)
sub compile_program
{
	if ($pgm eq "0" or $cmod eq "0") {
		print "To compile a single program you need to specify at least -pgm and -cmod\n";
		exit();
	}
	if ($pmod eq "0") {
		$pmod = uc $pgm;
	}
	if ($pname eq "0") {
		$pname = $pgm;
	}
	
	maudify_file("$pgm.k", "");
	my $maudified = get_file_content("$pgm.maude");

	my $compile = 
"set include PL-BOOL off .
set include BOOL on .
load \"$k_tools_dir/" . "prelude-extras\"
load \"$k_tools_dir/" . "meta-k\"
load \"$k_tools_dir/" . "printing\"

load  \"$k_tools_dir/" . "compile-program-interface\"
---(
set print attribute on .
red in COMPILE-PROGRAM-META : compileProgram(\"$cmod\",\"$pmod\",\"$pname\") .
q
---)
loop compile-program .
(compileProgram $cmod $pmod $pname .)
q
";

	my $tempFile = "programCompile.tmp";
	#open (MYFILE, ">programCompile.tmp");
	open MYFILE,">",$tempFile or die "Cannot create $tempFile\n";
	print MYFILE "$maudified\n$compile\n";
	close(MYFILE);
	push(@generated_files, $tempFile);
	
# run maude with this input
	my $comp = run_maude("Compiling single program", "in programCompile.tmp");
# verific? - vezi cum se face verificarea
	#print "$comp\n";
	$comp =~ /$begin_compiled_module(.*?)$end_compiled_module/s;
	#print $1;

#	unlink("programCompile.tmp");

	open MYFILE,">","$pgm-compiled.maude" or die "Cannot create $tempFile\n";
	print MYFILE "load \"$pgm\"\n$1";
	close(MYFILE);
	push(@generated_files, "$pgm-compiled.maude");

	exit();
}

# Latex top level patterns
#my $latex_top_level_pattern = join("|", (
#		"\\/\\/@(before|after)=([a-zA-Z\-]+)\s(.*?)(?=\n)",
#		"\\/\\*@(before|after)=([a-zA-Z\-]+)\s(.*?)\\*\\/"
#));

# Args: k file content
# Return: void
# Stores all latex comments in some data structures
sub store_intermodule_latex
{
	local $_ = shift;

	while (/(\/\*)@(before|after)=([a-zA-Z\-]+)\s(.*?)\*\//sg)
	{
		$module_before{$3} = $4 if $2 eq "before";
		$module_after{$3} = $4 if $2 eq "after";
	}

	while (/(\/\/)@(before|after)=([a-zA-Z\-]+)\s(.*?)(?=\n)/sg)
	{
		$module_before{$3} = $4 if $2 eq "before";
		$module_after{$3} = $4 if $2 eq "after";
	}
	
}

# Args: latex file content
# Return: latex file content
# Restores all latex comments from som data structures
sub restore_intermodule_latex
{
	local $_ = shift;
	
	my @mlist = ();
	while (/\\begin{module}{\\moduleName{([a-zA-Z\-]+)}}/sg)
	{
		push(@mlist, $1);
	}

	foreach my $module (@mlist)
	{
		s/(\\begin{module}{\\moduleName{\Q$module\E}})/\n$module_before{$module}\n$1/sg	if (defined $module_before{$module});
		s/(\\begin{module}{\\moduleName{\Q$module\E}}.*?\\end{module})/$1\n$module_after{$module}\n/sg if (defined $module_after{$module});
	}
	
	return $_;
}

# Args: no input
# Return: null
# Check installed software on local machine:
# maude, perl XML::DOM package
# Issue: doesn't work fine if other perl packages are not installed.
sub check_perl_packages
{
	# check if maude is installed
        my $pack = shift;

	# check if XML::DOM package is installed
	$_ = `perl -e 'use $pack;print "okay"'`;
	my $found = $_ eq "okay"?1:0;

	if (!$found)
	{
		print "[ERROR] Perl package $pack is not installed.\n";
		exit(1);
	}
	else
	{
		print "Package $pack installed...\n" if $verbose;
	}

}


sub check_maude_instalation
{
	local $_ = `echo 'rew "hello" + "world" .' | maude 2>&1`;
	return if ( m!helloworld!sg );

	my $maude_lib = $ENV{'MAUDE_LIB'};

	if ( m!command\s+not\s+found!sg )
	{
		print "Maude command doesn't execute. Please install maude or set maude directory in PATH.\n";

		if ($maude_lib eq "")
		{
			print "Also variable MAUDE_LIB is not set. Please check instalation instructions for maude.\n";
		}

		exit(1);
	}

	if ($maude_lib eq "")
	{
		print "Variable MAUDE_LIB is not set and maude cannot find prelude.maude.\nPlease check installation instructions for maude.\n";
		exit(1);
	}
}

# Args: none
# Return: none
# Add k-prelude sorts in @all_sorts if not already...
# Atention: this recurses only in maude files.
sub add_kprelude_sorts
{
	if (!$k_prelude_loaded)
	{
		my $to_load = shift;
		my $to_load_dir = shift;

		# add maude extension if not already
		$to_load .= ".maude" if $to_load !~ /\..+?/sg;

		my $fullname = File::Spec->file_name_is_absolute($to_load) ? $to_load : File::Spec->catfile($to_load_dir, $to_load);
		$fullname = getFullName($fullname);

		my $var = get_file_content($fullname);
		add_sorts($var);
		add_tokens($var);

#		print "@all_sorts\n\n@all_tokens\n\n\n\n";

		while ( $var =~ m!^\s*(in|load)\s+(\S+)!sgm )
		{
			add_kprelude_sorts($2, dirname($fullname));
		}

	}

}

sub addKandKLATEX
{
	my $content = shift;
	my $file = shift;
	my $mno = shift;
	my $k = 0;
	my $k_latex = 0;

	# extract module name
	my $mod = $1 if $content =~ /kmod\s+(.*?)\s/sg;

	# get list of imported modules
	while ( $content =~ /\s+including([\sA-Z\-+]*)/sgm )
	{
		$k = 1 if $1 =~ /\sK\s/sg;
		$k_latex = 1 if $1 =~ /\sK-LATEX\s/sg;
	}

	return $content if $k;
	
	my $prelude_sorts = $k_sorts;
	$prelude_sorts =~ s/#/\|/sg;
	$prelude_sorts =~ s/^\s*\|//;
	$prelude_sorts =~ s/\|\s*$//;
#	print "SORTS: $prelude_sorts\n\n";
	if ($content =~ /\s(syntax\s+($prelude_sorts)|configuration|rule)\s/sg)
	{
		# include K if syntax, configuration or rule keywords are used in module
		$content =~ s!(k?mod\s+\S+\s+is\s)!$1 including K !sg;

#		print "MOD: |$mod|\nMDD: |$language_module_name|\n\n";
		$k_auto_incl = 1 if $mod eq $language_module_name;
	}
	else
	{
		# include only K-LATEX
		$content =~ s!(k?mod\s+\S+\s+is\s)!$1 including K-LATEX !sg if !$k_latex;
	}

	$content;
}
