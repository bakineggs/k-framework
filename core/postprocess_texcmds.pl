#!/usr/bin/env perl
use strict;
use warnings;
use File::Basename;

my $tex_file;
my $out_file;
my $option;


if ($#ARGV < 0)
{
    terminate("no input file given.");
}
elsif ($#ARGV < 1)
{
    terminate("no output file given.");
}
elsif ($#ARGV < 2)
{
    if ($ARGV[0] eq "-check")
    {
	terminate("no output file given.");
    }
    else
    {
	$tex_file = $ARGV[0];
	$out_file = $ARGV[1] . ".tex";
	$option = 0;
    }
}
elsif ($#ARGV < 3)
{
    print "ARGV[0] = $ARGV[0]\n";
    if ($ARGV[0] ne "\-check")
    {
	terminate("unknown option $ARGV[0].");
    }
    else
    {
	$tex_file = $ARGV[1];
	$out_file = $ARGV[2] . ".tex";
	$option = 1;
    }
}

if ($option == 1)
{
    # must add a \nonstopmode command before \documentclass
    # so that the latex will always exit
    print "Creating a copy of $tex_file in order to test the format of the file.\n";
    my $temp_tex = create_temp_tex_file($tex_file);
 
    # check if the tex file is correct.
    print "Checking the format of the input file... \n";
    system("pdflatex", $temp_tex, "-no-file-line-error");

    # remove temp tex extension
    $temp_tex =~ s/(.*)\.tex$/$1/sg;
    $temp_tex =~ s/(.*)\///sg;
    
    if ($? != 0)
    {
		print "\n\nERROR: Argument 1 must be a tex file.\nCheck if your file is correctly formatted as tex file.\n";
		print "Deleting temporary files...\n";
		
		# remove temp file
		system("rm", "$temp_tex.aux", "$temp_tex.log", "$temp_tex.pdf");    
		print "Temp files deleted.\nStatus: FAILED.\n";
	
		exit(1);
    }
   
    print "File $tex_file format check ok.\nDeleting temporary files...\n";
    # remove temp file
    system("rm", "$temp_tex.aux", "$temp_tex.log", "$temp_tex.pdf");    
    print "Delete ok.\n";
    
}


# call the main function
verification();

# Notify user.
# print "File $out_file created in current directory.\nStatus: FINISHED.\n\n";


sub terminate
{
    print "ERROR: " . (shift) . "\n";
    print "\nUSAGE:\n postprocess_texcmds [-check] input_file.tex output_file\n\n
  This program takes a latex file generated by kompile and
  replaces each \\newcommand with its defintion. If the
  latex file is not correctly formated than the output 
  is unknown. To check the validity of the latex file
  given as an input the option \"-check\" is used:\n
  postprocess_texcmds -check input.tex output\n
  This option starts latex in order to compile the
  input.tex. If the compilation is sucessfull than the 
  output.tex file will contain a valid tex file.\n
  To avoid latex to start then do not use \"-check\" option:\n
  post_process_texcmds input.tex output\n
  In this case the result is not guaranteed to be correct.\n";
    exit(1);    
}

# sub adds an extracommand at the beginning of the document.
sub create_temp_tex_file
{
    my $tex_file_ = shift;
    my $out_file_ = "$tex_file" . "_temp.tex";
    
    # open file and get content
    open FILE, "<", $tex_file_ or die "Could not open file $tex_file_!\n";
    my @lines = <FILE>;
    my $lines = "@lines";
    
    my $new_lines = "\\nonstopmode$lines";

    # write output file.
    open MYFILE, ">", $out_file_ or die "Could not open file $out_file_!\n";
    print MYFILE "$new_lines";
    close MYFILE;
    
    print "File $out_file_ created.\n\n";
    return $out_file_;
}

sub verification
{
    # open file and get content
    open FILE, "<", $tex_file or die "Could not open file $tex_file!\n";
    my @lines = <FILE>;
    my $lines = "@lines";
    my $temp = $lines;
    
    # close file
    close FILE;
    
    if ($temp =~ m/\\begin{document}(.*)\\end{document}/sg)
    {
	$temp = $1;
    }
    
    # match each command and replace it
    while ($lines =~ m/\\newcommand{\\(.*?)}(\[(\d)\])?(.*?)(?=(\\newcommand|\\begin{document}))/sg)
    {

	# arg no
	my $arg_no = 0;
	if (defined($3))
	{
	    $arg_no = $3;
	}
	
	# command name
	my $command = $1;
	my $quote = quotemeta($command);

	# command text
	my $c_text = $4;
	$c_text =~ s!^{!!sg;
	$c_text =~ s!}\s*$!!sg;
	    
	while ($temp =~ m/\\$quote([^A-Za-z])/sg)
	{
	    my $remainder = $1 . substr $temp, pos($temp);
	    my $match = $command . $remainder;
	    my $inline = $c_text;
	    
	    my $args;
	    my $i;
	    for ($i = 1; $i <= $arg_no; $i++)
	    {
		my $arg = get_argument($remainder);
		$args .= $arg;
		my $q_arg = quotemeta($arg);
		$remainder =~ s/^$q_arg//;
		$inline =~ s/\{#$i\}/$arg/;
	    }
	    
	    my $smatch = quotemeta($match);
	    if ($temp =~ m/\\$smatch/)
	    {
		my $repl = $inline . $remainder;
		$temp =~ s/\\$smatch/$repl/g;
	    }
	}
	
    }
    
    # replace all \newcommands "calls" with inline commands
    $lines =~ s/\\begin\{document\}(.*)\\end\{document\}/\\begin\{document\}$temp\\end\{document\}/sg;

    # remove useless \newcommands definitions
    $lines =~ s/\\newcommand{\\(.*?)}(\[(\d)\])?(.*?)(?=(\\newcommand|\\begin{document}))//sg;

    # write output file.
    open MYFILE, ">", $out_file or die "Could not open file $tex_file!\n";
    print MYFILE "$lines";
    close(MYFILE);
}

# uuuuuuugly sub, (it will be replaced. :D)
sub get_argument
{
    my $text = shift;
    my $return_text = "";
    
    my $depth = 0;
    while ($text =~ /(.)/sg)
    {
#	print $1;
	$return_text .= "$1";
	if ($1 eq "{")
	{
	    $depth++;
	}
	elsif ($1 eq "}")
	{
	    $depth--;
	    if ($depth <= 0)
	    {
		return $return_text;
	    }
	}
    }
    return "";
}
