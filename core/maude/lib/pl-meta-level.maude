***(

    This file is part of the K Framework Maude library.

    Copyright 2009-2011 Grigore Rosu
    Portions Copyright 2004-2006 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

***)


mod PL-LIST{X :: TRIV} is
  protecting PL-NAT .
  protecting PL-IF-THEN-ELSE .
  sorts NeList{X} List{X} .
  subsort X$Elt < NeList{X} < List{X} .

  op nil : -> List{X} [ctor] .
  op _plList_ : List{X} List{X} -> List{X} [ctor assoc id: nil prec 25] .
  op _plList_ : NeList{X} List{X} -> NeList{X} [ctor ditto] .
  op _plList_ : List{X} NeList{X} -> NeList{X} [ctor ditto] .

  var E E' : X$Elt .
  vars A L : List{X} .
  var C : Nat .

  op append : List{X} List{X} -> List{X} .
  op append : NeList{X} List{X} -> NeList{X} .
  op append : List{X} NeList{X} -> NeList{X} .
  eq append(A, L) = A plList L .

  op head : NeList{X} -> X$Elt .
  eq head(E plList L) = E .

  op tail : NeList{X} -> List{X} .
  eq tail(E plList L) = L .

  op last : NeList{X} -> X$Elt .
  eq last(L plList E) = E .

  op front : NeList{X} -> List{X} .
  eq front(L plList E) = L .

  op occurs : X$Elt List{X} -> Bool .
  eq occurs(E, nil) = false .
  eq occurs(E, E' plList L) = if E ==Bool E' then true else occurs(E, L) fi .

  op reverse : List{X} -> List{X} .
  op reverse : NeList{X} -> NeList{X} .
  eq reverse(L) = $reverse(L, nil) .

  op $reverse : List{X} List{X} -> List{X} .
  eq $reverse(nil, A) = A .
  eq $reverse(E plList L, A) = $reverse(L, E plList A).

  op size : List{X} -> Nat .
  op size : NeList{X} -> NzNat .
  eq size(L) = $size(L, 0) .

  op $size : List{X} Nat -> Nat .
  eq $size(nil, C) = C .
  eq $size(E plList L, C) = $size(L, C +Nat 1) .
endm

mod PL-SET{X :: TRIV} is
  protecting PL-EXT-BOOL .
  protecting PL-IF-THEN-ELSE .
  protecting PL-NAT .
  sorts NeSet{X} Set{X} .
  subsort X$Elt < NeSet{X} < Set{X} .

  op empty : -> Set{X} [ctor] .
  op _,_ : Set{X} Set{X} -> Set{X} [ctor assoc comm id: empty prec 121 format (d r os d)] .
  op _,_ : NeSet{X} Set{X} -> NeSet{X} [ctor ditto] .

  var E : X$Elt .
  var N : NeSet{X} .
  vars A S S' : Set{X} .
  var C : Nat .

  eq N, N = N .
  
  op insert : X$Elt Set{X} -> Set{X} .
  eq insert(E, S) = E, S .

  op delete : X$Elt Set{X} -> Set{X} .
  eq delete(E, (E, S)) = delete(E, S) .
  eq delete(E, S) = S [owise] .

  op _in_ : X$Elt Set{X} -> Bool .
  eq E in (E, S) = true .
  eq E in S = false [owise] .

  op |_| : Set{X} -> Nat .
  op |_| : NeSet{X} -> NzNat .
  eq | S | = $card(S, 0) .

  op $card : Set{X} Nat -> Nat .
  eq $card(empty, C) = C .
  eq $card((N, N, S), C) = $card((N, S), C) .
  eq $card((E, S), C) = $card(S, C +Nat 1) [owise] .

  op union : Set{X} Set{X} -> Set{X} .
  op union : NeSet{X} Set{X} -> NeSet{X} .
  op union : Set{X} NeSet{X} -> NeSet{X} .
  eq union(S, S') = S, S' .

  op intersection : Set{X} Set{X} -> Set{X} .
  eq intersection(S, empty) = empty .
  eq intersection(S, N) = $intersect(S, N, empty) .

  op $intersect : Set{X} Set{X} Set{X} -> Set{X} .
  eq $intersect(empty, S', A) = A .
  eq $intersect((E, S), S', A) = $intersect(S, S', if E in S' then E, A else A fi) .

  op _\_ : Set{X} Set{X} -> Set{X}  [gather (E e)].
  eq S \ empty = S .
  eq S \ N = $diff(S, N, empty) .

  op $diff : Set{X} Set{X} Set{X} -> Set{X} .
  eq $diff(empty, S', A) = A .
  eq $diff((E, S), S', A) = $diff(S, S', if E in S' then A else E, A fi) .

  op _subset_ : Set{X} Set{X} -> Bool .
  eq empty subset S' = true .
  eq (E, S) subset S' = E in S' and-then S subset S' .

  op _psubset_ : Set{X} Set{X} -> Bool .
  eq S psubset S' = S =/=Bool S' and-then S subset S' .
endm

view PlNat from TRIV to PL-NAT is
  sort Elt to Nat .
endv

view PlQid from TRIV to PL-QID is
  sort Elt to Qid .
endv

mod PL-NAT-LIST is
  protecting PL-LIST{PlNat} * (sort NeList{PlNat} to NeNatList, sort List{PlNat} to NatList) .
endm

mod PL-QID-LIST is
  protecting PL-LIST{PlQid} * (sort NeList{PlQid} to NeQidList, sort List{PlQid} to QidList) .
endm

mod PL-QID-SET is
  protecting PL-SET{PlQid} * (sort NeSet{PlQid} to NeQidSet, sort Set{PlQid} to QidSet) .
endm

mod PL-META-TERM is
  protecting PL-QID .

*** types
  sorts Sort Kind TypeMeta .
  subsorts Sort Kind < TypeMeta < Qid .
  op <Qids> : -> Sort [special (id-hook QuotedIdentifierSymbol (sortQid))] .
  op <Qids> : -> Kind [special (id-hook QuotedIdentifierSymbol (kindQid))] .

*** terms
  sorts Constant Variable TermQid GroundTerm Term NeGroundTermList GroundTermList NeTermList TermList .
  subsorts Constant Variable < TermQid < Qid Term .
  subsorts Constant < GroundTerm < Term NeGroundTermList < NeTermList .
  subsorts NeGroundTermList < NeTermList GroundTermList < TermList .
  op <Qids> : -> Constant [special (id-hook QuotedIdentifierSymbol (constantQid))] .
  op <Qids> : -> Variable [special (id-hook QuotedIdentifierSymbol (variableQid))] .
  op empty : -> GroundTermList [ctor] .
  op _,_ : NeGroundTermList GroundTermList -> NeGroundTermList [ctor assoc id: empty gather (e E) prec 121] .
  op _,_ : GroundTermList NeGroundTermList -> NeGroundTermList [ctor ditto] .
  op _,_ : GroundTermList GroundTermList -> GroundTermList [ctor ditto] .
  op _,_ : NeTermList TermList -> NeTermList [ctor ditto] .
  op _,_ : TermList NeTermList -> NeTermList [ctor ditto] .
  op _,_ : TermList TermList -> TermList [ctor ditto] .
  op _[_] : Qid NeGroundTermList -> GroundTerm [ctor] .
  op _[_] : Qid NeTermList -> Term [ctor] .

*** extraction of names and types
  op getName : Constant -> Qid .
  op getTypeMeta : Constant -> TypeMeta .
  var C : Constant .
  eq getName(C) = qid(substrString(string(C),
                             0,
                             rfindString(string(C), ".", lengthString(string(C))))) .
  eq getTypeMeta(C) = qid(substrString(string(C),
                             rfindString(string(C), ".", lengthString(string(C))) +Nat 1,
                             lengthString(string(C)))) .

  op getName : Variable -> Qid .
  op getTypeMeta : Variable -> TypeMeta .
  var V : Variable .
  eq getName(V) = qid(substrString(string(V),
                             0,
                             rfindString(string(V), ":", lengthString(string(V))))) .
  eq getTypeMeta(V) = qid(substrString(string(V),
                             rfindString(string(V), ":", lengthString(string(V))) +Nat 1,
                             lengthString(string(V)))) .

*** substitutions
  sorts Assignment Substitution .
  subsort Assignment < Substitution .
  op _<-_ : Variable Term -> Assignment [ctor prec 63 format (nt d d d)] .
  op none : -> Substitution [ctor] .
  op _;_ : Substitution Substitution -> Substitution
    [ctor assoc comm id: none prec 65] .
  eq A:Assignment ; A:Assignment = A:Assignment .

*** contexts (terms with a single hole)
  sorts Context NeCTermList GTermList .
  subsort Context < NeCTermList < GTermList .
  subsorts TermList < GTermList .

  op [] : -> Context [ctor] .
  op _,_ : TermList NeCTermList -> NeCTermList [ctor ditto] .
  op _,_ : NeCTermList TermList -> NeCTermList [ctor ditto] .
  op _,_ : GTermList GTermList -> GTermList [ctor ditto] .
  op _[_] : Qid NeCTermList -> Context [ctor] .
endm

mod PL-META-MODULE is
  protecting PL-META-TERM .
  protecting PL-NAT-LIST .
  protecting PL-QID-LIST .
  protecting PL-QID-SET * (op empty to none, op _,_ to _;_ [prec 43]) .

*** subsort declarations
  sorts SubsortDecl SubsortDeclSet .
  subsort SubsortDecl < SubsortDeclSet .
  op subsort_<_. : Sort Sort -> SubsortDecl [ctor] .
  op none : -> SubsortDeclSet [ctor] .
  op __ : SubsortDeclSet SubsortDeclSet -> SubsortDeclSet
    [ctor assoc comm id: none format (d ni d)] .
  eq S:SubsortDecl S:SubsortDecl = S:SubsortDecl .

*** sort, kind and type sets
  sorts EmptyTypeMetaSet NeSortSet NeKindSet NeTypeMetaSet SortSet KindSet TypeMetaSet .
  subsort EmptyTypeMetaSet < SortSet KindSet < TypeMetaSet < QidSet .
  subsort Sort < NeSortSet < SortSet .
  subsort Kind < NeKindSet < KindSet .
  subsort TypeMeta NeSortSet NeKindSet < NeTypeMetaSet < TypeMetaSet NeQidSet .
  op none : -> EmptyTypeMetaSet [ctor] .
  op _;_ : TypeMetaSet TypeMetaSet -> TypeMetaSet [ctor ditto] .
  op _;_ : NeTypeMetaSet TypeMetaSet -> NeTypeMetaSet [ctor ditto] .
  op _;_ : SortSet SortSet -> SortSet [ctor ditto] .
  op _;_ : NeSortSet SortSet -> NeSortSet [ctor ditto] .
  op _;_ : KindSet KindSet -> KindSet [ctor ditto] .
  op _;_ : NeKindSet KindSet -> NeKindSet [ctor ditto] .
  op _;_ : EmptyTypeMetaSet EmptyTypeMetaSet -> EmptyTypeMetaSet [ctor ditto] .

*** type lists
  sort NeTypeMetaList TypeMetaList .
  subsorts TypeMeta < NeTypeMetaList < TypeMetaList < QidList .
  subsorts NeTypeMetaList < NeQidList .
  op nil : -> TypeMetaList [ctor] .
  op _plList_ : TypeMetaList TypeMetaList -> TypeMetaList [ctor ditto] .
  op _plList_ : NeTypeMetaList TypeMetaList -> NeTypeMetaList [ctor ditto] .
  op _plList_ : TypeMetaList NeTypeMetaList -> NeTypeMetaList [ctor ditto] .
  eq T:TypeMetaList ; T:TypeMetaList = T:TypeMetaList .

*** sets of type lists
  sort TypeMetaListSet .
  subsort TypeMetaList TypeMetaSet < TypeMetaListSet .
  op _;_ : TypeMetaListSet TypeMetaListSet -> TypeMetaListSet [ctor ditto] .

*** attribute sets
  sorts Attr AttrSet .
  subsort Attr < AttrSet .
  op none : -> AttrSet [ctor] .
  op __ : AttrSet AttrSet -> AttrSet [ctor assoc comm id: none] .
  eq A:Attr A:Attr = A:Attr .

*** renamings
  sorts Renaming RenamingSet .
  subsort Renaming < RenamingSet .
  op sort_to_ : Qid Qid -> Renaming [ctor] .
  op op_to_[_] : Qid Qid AttrSet -> Renaming
    [ctor format (d d d d s d d d)] .
  op op_:_->_to_[_] : Qid TypeMetaList TypeMeta Qid AttrSet -> Renaming
    [ctor format (d d d d d d d d s d d d)] .
  op label_to_ : Qid Qid -> Renaming [ctor] .
  op _,_ : RenamingSet RenamingSet -> RenamingSet
    [ctor assoc comm prec 43 format (d d ni d)] .

*** parameter lists
  sort EmptyCommaList NeParameterList ParameterList .
  subsorts Sort < NeParameterList < ParameterList .
  subsort EmptyCommaList < GroundTermList ParameterList .
  op empty : -> EmptyCommaList [ctor] .
  op _,_ : ParameterList ParameterList -> ParameterList [ctor ditto] .
  op _,_ : NeParameterList ParameterList -> NeParameterList [ctor ditto] .
  op _,_ : ParameterList NeParameterList -> NeParameterList [ctor ditto] .
  op _,_ : EmptyCommaList EmptyCommaList -> EmptyCommaList [ctor ditto] .

*** module expressions
  sort ModuleExpression .
  subsort Qid < ModuleExpression .
  op _+_ : ModuleExpression ModuleExpression -> ModuleExpression
    [ctor assoc comm] .
  op _*(_) : ModuleExpression RenamingSet -> ModuleExpression
    [ctor prec 39 format (d d s n++i n--i d)] .
  op _{_} : ModuleExpression ParameterList -> ModuleExpression [ctor prec 37].

*** parameter declarations
  sorts ParameterDecl NeParameterDeclList ParameterDeclList .
  subsorts ParameterDecl < NeParameterDeclList < ParameterDeclList .
  op _::_ : Sort ModuleExpression -> ParameterDecl .
  op nil : -> ParameterDeclList [ctor] .
  op _,_ : ParameterDeclList ParameterDeclList -> ParameterDeclList [ctor assoc id: nil prec 121] .
  op _,_ : NeParameterDeclList ParameterDeclList -> NeParameterDeclList [ctor ditto] .
  op _,_ : ParameterDeclList NeParameterDeclList -> NeParameterDeclList [ctor ditto] .

*** importations
  sorts Import ImportList .
  subsort Import < ImportList .
  op protecting_. : ModuleExpression -> Import [ctor] .
  op extending_. : ModuleExpression -> Import [ctor] .
  op including_. : ModuleExpression -> Import [ctor] .
  op nil : -> ImportList [ctor] .
  op __ : ImportList ImportList -> ImportList
    [ctor assoc id: nil format (d ni d)] .

*** hooks
  sorts Hook NeHookList HookList .
  subsort Hook < NeHookList < HookList .
  op id-hook : Qid QidList -> Hook [ctor format (nssss d)] .
  op op-hook : Qid Qid QidList Qid -> Hook [ctor format (nssss d)] .
  op term-hook : Qid Term -> Hook [ctor format (nssss d)] .
  op nil : -> HookList [ctor] .
  op __ : HookList HookList -> HookList [ctor assoc id: nil] .
  op __ : NeHookList HookList -> NeHookList [ctor ditto] .
  op __ : HookList NeHookList -> NeHookList [ctor ditto] .

*** operator attributes
  op assoc : -> Attr [ctor] .
  op comm : -> Attr [ctor] .
  op idem : -> Attr [ctor] .
  op iter : -> Attr [ctor] .
  op id : Term -> Attr [ctor] .
  op left-id : Term -> Attr [ctor] .
  op right-id : Term -> Attr [ctor] .
  op strat : NeNatList -> Attr [ctor] .
  op memo : -> Attr [ctor] .
  op prec : Nat -> Attr [ctor] .
  op gather : QidList -> Attr [ctor] .
  op format : QidList -> Attr [ctor] .
  op ctor : -> Attr [ctor] .
  op config : -> Attr [ctor] .
  op object : -> Attr [ctor] .
  op msg : -> Attr [ctor] .
  op frozen : NeNatList -> Attr [ctor] .
  op poly : NeNatList -> Attr [ctor] .
  op special : NeHookList -> Attr [ctor] .

*** statement attributes
  op label : Qid -> Attr [ctor] .
  op metadata : String -> Attr [ctor] .
  op owise : -> Attr [ctor] .
  op nonexec : -> Attr [ctor] .
  op print : QidList -> Attr [ctor] .

*** operator declarations
  sorts OpDecl OpDeclSet .
  subsort OpDecl < OpDeclSet .
  op (op_:_->_[_].) : Qid TypeMetaList TypeMeta AttrSet -> OpDecl
    [ctor format (d d d d d d s d d s d)] .
  op none : -> OpDeclSet [ctor] .
  op __ : OpDeclSet OpDeclSet -> OpDeclSet
    [ctor assoc comm id: none format (d ni d)] .
  eq O:OpDecl O:OpDecl = O:OpDecl .

*** conditions
  sorts EqCondition Condition .
  subsort EqCondition < Condition .
  op nil : -> EqCondition [ctor] .
  op _=_ : Term Term -> EqCondition [ctor prec 71] .
  op _:_ : Term Sort -> EqCondition [ctor prec 71] .
  op _:=_ : Term Term -> EqCondition [ctor prec 71] .
  op _=>_ : Term Term -> Condition [ctor prec 71] .
  op _/\_ : EqCondition EqCondition -> EqCondition [ctor assoc id: nil prec 73] .
  op _/\_ : Condition Condition -> Condition [ctor assoc id: nil prec 73] .

*** membership axioms
  sorts MembAx MembAxSet .
  subsort MembAx < MembAxSet .
  op mb_:_[_]. : Term Sort AttrSet -> MembAx
    [ctor format (d d d d s d d s d)] .
  op cmb_:_if_[_]. : Term Sort EqCondition AttrSet -> MembAx
    [ctor format (d d d d d d s d d s d)] .
  op none : -> MembAxSet [ctor] .
  op __ : MembAxSet MembAxSet -> MembAxSet
    [ctor assoc comm id: none format (d ni d)] .
  eq M:MembAx M:MembAx = M:MembAx .

*** equations
  sorts Equation EquationSet .
  subsort Equation < EquationSet .
  op eq_=_[_]. : Term Term AttrSet -> Equation
    [ctor format (d d d d s d d s d)] .
  op ceq_=_if_[_]. : Term Term EqCondition AttrSet -> Equation
    [ctor format (d d d d d d s d d s d)] .
  op none : -> EquationSet [ctor] .
  op __ : EquationSet EquationSet -> EquationSet
    [ctor assoc comm id: none format (d ni d)] .
  eq E:Equation E:Equation = E:Equation .

*** rules
  sorts Rule RuleSet .
  subsort Rule < RuleSet .
  op rl_=>_[_]. : Term Term AttrSet -> Rule
    [ctor format (d d d d s d d s d)] .
  op crl_=>_if_[_]. : Term Term Condition AttrSet -> Rule
    [ctor format (d d d d d d s d d s d)] .
  op none : -> RuleSet [ctor] .
  op __ : RuleSet RuleSet -> RuleSet
    [ctor assoc comm id: none format (d ni d)] .
  eq R:Rule R:Rule = R:Rule .

*** modules
  sorts FModule SModule FTheory STheory Module .
  subsorts FModule < SModule < Module .
  subsorts FTheory < STheory < Module .
  sort Header .
  subsort Qid < Header .
  op _{_}  : Qid ParameterDeclList -> Header [ctor] .
  op fmod_is_sorts_.____endfm : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet -> FModule [ctor gather (& & & & & & &)
     format (d d s n++i ni d d ni ni ni ni n--i d)] .
  op mod_is_sorts_._____endm : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet -> SModule
    [ctor gather (& & & & & & & &)
     format (d d s n++i ni d d ni ni ni ni ni n--i d)] .
  op fth_is_sorts_.____endfth : Qid ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet -> FTheory [ctor gather (& & & & & & &)
     format (d d d n++i ni d d ni ni ni ni n--i d)] .
  op th_is_sorts_._____endth : Qid ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet -> STheory
    [ctor gather (& & & & & & & &)
     format (d d d n++i ni d d ni ni ni ni ni n--i d)] .
  op [_] : Qid -> Module .
  eq [Q:Qid] = (th Q:Qid is including Q:Qid .
                sorts none . none none none none none endth) .

*** projection functions
  var Q : Qid .
  var PDL : ParameterDeclList .
  var H : Header .
  var M : Module .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .
  var RLS : RuleSet .

  op getName : Module -> Qid .
  eq getName(fmod Q is IL sorts SS . SSDS OPDS MAS EQS endfm) = Q .
  eq getName(mod Q is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = Q .
  eq getName(fmod Q{PDL} is IL sorts SS . SSDS OPDS MAS EQS endfm) = Q .
  eq getName(mod Q{PDL} is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = Q .
  eq getName(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = Q .
  eq getName(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = Q .

  op getImports : Module -> ImportList .
  eq getImports(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = IL .
  eq getImports(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = IL .
  eq getImports(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = IL .
  eq getImports(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = IL .

  op getSorts : Module -> SortSet .
  eq getSorts(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = SS .
  eq getSorts(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = SS .
  eq getSorts(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = SS .
  eq getSorts(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = SS .

  op getSubsorts : Module -> SubsortDeclSet .
  eq getSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = SSDS .
  eq getSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = SSDS .
  eq getSubsorts(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = SSDS .
  eq getSubsorts(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = SSDS .

  op getOps : Module -> OpDeclSet .
  eq getOps(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = OPDS .
  eq getOps(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = OPDS .
  eq getOps(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = OPDS .
  eq getOps(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = OPDS .

  op getMbs : Module -> MembAxSet .
  eq getMbs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = MAS .
  eq getMbs(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = MAS .
  eq getMbs(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = MAS .
  eq getMbs(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = MAS .

  op getEqs : Module -> EquationSet .
  eq getEqs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = EQS .
  eq getEqs(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = EQS .
  eq getEqs(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = EQS .
  eq getEqs(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = EQS .

  op getRls : Module -> RuleSet .
  eq getRls(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = none .
  eq getRls(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = RLS .
  eq getRls(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = none .
  eq getRls(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = RLS .
endm

mod PL-META-VIEW is
  protecting PL-META-MODULE .

*** sort mappings
  sorts SortMapping SortMappingSet .
  subsort SortMapping < SortMappingSet .
  op sort_to_. : Sort Sort -> SortMapping [ctor] .
  op none : -> SortMappingSet [ctor] .
  op __ : SortMappingSet SortMappingSet -> SortMappingSet
    [ctor assoc comm id: none format (d ni d)] .
  eq S:SortMapping S:SortMapping = S:SortMapping .

*** operator mappings
  sorts OpMapping OpMappingSet .
  subsort OpMapping < OpMappingSet .

  op (op_to_.) : Qid Qid -> OpMapping [ctor] .
  op (op_:_->_to_.) : Qid TypeMetaList TypeMeta Qid -> OpMapping [ctor] .
  op (op_to term_.) : Term Term -> OpMapping [ctor] .

  op none : -> OpMappingSet [ctor] .
  op __ : OpMappingSet OpMappingSet -> OpMappingSet
    [ctor assoc comm id: none format (d ni d)] .
  eq O:OpMapping O:OpMapping = O:OpMapping .

  sort View .
  op view_from_to_is__endv : Header ModuleExpression ModuleExpression
    SortMappingSet OpMappingSet -> View [ctor gather (& & & & &)
     format (d d d d d d d n++i ni n--i d)] .

*** projection functions
  var Q : Qid .
  vars ME ME' : ModuleExpression .
  var SMS : SortMappingSet .
  var OMS : OpMappingSet .

  op getName : View -> Qid .
  eq getName(view Q from ME to ME' is SMS OMS endv) = Q .

  op getFrom : View -> ModuleExpression .
  eq getFrom(view Q from ME to ME' is SMS OMS endv) = ME .

  op getTo : View -> ModuleExpression .
  eq getTo(view Q from ME to ME' is SMS OMS endv) = ME' .

  op getSortMappings : View -> SortMappingSet .
  eq getSortMappings(view Q from ME to ME' is SMS OMS endv) = SMS .

  op getOpMappings : View -> OpMappingSet .
  eq getOpMappings(view Q from ME to ME' is SMS OMS endv) = OMS .
endm

mod PL-META-LEVEL-BUILTIN-MODULE is
  protecting PL-META-VIEW .

*** bounds
  sort Bound .
  subsort Nat < Bound .
  op unbounded : -> Bound [ctor] .

*** argument values
  sort TypeMeta? .
  subsort TypeMeta < TypeMeta? .
  op anyTypeMeta : -> TypeMeta? [ctor] .

*** options for metaPrettyPrint()
  sorts PrintOption PrintOptionSet .
  subsort PrintOption < PrintOptionSet .
  ops mixfix with-parens flat format number rat : -> PrintOption [ctor] .
  op none : -> PrintOptionSet [ctor] .
  op __ : PrintOptionSet PrintOptionSet -> PrintOptionSet [ctor assoc comm id: none] .

*** unification problems
  sorts UnificandPair UnificationProblem .
  subsort UnificandPair < UnificationProblem .
  op _=?_ : Term Term -> UnificandPair [ctor prec 71] .
  op _/\_ : UnificationProblem UnificationProblem -> UnificationProblem [ctor assoc comm prec 73] .

*** success results
  sorts ResultPair ResultTriple Result4Tuple MatchPair TraceStep Trace
    UnificationPair UnificationTriple .
  subsort TraceStep < Trace .
  op {_,_} : Term TypeMeta -> ResultPair [ctor] .
  op {_,_,_} : Term TypeMeta Substitution -> ResultTriple [ctor] .
  op {_,_,_,_} : Term TypeMeta Substitution Context -> Result4Tuple [ctor] .
  op {_,_} : Substitution Context -> MatchPair [ctor] .
  op {_,_} : Substitution Nat -> UnificationPair [ctor] .
  op {_,_,_} : Substitution Substitution Nat -> UnificationTriple [ctor] .
  op {_,_,_} : Term TypeMeta Rule -> TraceStep [ctor] .
  op nil : -> Trace [ctor] .
  op __ : Trace Trace -> Trace [ctor assoc id: nil format (d n d)] .

*** failure results
  sorts ResultPair? ResultTriple? Result4Tuple? MatchPair? Substitution? Trace?
    UnificationPair? UnificationTriple? .
  subsort ResultPair < ResultPair? .
  subsort ResultTriple < ResultTriple? .
  subsort Result4Tuple < Result4Tuple? .
  subsort MatchPair < MatchPair? .
  subsort UnificationPair < UnificationPair? .
  subsort UnificationTriple < UnificationTriple? .
  subsort Substitution < Substitution? .
  subsort Trace < Trace? .
  op noParse : Nat -> ResultPair? [ctor] .
  op ambiguity : ResultPair ResultPair -> ResultPair? [ctor] .
  op failure : -> ResultPair? [ctor] .

  op failure : -> ResultTriple? [ctor] .
  op failure : -> Result4Tuple? [ctor] .
  op noUnifier : -> UnificationPair? [ctor] .
  op noUnifier : -> UnificationTriple? [ctor] .
  op noMatch : -> Substitution? [ctor] .
  op noMatch : -> MatchPair? [ctor] .
  op failure : -> Trace? [ctor] .

*** projection functions
  op getTerm : ResultPair -> Term .
  eq getTerm({T:Term, T:TypeMeta}) = T:Term .
  op getTypeMeta : ResultPair -> TypeMeta .
  eq getTypeMeta({T:Term, T:TypeMeta}) = T:TypeMeta .

  op getTerm : ResultTriple -> Term .
  eq getTerm({T:Term, T:TypeMeta, S:Substitution}) = T:Term .
  op getTypeMeta : ResultTriple -> TypeMeta .
  eq getTypeMeta({T:Term, T:TypeMeta, S:Substitution}) = T:TypeMeta .
  op getSubstitution : ResultTriple -> Substitution .
  eq getSubstitution({T:Term, T:TypeMeta, S:Substitution}) = S:Substitution .

  op getTerm : Result4Tuple -> Term .
  eq getTerm({T:Term, T:TypeMeta, S:Substitution, C:Context}) = T:Term .
  op getTypeMeta : Result4Tuple -> TypeMeta .
  eq getTypeMeta({T:Term, T:TypeMeta, S:Substitution, C:Context}) = T:TypeMeta .
  op getSubstitution : Result4Tuple -> Substitution .
  eq getSubstitution({T:Term, T:TypeMeta, S:Substitution, C:Context}) = S:Substitution .
  op getContext : Result4Tuple -> Context .
  eq getContext({T:Term, T:TypeMeta, S:Substitution, C:Context}) = C:Context .

  op getSubstitution : MatchPair -> Substitution .
  eq getSubstitution({S:Substitution, C:Context}) = S:Substitution .
  op getContext : MatchPair -> Context .
  eq getContext({S:Substitution, C:Context}) = C:Context .

*** descent functions
  op metaReduce : Module Term ~> ResultPair
     [special (
        id-hook MetaLevelOpSymbol	(metaReduce)

        op-hook qidSymbol		(<Qids> : ~> Qid)
        op-hook metaTermSymbol		(_[_] : Qid NeTermList ~> Term)
        op-hook metaArgSymbol		(_,_ : NeTermList NeTermList ~> NeTermList)

        op-hook assignmentSymbol	(_<-_ : Qid Term ~> Assignment)
        op-hook substitutionSymbol
                (_;_ : Substitution Substitution ~> Substitution)
        op-hook emptySubstitutionSymbol	(none : ~> Substitution)
        op-hook holeSymbol		([] : ~> Context)

        op-hook headerSymbol		(_{_} : Qid ParameterDeclList ~> Header)
        op-hook parameterDeclSymbol	(_::_ : Sort ModuleExpression ~> ParameterDecl)
        op-hook parameterDeclListSymbol	(_,_ : ParameterDeclList ParameterDeclList ~> ParameterDeclList)

        op-hook emptyAttrSetSymbol	(none : ~> AttrSet)
        op-hook attrSetSymbol		(__ : AttrSet AttrSet ~> AttrSet)

        op-hook sortRenamingSymbol	(sort_to_ : Qid Qid ~> Renaming)
        op-hook opRenamingSymbol	(op_to_[_] : Qid Qid AttrSet ~> Renaming)
        op-hook opRenamingSymbol2
                (op_:_->_to_[_] : Qid TypeMetaList TypeMeta Qid AttrSet ~> Renaming)
        op-hook labelRenamingSymbol	(label_to_ : Qid Qid ~> Renaming)
        op-hook renamingSetSymbol	(_,_ : RenamingSet RenamingSet ~> RenamingSet)

        op-hook sumSymbol
                (_+_ : ModuleExpression ModuleExpression ~> ModuleExpression)
        op-hook renamingSymbol
                (_*(_) : ModuleExpression RenamingSet ~> ModuleExpression)
        op-hook instantiationSymbol
                (_{_} : ModuleExpression ParameterList ~> ModuleExpression)

        op-hook protectingSymbol	(protecting_. : ModuleExpression ~> Import)
        op-hook extendingSymbol		(extending_. : ModuleExpression ~> Import)
        op-hook includingSymbol		(including_. : ModuleExpression ~> Import)
        op-hook nilImportListSymbol	(nil : ~> ImportList)
        op-hook importListSymbol	(__ : ImportList ImportList ~> ImportList)

        op-hook emptySortSetSymbol	(none : ~> SortSet)
        op-hook sortSetSymbol		(_;_ : SortSet SortSet ~> SortSet)

        op-hook subsortSymbol		(subsort_<_. : Sort Sort ~> SubsortDecl)
        op-hook emptySubsortDeclSetSymbol	(none : ~> SubsortDeclSet)
        op-hook subsortDeclSetSymbol
                (__ : SubsortDeclSet SubsortDeclSet ~> SubsortDeclSet)

        op-hook nilQidListSymbol	(nil : ~> QidList)
        op-hook qidListSymbol		(_plList_ : QidList QidList ~> QidList)

        op-hook succSymbol		(sNat_ : Nat ~> NzNat)
        op-hook natListSymbol		(_plList_ : NeNatList NeNatList ~> NeNatList)
        op-hook unboundedSymbol		(unbounded : ~> Bound)

        op-hook stringSymbol		(<Strings> : ~> String)
        op-hook idHookSymbol		(id-hook : Qid QidList ~> Hook)
        op-hook opHookSymbol		(op-hook : Qid Qid QidList Qid ~> Hook)
        op-hook termHookSymbol		(term-hook : Qid Term ~> Hook)
        op-hook hookListSymbol		(__ : HookList HookList ~> HookList)

        op-hook assocSymbol		(assoc : ~> Attr)
        op-hook commSymbol		(comm : ~> Attr)
        op-hook idemSymbol		(idem : ~> Attr)
        op-hook iterSymbol		(iter : ~> Attr)
        op-hook idSymbol		(id : Term ~> Attr)
        op-hook leftIdSymbol		(left-id : Term ~> Attr)
        op-hook rightIdSymbol		(right-id : Term ~> Attr)
        op-hook stratSymbol		(strat : NeNatList ~> Attr)
        op-hook memoSymbol		(memo : ~> Attr)
        op-hook precSymbol		(prec : Nat ~> Attr)
        op-hook gatherSymbol		(gather : QidList ~> Attr)
        op-hook formatSymbol		(format : QidList ~> Attr)
        op-hook ctorSymbol		(ctor : ~> Attr)
        op-hook frozenSymbol		(frozen : NeNatList ~> Attr)
        op-hook polySymbol		(poly : NeNatList ~> Attr)
        op-hook configSymbol		(config : ~> Attr)
        op-hook objectSymbol		(object : ~> Attr)
        op-hook msgSymbol		(msg : ~> Attr)
        op-hook specialSymbol		(special : NeHookList ~> Attr)

        op-hook labelSymbol		(label : Qid ~> Attr)
        op-hook metadataSymbol		(metadata : String ~> Attr)
        op-hook owiseSymbol		(owise : ~> Attr)
        op-hook nonexecSymbol		(nonexec : ~> Attr)
        op-hook printSymbol		(print : QidList ~> Attr)

        op-hook opDeclSymbol
                (op_:_->_[_]. : Qid TypeMetaList TypeMeta AttrSet ~> OpDecl)
        op-hook emptyOpDeclSetSymbol	(none : ~> OpDeclSet)
        op-hook opDeclSetSymbol		(__ : OpDeclSet OpDeclSet ~> OpDeclSet)

        op-hook noConditionSymbol	(nil : ~> EqCondition)
        op-hook equalityConditionSymbol	(_=_ : Term Term ~> EqCondition)
        op-hook sortTestConditionSymbol	(_:_ : Term Sort ~> EqCondition)
        op-hook matchConditionSymbol	(_:=_ : Term Term ~> EqCondition)
        op-hook rewriteConditionSymbol	(_=>_ : Term Term ~> Condition)
        op-hook conjunctionSymbol	(_/\_ : Condition Condition ~> Condition)

        op-hook mbSymbol		(mb_:_[_]. : Term Sort AttrSet ~> MembAx)
        op-hook cmbSymbol
                (cmb_:_if_[_]. : Term Sort EqCondition AttrSet ~> MembAx)
        op-hook emptyMembAxSetSymbol	(none : ~> MembAxSet)
        op-hook membAxSetSymbol		(__ : MembAxSet MembAxSet ~> MembAxSet)

        op-hook eqSymbol		(eq_=_[_]. : Term Term AttrSet ~> Equation)
        op-hook ceqSymbol
                (ceq_=_if_[_]. : Term Term EqCondition AttrSet ~> Equation)
        op-hook emptyEquationSetSymbol	(none : ~> EquationSet)
        op-hook equationSetSymbol
                (__ : EquationSet EquationSet ~> EquationSet)

        op-hook rlSymbol		(rl_=>_[_]. : Term Term AttrSet ~> Rule)
        op-hook crlSymbol
                (crl_=>_if_[_]. : Term Term Condition AttrSet ~> Rule)
        op-hook emptyRuleSetSymbol	(none : ~> RuleSet)
        op-hook ruleSetSymbol		(__ : RuleSet RuleSet ~> RuleSet)

        op-hook fmodSymbol
                (fmod_is_sorts_.____endfm :
                        Qid ImportList SortSet SubsortDeclSet OpDeclSet 
                        MembAxSet EquationSet ~> FModule)
        op-hook fthSymbol
                (fth_is_sorts_.____endfth :
                        Qid ImportList SortSet SubsortDeclSet OpDeclSet 
                        MembAxSet EquationSet ~> FModule)
        op-hook modSymbol
                (mod_is_sorts_._____endm :
                        Qid ImportList SortSet SubsortDeclSet OpDeclSet 
                        MembAxSet EquationSet RuleSet ~> Module)
        op-hook thSymbol
                (th_is_sorts_._____endth :
                        Qid ImportList SortSet SubsortDeclSet OpDeclSet 
                        MembAxSet EquationSet RuleSet ~> Module)

        op-hook sortMappingSymbol	(sort_to_. : Sort Sort ~> SortMapping [ctor] .)
	op-hook emptySortMappingSetSymbol	(none : ~> SortMappingSet)
        op-hook sortMappingSetSymbol
                (__ : SortMappingSet SortMappingSet ~> SortMappingSet)

        op-hook opMappingSymbol		(op_to_. : Qid Qid ~> OpMapping)
        op-hook opSpecificMappingSymbol	(op_:_->_to_. : Qid TypeMetaList TypeMeta Qid ~> OpMapping)
        op-hook opTermMappingSymbol	(op_to`term_. : Term Term ~> OpMapping)

	op-hook emptyOpMappingSetSymbol	(none : ~> OpMappingSet)
        op-hook opMappingSetSymbol
                (__ : OpMappingSet OpMappingSet ~> OpMappingSet)

        op-hook viewSymbol
                (view_from_to_is__endv : Header ModuleExpression ModuleExpression
                 SortMappingSet OpMappingSet ~> View)

        op-hook anyTypeSymbol		(anyTypeMeta : ~> TypeMeta?)

	op-hook unificandPairSymbol	(_=?_ : Term Term ~> UnificandPair)
        op-hook unificationConjunctionSymbol
                (_/\_ : UnificationProblem UnificationProblem ~> UnificationProblem)

        op-hook resultPairSymbol	({_,_} : Term TypeMeta ~> ResultPair)
        op-hook resultTripleSymbol
                ({_,_,_} : Term TypeMeta Substitution ~> ResultTriple)
        op-hook result4TupleSymbol
                ({_,_,_,_} : Term TypeMeta Substitution Context ~> Result4Tuple)
        op-hook matchPairSymbol		({_,_} : Substitution Context ~> MatchPair)
        op-hook unificationPairSymbol	({_,_} : Substitution Nat ~> UnificationPair)
        op-hook unificationTripleSymbol	({_,_,_} : Substitution Substitution Nat ~> UnificationTriple)

        op-hook traceStepSymbol		({_,_,_} : Term TypeMeta Rule ~> TraceStep)
        op-hook nilTraceSymbol		(nil : ~> Trace)
        op-hook traceSymbol		(__ : Trace Trace ~> Trace)

        op-hook noParseSymbol		(noParse : Nat ~> ResultPair?)
        op-hook ambiguitySymbol		(ambiguity : ResultPair ResultPair ~> ResultPair?)
        op-hook failure2Symbol		(failure : ~> ResultPair?)
        op-hook failure3Symbol		(failure : ~> ResultTriple?)
        op-hook failure4Symbol		(failure : ~> Result4Tuple?)
        op-hook noUnifierPairSymbol	(noUnifier : ~> UnificationPair?)
        op-hook noUnifierTripleSymbol	(noUnifier : ~> UnificationTriple?)
        op-hook noMatchSubstSymbol	(noMatch : ~> Substitution?)
        op-hook noMatchPairSymbol	(noMatch : ~> MatchPair?)
        op-hook failureTraceSymbol	(failure : ~> Trace?)

        op-hook mixfixSymbol		(mixfix : ~> PrintOption)
        op-hook withParensSymbol	(with-parens : ~> PrintOption)
        op-hook flatSymbol		(flat : ~> PrintOption)
        op-hook formatPrintOptionSymbol	(format : ~> PrintOption)
        op-hook numberSymbol		(number : ~> PrintOption)
        op-hook ratSymbol		(rat : ~> PrintOption)
        op-hook emptyPrintOptionSetSymbol	(none : ~> PrintOptionSet)
        op-hook printOptionSetSymbol	(__ : PrintOptionSet PrintOptionSet ~> PrintOptionSet)

        term-hook trueTerm		(true)
        term-hook falseTerm		(false))] .

  op metaNormalize : Module Term ~> ResultPair
        [special (
           id-hook MetaLevelOpSymbol	(metaNormalize)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaRewrite : Module Term Bound ~> ResultPair
        [special (
           id-hook MetaLevelOpSymbol	(metaRewrite)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaFrewrite : Module Term Bound Nat ~> ResultPair
        [special (
           id-hook MetaLevelOpSymbol	(metaFrewrite)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaApply : Module Term Qid Substitution Nat ~> ResultTriple?
        [special (
           id-hook MetaLevelOpSymbol	(metaApply)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaXapply : Module Term Qid Substitution Nat Bound Nat ~> Result4Tuple?
        [special (
           id-hook MetaLevelOpSymbol	(metaXapply)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaMatch : Module Term Term Condition Nat ~> Substitution?
        [special (
           id-hook MetaLevelOpSymbol	(metaMatch)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaXmatch : Module Term Term Condition Nat Bound Nat ~> MatchPair?
        [special (
           id-hook MetaLevelOpSymbol	(metaXmatch)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaUnify : Module UnificationProblem Nat Nat ~> UnificationPair?
        [special (
           id-hook MetaLevelOpSymbol	(metaUnify)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaDisjointUnify : Module UnificationProblem Nat Nat ~> UnificationTriple?
        [special (
           id-hook MetaLevelOpSymbol	(metaDisjointUnify)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaSearch : Module Term Term Condition Qid Bound Nat ~> ResultTriple?
        [special (
           id-hook MetaLevelOpSymbol	(metaSearch)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaSearchPath : Module Term Term Condition Qid Bound Nat ~> Trace?
        [special (
           id-hook MetaLevelOpSymbol	(metaSearchPath)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaNarrow : Module Term Term Qid Bound Nat ~> ResultTriple?
        [special (
           id-hook MetaLevelOpSymbol	(metaNarrow)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaNarrow : Module Term Qid Bound Bool Nat ~> ResultPair?
        [special (
           id-hook MetaLevelOpSymbol	(metaNarrow2)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op sortLeq : Module TypeMeta TypeMeta ~> Bool
        [special (
           id-hook MetaLevelOpSymbol	(metaSortLeq)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op sameKind : Module TypeMeta TypeMeta ~> Bool
        [special (
           id-hook MetaLevelOpSymbol	(metaSameKind)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op lesserSorts : Module TypeMeta ~> SortSet
        [special (
           id-hook MetaLevelOpSymbol	(metaLesserSorts)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op glbSorts : Module TypeMeta TypeMeta ~> TypeMetaSet
        [special (
           id-hook MetaLevelOpSymbol	(metaGlbSorts)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op leastSort : Module Term ~> TypeMeta
        [special (
           id-hook MetaLevelOpSymbol	(metaLeastSort)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op completeName : Module TypeMeta ~> TypeMeta
        [special (
           id-hook MetaLevelOpSymbol	(metaCompleteName)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaParse : Module QidList TypeMeta? ~> ResultPair?
        [special (
           id-hook MetaLevelOpSymbol	(metaParse)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op metaPrettyPrint : Module Term PrintOptionSet ~> QidList
        [special (
           id-hook MetaLevelOpSymbol	(metaPrettyPrint)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op wellFormed : Module -> Bool
        [special (
           id-hook MetaLevelOpSymbol	(metaWellFormedModule)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op wellFormed : Module Term ~> Bool
        [special (
           id-hook MetaLevelOpSymbol	(metaWellFormedTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op wellFormed : Module Substitution ~> Bool
        [special (
           id-hook MetaLevelOpSymbol	(metaWellFormedSubstitution)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op getKind : Module TypeMeta ~> Kind
        [special (
           id-hook MetaLevelOpSymbol	(metaGetKind)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op getKinds : Module ~> KindSet
        [special (
           id-hook MetaLevelOpSymbol	(metaGetKinds)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op maximalSorts : Module Kind ~> SortSet
        [special (
           id-hook MetaLevelOpSymbol	(metaMaximalSorts)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op minimalSorts : Module Kind ~> SortSet
        [special (
           id-hook MetaLevelOpSymbol	(metaMinimalSorts)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op maximalAritySet : Module Qid TypeMetaList Sort ~> TypeMetaListSet
        [special (
           id-hook MetaLevelOpSymbol	(metaMaximalAritySet)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upModule : Qid Bool ~> Module
        [special (
           id-hook MetaLevelOpSymbol	(metaUpModule)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upImports : Qid ~> ImportList
        [special (
           id-hook MetaLevelOpSymbol	(metaUpImports)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upSorts : Qid Bool ~> SortSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpSorts)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upSubsortDecls : Qid Bool ~> SubsortDeclSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpSubsortDecls)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upOpDecls : Qid Bool ~> OpDeclSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpOpDecls)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upMbs : Qid Bool ~> MembAxSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpMbs)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upEqs : Qid Bool ~> EquationSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpEqs)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upRls : Qid Bool ~> RuleSet
        [special (
           id-hook MetaLevelOpSymbol	(metaUpRls)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upView : Qid ~> View
        [special (
           id-hook MetaLevelOpSymbol	(metaUpView)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op upTerm : Universal -> Term
        [poly (1)
         special (
           id-hook MetaLevelOpSymbol	(metaUpTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

  op downTerm : Term Universal -> Universal
        [poly (2 0)
         special (
           id-hook MetaLevelOpSymbol	(metaDownTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .

*** backward compatibility
  op metaPrettyPrint : Module Term ~> QidList .
  eq metaPrettyPrint(M:Module, T:Term) = metaPrettyPrint(M:Module, T:Term, mixfix flat format number rat) .
endm


