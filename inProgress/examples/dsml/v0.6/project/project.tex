\documentclass[a4paper,11pt,twoside]{article}
\usepackage[utf8x]{inputenc}

%\usepackage{TheStyle}
\usepackage{fullpage}
\usepackage{float}
\usepackage{theorem}
\usepackage{color}

\usepackage[english]{babel}



\newcommand{\dsml}{\textsc{dsml}}
\newcommand{\dsmls}{\textsc{dsml}s}
\newcommand{\mde}{\textsc{mde}}
\newcommand{\kmt}{\textsc{kermeta}}
\newcommand{\uml}{\textsc{uml}}
\newcommand{\ocl}{\textsc{ocl}}
\renewcommand{\L}{\mathcal{L}}

\title{Formal Support for Defining and Verifying Domain-Specific Modelling Languages}
\author{Dorel Lucanu and Vlad Rusu}
\date{\texttt{dlucanu@info.uauic.ro \quad Vlad.Rusu@inria.fr}}

\begin{document}
\pagestyle{plain}
\maketitle

\section*{Motivation}
Domain-Specific Modelling Languages (\dsmls) are languages dedicated to modelling specific application areas. Recently, the design of \dsmls\
has become widely accessible to engineers trained in the basics of Model-Driven Engineering (\mde): one designs
 a \emph{metamodel} for the language's abstract syntax; then, the language's operational semantics is expressed using \emph{model transformations} over
the metamodel. Such designs can be implemented using  \mde\ tools~\cite{DBLP:conf/uml/MullerFJ05,DBLP:journals/scp/JouaultABK08,qvt}.
%The analogy with the Structured Operational Semantics (\textsc{sos}) framework is that  models play the roles of abstract syntax trees, and model transformations play the
%role of  \textsc{sos} rules.

The democratisation of  \dsml\ design catalysed by \mde\ is likely to give birth to  numerous languages. 
One can also reasonably expect that there shall be  numerous errors in those languages. Indeed, getting a language right (especially its operational semantics)
is  hard, regardless of whether the language is defined  in the  modern \mde\ framework or in   more traditional ones.

Formal approaches can benefit language designers by helping them  avoid or detect errors. But, in order to be
accepted by nonexpert users, formal approaches have to 
%be ``hidden'' behind
operate in the background of a familiar design process,  such as the \mde-based one mentioned above.



\section*{Project Outline}
We propose to build on our experience of using the K formal framework~\cite{rosu-serbanuta-2010-jlap}, which has been shown effective at  defining real programming languages such as C~\cite{ellison-rosu-2010-tr},  
Java~\cite{farzan-chen-meseguer-rosu-2004-cav}
Scheme~\cite{meredith-hills-rosu-2007-tr-b}.
K~is based on rewriting and is connected to verification tools: a model checker, and a verifier 
 \emph{matching logic} properties~\cite{rosu-ellison-schulte-2010-amast}.
K's strength  lies in its modularity: one can define a language by combining ``language modules'' containing the  language features (imperative, functional, object-oriented, multithereading, \ldots) that one wishes. Regarding the definition of \dsml, our proposal is \emph{not} to define them directly in K, since 
K is unlikely to be easily adopted by nonexperts. Rather, we propose to define in K the ingredients for the  \mde-based approach to \dsml\ definition:


\begin{itemize}
\item define in K a language for writing metamodels. We are planning to adpot \textsc{km3}~\cite{DBLP:conf/fmoods/JouaultB06}, which has a complete and minimal set of constructors,
 as well as  clear syntax and semantics.
\item define in K an object-oriented language, possibly by drawing inspiration from the
  \textsc{kool} language~\cite{hills-rosu-2007-rta} used for teaching.
This new language will be (tentatively)  called by \textsc{mool}. Graphs of classes in  \textsc{mool} will constitute metamodels and will follow the 
\textsc{km3} syntax.
\textsc{mool} will also have primitives for creating and for modifying models conforming to metamodels (i.e., graphs of instances of the classes, linked by instances of the references
between classes). Those primitives include model-specific instructions (i.e., modifying the value of an object's attribute) as well as general impoerative instructions
(loops, if-then-else, \ldots).


\item define in K the subset of  \ocl~\cite{ocl} called \emph{essential \ocl}. \ocl\ is a language for model navigation, 
 query, and constraints, and essential \ocl\  is its  subset used in metamodelling;
\item merge  the two definitions to obtain an ``object-oriented metalanguage'', say, \textsc{mool+ocl}.
\end{itemize}

In \textsc{mool+ocl}  we shall be able to define a \dsml\ syntax as a metamodel possibly extended with \ocl\ invariants for expressing well-formedness constraints. Regarding a  \dsml's operational semantics, it will only  be possible
at this stage of the project to define it using the imperative constructs of the \textsc{mool} sublanguage. This means that we shall have the same functionality as \kmt~\cite{DBLP:conf/uml/MullerFJ05}, with the additional advantage of being formal and connected to verification tools. 


 However,  imperative programming is sometimes too low-level for defining operational semantics~; for instance, executing
finite-state machines in \kmt\ takes several dozen line\footnote{see \texttt{http://www.kermeta.org/docs/KerMeta-How-to-add-behavior-to-a-metamodel.pdf}.}.

The same definition only takes one  rewrite  rule in a rewrite-based framework; see, e.g.,~\cite{r10b}. 

Hence, the next step of our project is to extend  our forthcoming K definition of the \ocl\ language into  a \emph{rewrite-rule based language for defining \dsml\ semantics}. The rewrite
rules of that language shall be  mapped to K conditional rewrite rules, whose conditions shall naturally be expressed in \ocl. When this is done, the  \textsc{mool+ocl}  language will 
allow us to:
\begin{itemize}
\item write metamodels, in particular, for defining the abstract syntax of a given \dsml;
\item check the conformance of models with respect to  metamodels enriched with well-formedness \ocl\ constraints; in particular, such models can represent ``programs'' in a given \dsml;
\item write model transformations by combining imperative instructions and declarative rules. Such transformations can denote operational semantics, 
or translations between   \dsmls. We expect that  transformations denoting operational semantics will use mostly rewrite rules, and  transformations denoting translations will use mostly imperative instructions;
\item execute, simulate, and verify model transformations with respect to expected properties.
\end{itemize}
Among the expected properties, interesting ones \emph{safety properties}, for model transformations encoding a \dsml's operational semantics; and \emph{simulation properties}, for expressing the fact that a translation between \dsml\ expressed as a model transformation 
preserves operational semantics. Such properties could be expressed as predicates written in \ocl, over single models (for safety), and over pairs of models (for simulation). To perform the verifications we are planning to use, possibly after adapting them, the K model checker and matching logic verifier.



\section*{Comparison with Related Work}
\kmt~\cite{DBLP:conf/uml/MullerFJ05} an object-oriented language extended with metamodelling feature,  which allows users to define the syntax of \dsml\ using of metamodels, and their operational semantics
by means of imperative commands of the language (assignments, loops, \ldots). Compared to \kmt, \textsc{mool+ocl} is \emph{formally defined}, allows for \emph{verification}, and
has additional \emph{declarative features}. We  also express \emph{nondetertministic} semantics, e.g., for  parallel/concurrent languages.

\textsc{atl}~\cite{DBLP:journals/scp/JouaultABK08} is a declarative model transformation language, in which model transformations are expressed using declarative rules that may contain calls to imperative code. A formal definition of \textsc{atl} in Maude has been proposed in~\cite{DBLP:conf/icmt/TroyaV10}. Compared to this work, we expect that our definition in K of   \textsc{mool+ocl}
will  benefit from the distinctive features of K (modularity, context inference,\ldots) that make K semantics definitions  shorter and simpler than Maude ones. Also, defining a new language will allow us to  simplify some unnecessarily complex semantical issues
 (e.g., regarding the integration of  declarative and imperative features) that arise in \textsc{atl}.

Several other approaches~\cite{bhm08,rdv09,r10b} use the Maude algebraic and rewriting-based formal specification language Maude~\cite{allAboutMaude}.  In these approaches, model transformations (in particular, 
for \dsml\ operational semantics) can only be specified in a declarative manner, by mapping them to Maude equations/rewrite rules.
 Compared to these approaches, ours also includes \emph{imperative features}, which are lower-lever but allow for better
control and efficiency.
The same comparison can be drawn with declarative model transformations based on graph rewriting~\cite{DBLP:conf/agtive/Taentzer03,DBLP:conf/kbse/CsertanHMPPV02}.

Finally, the so called \emph{semantics anchoring} approach~\cite{DBLP:conf/ecmdafa/0003SAJ05} consists in endowing a source language (in particular, a \dsml) with a formal semantics by translating it
 to a target language that does have a formally defined  semantics. Our approach offers as a target language
\textsc{mool+ocl}; however, one does not translate a \dsml\ in \textsc{mool+ocl}, but \emph{defines} the \dsml\ in it.
Since  \textsc{mool+ocl}
is formally defined in K, any \dsml\ defined in  \textsc{mool+ocl} is also formally defined.
\bibliography{project}
\bibliographystyle{unsrt}
\end{document}
