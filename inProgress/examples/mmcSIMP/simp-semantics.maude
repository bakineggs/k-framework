in simp-syntax
in ../../../k-prelude

mod SIMP-SEMANTICS is including SIMP-SYNTAX + K .  
  sort Val .
  sort Res .
  subsort Int Bool < Val < Exp .

  subsorts Stmts < K .
  subsort Res < KResult .

  vars I I1 I2 : Int .  
  var N N1 N2 L : Nat .  
  var T T1 T2 : Bool .  
  var X : Id .  
  var B : Exp .
  var S S1 S2 : Stmt .  
  var K : K .  
  var Ss : Stmts .  
  var V V1 V2 : Val .

  op store  : -> CellLabel .
  op env : -> CellLabel .
  op nextLoc : -> CellLabel .

  vars Store Env : Map .

  mb configuration < T > 
                     < k > K </ k >
                     < store > .Map </ store >
		     < env > .Map </ env >
		     < nextLoc > 0 </ nextLoc >
                   </ T > : KSentence .

  mb rule < k > [X => V] ...</ k > 
	  < store >... X |-> L ...</ store > 
	  < env >... L |-> V ...</ env > : KSentence .

  mb rule [ I1 + I2 => I1 +Int I2 ] : KSentence .
  mb rule [ I1 <= I2 => I1 <=Int I2 ] : KSentence .
  mb rule [ V1 == V2 => V1 ==Bool V2 ] : KSentence .
  mb rule [ T1 and T2 => T1 andBool T2 ] : KSentence .
  mb rule [ not(T) => notBool(T) ] : KSentence .

  mb rule < k > [ skip; => .K ] </ k > : KSentence .
  mb rule < k > [ var X ; => .K ] ...</ k > 
     	  < env > [ Env => Env [L / X] ] </ env > 
          < nextLoc > [L => sNat(L)] </ nextLoc > : KSentence .
  mb rule [ {} => .K ] : KSentence .
  mb rule < k > [ {Ss} => Ss ] ...</ k > : KSentence .
  mb rule [ S1 S2 => S1 ~> S2 ] : KSentence .
  mb rule < k > [ X = V ; => .K ] ...</ k > 
     	  < env >... X |-> L ...</ env > 
	  < store > [ Store => Store [V / L] ] </ store > : KSentence .
  mb rule [ V ; => .K ] : KSentence .
  mb rule [ if true then S else ? => S ] : KSentence .
  mb rule [ if false then ? else S => S ] : KSentence .
  mb rule < k > [ while B do S  => if B then {S while B do S} else {} ] 
     	  ...</ k > : KSentence .
   
endm

--- mod SIMP is including SIMP-SEMANTICS + SIMP-PROGRAMS .
--- make sure the name of the final module is the capitalized version of the file name
---  op run : -> Bag .
--- After loading simple-untyped-compiled into maude, type "rew run .".  Replace prog by any program, then recompile.
---  eq run = < T > 
---             < k > prog </ k >
---             < env > .Map </ env >
---             < store > .Map </ store >
--- 	     < nextLoc > 0 </ nextLoc >
---           </ T > .
--- endm

