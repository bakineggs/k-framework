mod SSRISC-DCACHE-SYNTAX is including K . 

      op dwrap(_,_) :  K  K -> K .  

endm

mod SSRISC-DCACHE-SEMANTICS is including SSRISC-TIME-MODEL + SSRISC-COMMUNICATION-INTERFACE + SSRISC-DCACHE-SYNTAX + SSRISC-SYNTAX .

mb configuration 
    < k > (.).K  </ k > 
    < dc > (.).Map  </ dc > 
    < profile > 
      < dmiss > 0 </ dmiss > 
      < dhit > 0 </ dhit > 
    </ profile > : KSentence . 

      op dcachesize :  -> Int32 . 
eq dcachesize =  10 .

      op currDCacheOccup(_) :  Map -> Int32 .  
eq currDCacheOccup(M:Map (K1:K |->  K2:K)) =  currDCacheOccup(M) +Int32  1 . 
eq currDCacheOccup(. ) =  0 .


       
 
     
        
         
           

   
     
         
              

      
          
         
          

   
        
         
          

        



       
 
mb rule < k >  getd(Addr:Int32) =>  Data  ...</ k > 
     < dc >...  Addr |->  dwrap(Addr,Data:Int32) ...</ dc > 
     < dhit > H:Int32 =>  H +Int32  1 </ dhit > : KSentence . 

   
mb rule < k >  getd(Addr:Int32) =>  dmiss(Addr)  ...</ k > 
     < dc > DCache:Map </ dc > 
     if notBool ($hasMapping (DCache, Addr)) : KSentence .

mb rule < k >  getd(Addr:Int32) =>  dmiss(Addr)  ...</ k > 
     < dc >...  Addr |->  dwrap(Addr1,Data:Int32) ...</ dc > 
     if notBool (Addr ==Int32  Addr1) : KSentence .

mb rule < k >  dmissSolved(Addr:Int32, Data:Int32) =>  Data  ...</ k > 
     < dc > DCache:Map ((.).Map  =>  Addr |->  dwrap(Addr, Data))</ dc > 
     < dmiss > M1:Int32 =>  M1 +Int32  1 </ dmiss > 
     < t > T:Int32 =>  T +Int32  misstime </ t > : KSentence . 
        

      
           
         
         
        

 
mb rule < k >  putd(Addr:Int32, Data:Int32) =>  .   ...</ k > 
     < dc >...   Addr |->  dwrap(Addr, Data) ...</ dc > : KSentence .  

mb rule < k >  putd(Addr:Int32, Data:Int32) =>  .   ...</ k > 
     < dc > DCache:Map ((.).Map  =>  Addr |->  dwrap(Addr, Data))</ dc > 
     if notBool ($hasMapping (DCache, Addr)) andBool 
		(currDCacheOccup(DCache) <Int32  dcachesize) : KSentence .

   
mb rule < k >  putd(Addr:Int32, Data:Int32) =>  write(Addr1, Data1)  ...</ k > 
     < dc > DCache:Map (Addr1:Int32 |->  
                     (dwrap(Addr1, Data1:Int32) =>  dwrap(Addr, Data)))</ dc > 
     if (Addr1 %Int32  dcachesize) ==Int32  (Addr %Int32  dcachesize) andBool
         currDCacheOccup(DCache) <Int32  dcachesize : KSentence . 

   
mb rule < k >  putd(Addr:Int32, Data:Int32) =>  write(Addr1, Data1)  ...</ k > 
     < dc > DCache:Map (Addr1:Int32 |->  
                     (dwrap(Addr1, Data1:Int32) =>  dwrap(Addr, Data)))</ dc > 
     if (Addr1 %Int32  dcachesize) ==Int32  (Addr %Int32  dcachesize) andBool
         currDCacheOccup(DCache) ==Int32  dcachesize : KSentence . 

mb rule < k >  putd(Addr:Int32, Data:Int32) =>  write(Addr1, Data1)  ...</ k > 
     < dc > DCache:Map (Addr1:Int32 |->  
                     (dwrap(Addr1, Data1:Int32) =>  dwrap(Addr, Data)))</ dc > : KSentence . 



        


var T : Int32 . var Data1 : Int32 . var M1 : Int32 . var M : Map . var K2 : K . var Addr : Int32 . var Addr1 : Int32 . var H : Int32 . var K1 : K . var Data : Int32 . var DCache : Map .  ops dhit profile k dmiss dc : -> CellLabel .  endm
