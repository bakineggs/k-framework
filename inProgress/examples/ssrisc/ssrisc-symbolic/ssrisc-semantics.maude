mod SSRISC-CONFIGURATION is including SSRISC-TIME-MODEL + SSRISC-COMMUNICATION-INTERFACE + SSRISC-SYNTAX + PL-CONVERSION + K .

      subsort Instr <  K .    subsort Reg <  K .    subsort FReg <  K .  

      subsort Val32 <  KResult .    subsort Float <  KResult .  

mb configuration 

    < k > (.).K  </ k > 
    < pc > 0 </ pc > 
    < regs > (.).Map  </ regs > 
    < fregs > (.).Map  </ fregs > : KSentence . 

ops fregs k regs pc : -> CellLabel .  endm

mod SSRISC-SEMANTICS is including SSRISC-CONFIGURATION .

   
mb rule < k >  .  =>  geti(PC) </ k > 
     < pc > PC:Int32 </ pc > : KSentence .   

mb rule < k >  incPC(PC) =>  .   ...</ k > 
     < pc > PC:Int32 =>  PC +Int32  4 </ pc > : KSentence .   

mb rule < k >  setPC(1, NewV:Int32) =>  .   ...</ k > 
     < pc > Pc:Int32 =>  NewV </ pc > : KSentence .  

mb rule < k >  setPC(0,  ? ) =>  .   ...</ k > : KSentence . 

  
mb rule  < k >  R:Reg =>  Value:Val32  ...</ k > 
      < regs >...  R |->  Value:Val32 ...</ regs > : KSentence . 

  
mb rule < k >  update(Value:Val32, Rd:Reg) =>  .  </ k > 
     < regs >...   Rd |->  ( ?  =>  Value)  ...</ regs > : KSentence . 



     

 
    
mb rule < k >  add Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 +Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  addu Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 +Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  addi Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 +Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  addiu Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 +Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  sub Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 -Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  subi Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 -Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  and Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 &Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  andi Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 &Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  or Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 |Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  ori Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Val1 |Int32  Val2, Rd) </ k > : KSentence . 

    
mb rule < k >  sll Rd:Reg,Val1:Val32,V3:Nat ;  =>  update(Val1 <<Int32  V3, Rd) </ k > : KSentence . 

    
mb rule < k >  srl Rd:Reg,Val1:Val32,V3:Nat ;  =>  update(Val1 >>Int32  V3, Rd) </ k > : KSentence . 

   
    
mb rule < k >  sra Rd:Reg,Val1:Val32,V3:Nat ;  =>  update(Val1 >>Int32  V3, Rd) </ k > : KSentence . 

    
mb rule < k >  slt Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Bool2IntSy(Val1 <SyInt32  Val2), Rd) </ k > : KSentence . 

    
mb rule < k >  slti Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Bool2IntSy(Val1 <SyInt32  Val2), Rd) </ k > : KSentence . 

    
mb rule < k >  sltu Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Bool2IntSy(Val1 <SyInt32  Val2), Rd) </ k > : KSentence . 

    
mb rule < k >  sltiu Rd:Reg,Val1:Val32,Val2:Val32 ;  =>  update(Bool2IntSy(Val1 <SyInt32  Val2), Rd) </ k > : KSentence . 

  
mb rule < k >  j Addr:Int32 ;  =>  setPC(1, Addr) </ k > : KSentence . 

  
mb rule < k >  jr Rs:Reg ;  =>  setPC(1, Rs) </ k > : KSentence . 

mb rule < k >  beq Val1:Val32, Val2:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 ==BoolSy  Val2), Addr) </ k > : KSentence . 

    
mb rule < k >  bne Val1:Val32, Val2:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 =/=BoolSy  Val2), Addr) </ k > : KSentence . 

   
mb rule < k >  bltz Val1:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 <SyInt32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  bgtz Val1:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 >SyInt32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  blez Val1:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 <=SyInt32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  bgez Val1:Val32, Addr ;  =>  setPC(Bool2IntSy(Val1 >=SyInt32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  lui Rt:Reg, Imm:Int32 ;  =>  update(Imm, Rt) </ k > : KSentence . 

   
mb rule < k >  lw Rd:Reg, Off:Int32(Val1:Val32);  =>  update(getd(Val1 +Int32  Off), Rd) </ k > : KSentence . 


   
mb rule < k >  lw Rd:Reg, (Val1:Val32 +  Val2:Val32);  =>  update(getd(Val1 +Int32  Val2), Rd) </ k > : KSentence . 

   
mb rule < k >  sw Rd:Reg, Off:Int32(Val1:Val32);  =>  putd(Val1 +Int32  Off, Rd) </ k > : KSentence . 

   
mb rule < k >  sw Rd:Reg, (Val1:Val32 +  Val2:Val32);  =>  putd(Val1 +Int32  Val2, Rd) </ k > : KSentence . 
     
 
mb rule < k >  nop ;  =>  (.).K  </ k > : KSentence . 

var Value : Val32 . var V3 : Nat . var Rd : Reg . var Off : Int32 . var Val2 : Val32 . var Pc : Int32 . var Addr : Int32 . var PC : Int32 . var Imm : Int32 . var Val1 : Val32 . var Rt : Reg . var R : Reg . var Rs : Reg . var NewV : Int32 .  endm


