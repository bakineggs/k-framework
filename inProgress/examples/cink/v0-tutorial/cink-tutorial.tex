\documentclass[11pt,a4paper]{article}
\usepackage{epsf}
\usepackage{bm}
\usepackage{color}
\usepackage{latexsym}
\RequirePackage{amsopn}
\RequirePackage{amsfonts}
\RequirePackage{amsthm}

\title{Tutorial for {\bf Cink}}
\author{Radu Mereu\c{t}\u{a}, Andrei Arusoaie\thanks{\{radu.mereuta, andrei.arusoaie\}@infoiasi.ro} \\ Formal Methods in Software Engineering \\ Faculty of Computer Science Ia\c{s}i}

% Here I define a new command "\real" which can now be used in the text
\newcommand{\real}{\mathbb{R}}
% Several other commands that are useful for my purposes
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newcommand{\roo}{\real^{\scriptstyle \Omega\times\Omega}}  %fn space R^Om*Om
\newcommand{\sym}{\mbox{\em sym}}                           %symmetric reps
\newcommand{\alt}{\mbox{\em alt}}                           %alternating reps
\newcommand{\dirsum}{\oplus}                                %direct sum
\newcommand{\comp}{\circ}                                   %composition sign
\newcommand{\sOmega}{{\scriptscriptstyle \Omega}}
\newcommand{\complex}{\mathbb{C}}                           %complex numbers
\newcommand{\CX}{\mathcal{X}}                               %a vector space or category
\newcommand{\ro}{\real^{\scriptstyle \Omega}}               %function space R^\Omega
\newcommand{\sOmegap}{{\scriptscriptstyle \Omega'}}
\newcommand{\CM}{\mathcal{M}}                               %measure category


\begin{document}

\maketitle


\tableofcontents


\section{K, K-Framework, K-Maude}
\noindent K is an executable semantic framework in which programming languages, calculi, as well as type systems or formal analysis tools can be defined making use of {\bf configurations}, {\bf computations} and {\bf rules} [2]. 

\noindent The K framework is a semantic definitional framework inspired from rewriting logic but specialized and optimized for programming languages. It consists of three components: a concurrent rewrite abstract machine, a language deﬁnitional technique, and a specialized notation [1].

\noindent We recall from [2] the main features of the K framework:

\begin{itemize}
\item Configurations organize the system/program state in units called cells, which are labeled and can be nested. 

\item Computations carry "computational meaning" as special nested list structures sequentializing computational tasks, such as fragments of program; in particular, computations extend the original language or calculus syntax. 

\item K (rewrite) rules generalize conventional rewrite rules by making it explicit which parts of the term they read-only, write-only, or do not care about. This distinction makes K a suitable framework for defining truly concurrent languages or calculi even in the presence of sharing. 

\end{itemize}

\noindent Since computations can be handled like any other terms in a rewriting environment, that is, they can be matched, moved from one place to another in the original term, modified, or even deleted, K is particularly suitable for defining control-intensive language features such as abrupt termination, exceptions or call/cc [2].

\noindent K-Maude is an implementation of the K language deﬁnitional framework in Maude. K-Maude consists of an interface, which allows one to deﬁne a language using both special K modules and Maude modules. The K modules are translated into intermediate representation Maude modules, which can be further translated into executable Maude modules to obtain interpreters. \textit{Conﬁgurations}, \textit{K-contexts}, \textit{K-equations}, and \textit{K-rules} are all encoded as membership axioms[1]. These axioms are transformed into a rewrite theory which is able to execute programs in the defined language.

\subsection{Download K repository}

To get the prototype you have to download the sources from the google code repository. To do so, you can use (for example) the svn from linux:
\begin{verbatim}
linux$ svn checkout http://k-framework.googlecode.com/svn/tags/latest/
\end{verbatim}

Now, you can see in your current directory a folder called {\bf latest} and inside you can find the K
prototype itself and some basic examples:

\begin{verbatim}
linux$ cd latest
linux$ ls
editor-support       INSTALL
k-prelude.maude      newTests
README               socket.maude
tools                examples
k-model-checker.maude
LICENSE              pl-builtins.maude
regressionTests      TODO
\end{verbatim}

It's important to notice that here we can find the {\bf k-prelude.maude} file which is usually included in all K definitions. The {\bf tools} folder includes the source code for K-prototype which uses different languages/systems: maude, perl, bash, haskell as well as simple text files. The most important one is called {\bf kompile.pl}. This file is responsible with preprocessing and compilation of K code into maude code. You can create a Makefile to call this automatically.

In {\bf latest/examples/} there are a few K definitions for different types of languages (object oriented, imperative, functional and so on) which can be very helpful when writing a definition from scratch.
\section{Initial settings \label{init}}

{\bf Cink} is a small language definition used in {\bf K} taught at FII UAIC. You can find a zip archive including all versions of Cink at the address: 
\\{\color{red} https://portal.info.uaic.ro/curs/mfis/Resurse/kc.zip}. 

\subsection{Configuring the files}
Because all examples are developed in {\bf latest/examples/} we can create here a folder called {\bf cink} and inside it another one called {\bf v0}:
\begin{verbatim}
-$ mkdir cink
-$ cd cink
-$ mkdir v0
\end{verbatim}

\noindent Now you need to copy some files in the newly created {\bf cink/v0} folder:

\begin{itemize}
\item all *.k files from the archive cink.zip downloaded from the courses portal
\item example.yml and filterOutput from the same archive
\end{itemize}

\subsection{Running it for the first time}

Be sure you are in the in folder {\bf v0} and execute the command:

\begin{verbatim}
-$ make
\end{verbatim}

After compilation you’ll see that kompile.pl generated for each .k file a corresponding .maude file. Also, kompile.pl creates an aditional file called shared.maude. This file contains KLabel declarations which are used in all other maude files.

At this moment we can test the definition. To do so, go back to folder v0. You should find there a file fact.c, which is a simple C file that calculates the factorial of a number. There should be another Perl file named kcinkc.pl. This is a script that automates the compilation of a program. It first transforms the .c file into a .k file (the k definition of the program). In the second step it compiles it into a maude file, with the help of kompile.pl. The last step is to create another Perl file (i.e. fact.exe.pl) that will execute the program and show the result.
This requires 2 other files: example.yml - should be in folder v0; and filterOutput - should be in parent directory. If you want to change the location of this files, you have to edit the paths in kcinkc.pl.

Lets look at a practical example:

\begin{verbatim}
-$ ./kcinkc.pl fact.c 5
\end{verbatim}
Note: if you want to give arguments to your program, just append them after the kcinkc.pl call.

\begin{verbatim}
-$ ./fact.exe.pl
\end{verbatim}

The script fact.exe.pl runs automatically the output filter program which receives as arguments a yml configuration file and the maude output after execution. If the script gives an error because it cannot find maude, filterOutput or example.yml then you can open kcinkc.pl and change the variables \verb^$kompile_path^, \verb^$maude_path^, \verb^$format_yml^ or \verb^$filter^ accordingly, and compile again.

\section{Adding new functionalities to Cink}

In the sections above we described how to compile and run CINK. In order to learn how to use K we should also try to add a few functionalities to CINK.

\subsection{Adding \texttt{++}, the postfix operator}
Steps:

\noindent 1. open cink-syntax.k and add \texttt{++} as being an Exp:

\begin{tabbing}
\hspace{1cm}\verb+syntax Exp ::= Int | Id+
\\ \hspace{3.1cm} $ $ ...
\\ \hspace{3.3cm} \verb^|  Exp ++ [prec 0]^
\end{tabbing}

\noindent 2. open cink-semantics.k and add a rule which describes semantics for ++

\begin{verbatim}
  rule [increment] :
    <k> ID:Id ++ => I <_/k>
    <env_> ID |-> ( I => I +Int 1 )<_/env>
    [structural]
\end{verbatim}

This rule specifies that when the statement \texttt{Id ++}  is on the top of the k cell then replace the value \texttt{I} mapped in the environment for \texttt{ID} with \texttt{I++} and rewrite \texttt{ID ++} with \texttt{I} (postfix operator). This rule can also be written using ASTs (prefix form of an operator):

\begin{verbatim}
  rule [increment] :
    <k> '_++(ID:Id) => I <_/k>
    <env_> ID |-> ( I => I +Int 1 )<_/env>
    [structural]
\end{verbatim}

\noindent 3. create the file mycounter.c and write the following program that uses the ++ operator:

\begin{verbatim}
#include <stdio.h>

int main() {
  int n;
  int sum;
  int i;
  sum = 0;
  i = 0;
  scanf("%d", &n);
  while (n > i) {
    sum = sum + i;
    i++;
  }
  printf("%d;", sum);
}
\end{verbatim}

\noindent 4. Test it:

\begin{verbatim}
-$ ./kcinkc.pl mycounter.pl 10
-$ ./mycounter.exe.pl
\end{verbatim}

Notice that we also added some precedence for this operator because it should always be evaluated before the other operators. K will not complain if the precedence is omitted but it is very likely not to get the expected output.

Often, at this step it is possible to get some errors. One of the most frequent is when you forget to declare variables. If instead of rule:

\begin{verbatim}
  rule [increment] :
    <k> '_++(ID:Id) => I <_/k>
    <env_> ID |-> ( I => I +Int 1 )<_/env>
    [structural]
\end{verbatim}

you write:

\begin{verbatim}
  rule [increment] :
    <k> '_++(ID) => I <_/k>
    <env_> ID |-> ( I => I +Int 1 )<_/env>
    [structural]
\end{verbatim}

then you will get the following error:

\begin{verbatim}
-$ make
ERROR:
Warning: "cink-semantics.maude", line 45
   (mod CINK-SEMANTICS): bad token ID.
Warning: "cink-semantics.maude", line 44
   (mod CINK-SEMANTICS): no parse for statement
mb [increment] : rule < k > ID ++ => I ...
Aborting the compilation
\end{verbatim}

The construction \texttt{ID:Id} is a declaration of variable \texttt{ID} which has the sort \texttt{Id} . In K you can declare variables on the fly, and after that you can use them without declaring them again.

Another frequent error is when you forget to put spaces around the operators and the definitions. This one occurs when you declare in kc-syntax the \verb^++^ operator without whitespaces around it (\verb^Exp++^ instead of \verb^Exp ++ ^).:

\begin{verbatim}
$ make
ERROR:
Warning: "cink-syntax.maude", line 18 (mod CINK-SYNTAX):
   undeclared sort +.
Warning: the connected component in the sort graph that contains
   sort Builtins could not be linearly ordered due to a cycle.
Warning: "cink-syntax.maude", line 2 (mod CINK-SYNTAX): this
   module contains one or more errors that could not be patched
   up and thus it cannot be used or imported.
Warning: "cink-syntax.maude", line 63 (mod 
   CINK-DESUGARED-SYNTAX): unable to use module CINK-SYNTAX
   due to unpatchable errors.
Warning: "cink-syntax.maude", line 74: undeclared sort Stmt.
Warning: "cink-syntax.maude", line 74: undeclared sort Id.
Warning: "cink-syntax.maude", line 74: undeclared sort DeclId.
Warning: "cink-syntax.maude", line 74: undeclared sort Exp.
Warning: "cink-syntax.maude", line 74: undeclared sort StmtList.
Warning: "cink-syntax.maude", line 69 (mod
   CINK-DESUGARED-SYNTAX): bad token else.
Aborting the compilation
\end{verbatim}

This happens because K interprets \texttt{Exp++} as a new sort and then passes that to maude, which complains about not finding the declaration of sort \verb^+^ after \verb^Exp^ .

Usually, you can consider only first errors which are displayed. kompile.pl shows only first ten lines of errors but you can find the rest of them in the generated kompile\_errXXXXXXXXXX.txt. The script also generates a kompile\_inXXXXXXXXXX.txt and kompile\_outXXXXXXXXXX.txt files which are  temporary files, very helpful for debugging. The first one contains the last input given to maude and the second one contains the last output of maude.

\subsection{Refining the memory}

Now the memory for cink is abstracted by a mapping variable $\to$ value stored in the cell \verb+<env>+. We refine this definition with two cells, \verb+<env>+ keeping a mapping variables $\to$ locations and the cell \verb+<mem>+ which maps locations $\to$ values. We should also have to determine which is the available location in the memory so we will add the \verb^<next>^ cell. This will help us later to add arrays and pointers to cink language. The new configuration will be:

\begin{verbatim}
 configuration <T>                                                           
                  <k> .K </k>                                                   
                  <env> .Map </env>                                             
                  <funs> .Map </funs> @latex("\\kBR")                           
                  <in> .List </in>                                              
                  <out> "" </out>                                               
                  <mem> .Map </mem>                                             
                  <next> initialLoc </next>                                     
               </T> 
\end{verbatim}

Now we have to modify the semantics of some operations. First we change the lookup rule, because the value which has to be returned is located in the memory, not in the environment. 

\begin{verbatim}
rule [mem-lookup] :
       <k> X:Id => V <_/k>                                                      
       <env_> X |-> L <_/env>                                                   
       <mem_> L |-> V <_/mem>                                                   
       [structural]
\end{verbatim}

\noindent The update rule is changed accordingly:
\begin{verbatim}
rule [mem-update] :
       <k> X = V => V <_/k>                                                     
       <env_> X |-> L <_/env>                                                   
       <mem_> L |-> (_ => V) <_/mem>                                            
       [structural]
\end{verbatim}

\noindent We also have to change the ++ rule :
\begin{verbatim}
rule <k> ID:Id ++ => I <_/k>                                                  
       <env_> ID |-> L:Nat <_/env>                                              
       <mem> L |-> ( I => I +Int 1 ) <_/mem>                                    
       [structural]
\end{verbatim}

\noindent Memory is changed when a scanf occurs and we have to change the semantics of scanf too:
\begin{verbatim}
rule [read-local]:                                                            
       <k> scanf("%d",& X) => void <_/k>                                        
       <env_> X |-> L <_/env>                                                   
       <mem_> L |-> (_ => I) <_/mem>                                            
       <in> (ListItem(I) => .) <_/in>
\end{verbatim}

\noindent The allocation rule is changed into:

\begin{verbatim}
rule [var-decl] :
       <k> int X => void <_/k>
       <env_> . => (X |-> L) <_/env>
       <mem_> . => (L |-> initial) <_/mem>
       <next> L => L +Nat 1 </next>
       [structural]
\end{verbatim}

\noindent Here me make use of \verb^initial^ which is the default value for a newly allocated variable like \verb^int X;^. We also used \verb^initialLoc^ when we added the \verb^<next>^ cell in the configuration. Now, we have to define those constants, and to do so we add the following two rules: 

\begin{verbatim}
rule initialLoc => 1 [structural]                                             
rule initial => 0 [structural] 
\end{verbatim}

Test the new semantics by recompiling everything and running one of the examples:

\begin{verbatim}
-$ make
-$ ./kcinkc.pl mycounter.pl 10
-$ ./mycounter.exe.pl
\end{verbatim}

Note: notice that the \verb^<env>^ and \verb^<mem>^ are not shown after the execution of mycounter. You can choose what cells to be printed by editing the file example.yml. For example if you want to print the \verb^<env>^ cell, add the following lines, with the colors of your choosing:

\begin{verbatim}
env:
  text-style:
    foreground: red
  cell-style:
    foreground: blue
\end{verbatim}

When adding new cells the script can throw some warnings. When you misspell a cell in configuration like this: \verb^<mem> somecontent </me>^ then the tool reports:

\begin{verbatim}
[ERROR][40] in [cink-semantics.k] @ [45]: [configuration (@ line 31)
 cannot be parsed --> mismatched cell at line 38].
Can't call method "getDocumentElement" on an undefined value at
  ../../../../tools/configuration_parser.pl line 740.
Aborting the compilation
\end{verbatim}

\noindent If you misspell a cell name in a rule you can receive this error:
\begin{verbatim}
ERROR:
Warning: "cink-semantics.maude", line 64 
 (mod CINK-SEMANTICS): bad token mm.
Warning: "cink-semantics.maude", line 61
 (mod CINK-SEMANTICS): no parse for statement
mb [var-decl] : rule < k > int X => void ...</ k >
    < env >... (.) .Map => (X |-> L) ...</ env >
    < mem >... . => (L |-> initial) ...</ mm >
    ...
\end{verbatim}

In general, the tool throws all maude errors which occur during compilation. If you have difficulties when debugging K code you can try to use maude debugger: first use \verb^kompile -m cink^ to maudify K code and then load cink.maude into maude.

\newpage
\section{K builtin functions}

You can find some builtin functions in file k-prelude.maude from {\bf /latest} directory.

Here are some functions you may use while developing kc:
\\\\
\begin{tabular} {| l | p{5cm} | }
\hline
\texttt{lengthList\{K\} : List\{K\} -> Nat} & returns the length of a List\{K\} \\ \hline
\texttt{headList\{K\} : List\{K\} -> K} & returns the head of a list \\ \hline
\texttt{tailList\{K\} : List\{K\} -> K} & returns the tail of a list \\ \hline
\texttt{inKList : K List -> Bool} & returns true if K is in List \\ \hline
\texttt{lengthList : List -> Nat} & returns the length of a generic list \\ \hline
\texttt{\$hasMapping : Map , K -> Bool} & returns true if there is any key=K in the Map \\ \hline
\texttt{keys : Map -> Set} & returns the set of all keys from Map \\ \hline
\texttt{\_ in \_ : K Set -> Bool} & returns true if K is in Set \\ \hline
\texttt{\_ in \_ : K Bag -> Bool} & returns true if K is in Bag \\ \hline
\texttt{getKLabel : K -> KLabel} & returns the KLabel component for a given K \\ \hline
\texttt{getList : K -> List\{K\}} & returns the singleton list List\{K\} which contains the object K \\ \hline
\texttt{Map[undef/ K1,,NList1]} & all the elements of list K1 will be replaced with undef \\ \hline
\end{tabular}
\\\\
\noindent Note: \texttt{List\{K\}} is a sort. The "\{ \}" have no special meaning, they are a part of the sort name. It's a convention to specify the sort of elements in the list.

\begin{thebibliography}{9}


\bibitem{WRLA} G. Ro\c{s}u, T. F. \c{S}erbanu\c{t}\u{a}, \emph{K-Maude: A Rewriting Based Tool for Semantics of Programming Languages} at University of Illinois at Urbana-Champaign, WRLA'10, LNCS 6381, pp 104-122. 2010

\bibitem{JLAP} G. Ro\c{s}u, T. F. \c{S}erbanu\c{t}\u{a}, \emph{An Overview of the K Semantic Framework } at University of Illinois at Urbana-Champaign, J.LAP, Volume 79(6), pp 397-434. 2010


\end{thebibliography}


\newpage


\end{document}
