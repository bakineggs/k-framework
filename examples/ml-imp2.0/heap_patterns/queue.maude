mod QUEUE-HP is inc LIST-HP .
 var N : Nat . 
 var P P' Q Q' : Int++ . 
 var I I' : Int++ .
 var Alpha Beta : Seq++ . 
 var H : Map .
 var K : K . 
 var Phi : Formula . 
 var Cfg : BagItem . 
 var CfgItems Cfgs : Bag . 
 
 op queue : -> HeapLabel .

ceq < tasks > < config > < k > derive(P') ~> K </ k > < heap > queue(P)(Alpha) H </ heap > < form > Phi </ form > CfgItems </ config > Cfgs </ tasks >
    < counter > N </ counter >
= < tasks > < config > < k > derive(P') ~> K </ k > < heap > H </ heap > < form > Phi /\ (P === 0) /\ (Alpha === epsilon) </ form > CfgItems </ config > 
  < config > < k > K </ k > < heap > P |-> FreeInt(N) : (nodeQueue . head) (P +Int 1) |-> FreeInt(N +Int 1) : (nodeQueue . tail) queue(FreeInt(N), FreeInt(N +Int 1))(Alpha) H </ heap >
  < form > Phi /\ ~(P === 0) </ form > CfgItems </ config > Cfgs </ tasks > < counter > N +Int 2 </ counter >
if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

eq < heap > queue(0)(Alpha) H </ heap > < form > Phi </ form > = < heap > H </ heap > < form > Phi /\ Alpha === epsilon </ form > .

rl < config > < heap > P |-> Q : (nodeQueue . head) (P +Int 1) |-> 0 : (nodeQueue . tail) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(P)(epsilon) H </ heap > CfgItems </ config > =match=> Cfg .

rl < config > < heap > P |-> 0 : (nodeQueue . head) (P +Int 1) |-> Q : (nodeQueue . tail) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(P)(epsilon) H </ heap > CfgItems </ config > =match=> Cfg .

rl < config > < heap > P |-> Q : (nodeQueue . head) (P +Int 1) |-> Q' : (nodeQueue . tail) queue(Q,Q')(Alpha) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(P)(Alpha) H </ heap > CfgItems </ config > =match=> Cfg .

ceq < tasks > < config > < k > derive(P') ~> K </ k > < heap > queue(P,Q)(Alpha) H </ heap > < form > Phi </ form >  CfgItems </ config > Cfgs </ tasks > < counter > N </ counter >
= < tasks > 
  < config > < k > derive(P') ~> K </ k > < heap > H </ heap > < form > Phi /\ (P === 0) /\ (Q === 0) /\ (Alpha === epsilon) </ form > CfgItems </ config > 
  < config > < k > derive(P') ~> K </ k > < heap > lseg(P,Q)(?Seq(N)) Q |-> FreeInt(N +Int 1) : (nodeList  . val) (Q +Int 1) |-> FreeInt(N +Int 2) : (nodeList . next) H </ heap >
  < form > Phi /\ ~(P === 0) /\ ~(Q === 0) /\ (Alpha === ?Seq(N) @ [FreeInt(N +Int 1)]) </ form > CfgItems </ config > Cfgs </ tasks > < counter > N +Int 3 </ counter >
if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === Q \/ P' === Q +Int 1) .

eq < heap > queue(P,0)(Alpha) H </ heap > < form > Phi </ form > = < heap > H </ heap > < form > Phi /\ P === 0 /\ Alpha === epsilon </ form > .
eq < heap > queue(0,Q)(Alpha) H </ heap > < form > Phi </ form > = < heap > H </ heap > < form > Phi /\ Q === 0 /\ Alpha === epsilon </ form > .

***( rl < config > < heap > Q |-> I : (nodeList  . val) (Q +Int 1) |-> Q' : (nodeList . next) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(Q,Q)(I) H </ heap > CfgItems </ config > =match=> Cfg . )***

rl < config > < heap > P |-> Q : (nodeQueue  . head) (P +Int 1) |-> Q' : (nodeQueue  . tail) lseg(Q,Q')(Alpha) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(Q,Q')(Alpha) H </ heap > CfgItems </ config > =match=> Cfg .

rl < config > < heap > P |-> Q : (nodeQueue  . head) (P +Int 1) |-> Q : (nodeQueue  . tail) Q |-> I : (nodeList  . val) (Q +Int 1) |-> Q' : (nodeList . next) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(P)([I]) H </ heap > CfgItems </ config > =match=> Cfg .

rl < config > < heap > lseg(P,Q)(Alpha) Q |-> I : (nodeList  . val) (Q +Int 1) |-> Q' : (nodeList . next) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > lseg(P,Q')(Alpha @ [I]) H </ heap > CfgItems </ config > =match=> Cfg .

rl < config > < heap > lseg(P,P')(Alpha) queue(P',Q)(Beta) H </ heap > CfgItems </ config > =match=> Cfg
=> < config > < heap > queue(P,Q)(Alpha @ Beta) H </ heap > CfgItems </ config > =match=> Cfg .
endm