mod QUEUE-HP is inc LIST-HP .
  var N : Nat .  
  var P P' Q Q' : Int++ . 
  var I I' : Int++ .
  var Alpha Beta : Seq++ .  
  var H : Map .
  var K : K .  
  var Phi : Formula . 
  var Cfg : BagItem .  
  var CfgItems Cfgs : Bag . 
  
  
  op queue : -> HeapLabel .

  ceq < tasks > 
        < config >
          < k > derive(P') ~> K </ k >
          < heap > queue(P)(Alpha) H </ heap >
          < form > Phi </ form >
          CfgItems
        </ config >
        Cfgs
      </ tasks >
      < counter > N </ counter >
    = < tasks >
        < config >
          < k > derive(P') ~> K </ k >
          < heap > H </ heap >
          < form > Phi /\ (P === 0) /\ (Alpha === epsilon) </ form >
          CfgItems
       </ config >
       < config >
        < k > K </ k >
        < heap > 
          P |-> FreeInt(N) : (nodeQueue . head)
          (P +Int 1) |-> FreeInt(N +Int 1) : (nodeQueue . tail )
          lseg(FreeInt(N), FreeInt(N +Int 1))(Alpha) 
          H 
        </ heap >
        < form > Phi /\ ~(P === 0) </ form >
        CfgItems
        </ config >
      Cfgs
      </ tasks >
      < counter > N +Int 2 </ counter >
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .
    
  eq < heap > queue(0)(Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form >  Phi /\ (Alpha === epsilon) </ form > .
  
  rl < config >
      < heap >
        P |-> Q : (nodeQueue . head)
        (P +Int 1) |-> 0 : (nodeQueue . tail)
        H 
      </ heap >
      CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
        queue(P)(epsilon) 
        H
      </ heap >
      CfgItems
     </ config >
     =match=> Cfg .

  rl  < config >
        < heap >
          P |-> 0 : (nodeQueue . head) 
          (P +Int 1) |-> Q : (nodeQueue . tail) 
          H
        </ heap >
        CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
        queue(P)(epsilon) 
        H 
      </ heap >
      CfgItems
    </ config >
    =match=> Cfg .

  rl  < config >
        < heap >
          P |-> Q : (nodeQueue . head) 
          (P +Int 1) |-> Q' : (nodeQueue . tail) 
          lseg(Q,Q')(Alpha) 
          H 
          </ heap >
          CfgItems
      </ config >
      =match=> Cfg
   => < config >
        < heap >
          queue(P)(Alpha) 
          H
        </ heap >
        CfgItems
      </ config >
      =match=> Cfg .
endm