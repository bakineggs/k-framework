mod DLIST-HP is inc CONFIG + MATHEMATICAL-SEQUENCE .
  var N : Nat .
  var P P' P1 P2 Q Q' Q1 Q2 : Int++ .
  var I : Int++ .
  var Alpha Beta : Seq++ .
  var H : Map .
  var K : K .
  var Phi : Formula .
  var NtPhi : NtFormula .
  var Cfg : BagItem .
  var CfgItems Cfgs : Bag .

*** Definition of Double Linked Lists ***
  ops dlist dlseg : -> HeapLabel .
  ceq < tasks >
        < config >
          < k > derive(P') ~> K </ k >
          < heap > dlseg(P,Q)(P1,Q1,Alpha) H </ heap >
          < form > Phi </ form >
          CfgItems
        </ config >
      Cfgs
      </ tasks >
      < counter > N </ counter >
   =  < tasks >
        < config >
          < k > derive(P') ~> K </ k >
          < heap > H </ heap >
          < form > Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </ form >
        </ config >
        < config >
          < k > K </ k >
          < heap >
            P |-> FreeInt(N) : nodeDList . val
            (P +Int 1) |-> FreeInt(N +Int 1) : nodeDList . next
            (P +Int 2) |-> Q1 : nodeDList . prev
            dlseg(FreeInt(N +Int 1),Q)(P1,P,FreeSeq(N +Int 2))
            H 
          </ heap >
          < form > Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === [FreeInt(N)] @ FreeSeq(N +Int 2))
          </ form >
          CfgItems
        </ config >
      Cfgs
      </ tasks >
      < counter > N +Int 3 </ counter >
   if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === P +Int 2 ) .
  
  ceq < tasks >
        < config >
          < k > derive(Q') ~> K </ k >
          < heap > dlseg(P,Q)(P1,Q1,Alpha) H </ heap >
          < form > Phi </ form >
          CfgItems
        </ config >
      Cfgs
      </ tasks >
      < counter > N </ counter >
    = < tasks >
        < config >
          < k > derive(Q') ~> K </ k >
          < heap > H </ heap >
          < form > Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </ form >
          CfgItems
        </ config >
        < config >
          < k > K </ k >
          < heap >
            Q |-> FreeInt(N) : nodeDList . val
            (P +Int 1) |-> P1 : nodeDList . next
            (P +Int 2) |-> FreeInt(N +Int 1) : nodeDList . prev
            dlseg(P,FreeInt(N +Int 1))(Q,Q1,FreeSeq(N +Int 2))
            H
          </ heap >
          < form > Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === (FreeSeq(N +Int 2) @ [FreeInt(N)])) </ form >
          CfgItems
        </ config >
      Cfgs
      </ tasks >
      < counter > N +Int 3 </ counter >
    if VALID(Phi ===> Q' === Q \/ Q' === Q +Int 1 \/ Q' === Q +Int 2) .

  eq < heap > dlseg(P,Q)(P,Q1,Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ (Q === Q1) /\ (Alpha === epsilon) </ form > .
   
  eq < heap > dlseg(P,Q)(P1,Q,Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ (P === P1) /\ (Alpha === epsilon) </ form > .
  
  rl  < config >
        < heap >
          P |-> I : nodeDList . val 
          (P +Int 1) |-> Q1 : nodeDList . next
          (P +Int 2) |-> Q2 : nodeDList . prev
          H
        </ heap >
        CfgItems
      </ config >
      =match=> Cfg
   => < config >
        < heap >
        dlseg(P,P)(Q1,Q2,[I]) H
        </ heap >
        CfgItems
      </ config >
      =match=> Cfg .

  rl  < config >
        < heap >
          dlseg(P,Q')(P',P1,Alpha)
          dlseg(P',Q)(Q1,Q',Beta)
          H
        </ heap >
        CfgItems
      </ config >
      =match=> Cfg
   => < config >
        < heap >
          dlseg(P,Q)(Q1,P1, Alpha @ Beta)
          H
        </ heap >
        CfgItems
      </ config >
      =match=> Cfg .
  
  eq dlist(P,Q)(Alpha) = dlseg(P,Q)(0,0,Alpha) .
  
endm            
