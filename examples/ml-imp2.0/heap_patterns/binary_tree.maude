mod BINARY-TREE-HP is inc CONFIG + MATHEMATICAL-TREE + MATHEMATICAL-SEQUENCE .
  var N : Nat .
  var P P' P1 P2 Q Q' Q1 Q2 : Int++ .
  var I : Int++ .
  var Alpha : Seq++ .
  var Sigma Tau : Tree++ .
  var H : Map .
  var K : K .
  var Phi : Formula .
  var NtPhi : NtFormula .
  var Cfg : BagItem .
  var CfgItems : Bag .


*** Definition of Trees ***
  op tree : -> HeapLabel .
 ceq < config >
       < k > derive(P') ~> K </ k >
       < heap >
         tree(P)(Tau)
         H
       </ heap >
       < form > Phi </ form >
       CfgItems
     </ config >
     < counter > N </ counter >
   = < config >
       < k > derive(P') ~> K </ k >
       < heap > H </ heap >
       < form > Phi /\ (P === 0) /\ (Tau === upsilon) </ form >
       CfgItems
     </ config >
     < config >
       < k > K </ k >
       < heap >
         P |-> FreeInt(N) : treeNode . val
         (P +Int 1) |-> FreeInt(N +Int 1) : treeNode . left
         (P +Int 2) |-> FreeInt(N +Int 2) : treeNode . right
         tree(FreeInt(N +Int 1))(FreeTree(N +Int 3))
         tree(FreeInt(N +Int 2))(FreeTree(N +Int 4))
         H
       </ heap >
       < form >
         Phi /\ ~(P === 0) /\
         (Tau === (FreeTree(N +Int 3) [FreeInt(N)] FreeTree(N +Int 4)))
       </ form >
       CfgItems
     </ config >
     < counter > N +Int 5 </ counter >
  if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq < heap > tree(0)(Tau) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ Tau === upsilon </ form > .

  rl < config >
       < heap >
         P |-> I : treeNode . val
         (P +Int 1) |-> 0 : treeNode . left
         (P +Int 2) |-> 0 : treeNode . right
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         tree(P)(upsilon [I] upsilon)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> I : treeNode . val
         (P +Int 1) |-> Q : treeNode . left
         (P +Int 2) |-> 0 : treeNode . right
         tree(Q)(Tau)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         tree(P)(Tau [ I ] upsilon)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> I : treeNode . val
         (P +Int 1) |-> 0 : treeNode . left
         (P +Int 2) |-> Q : treeNode . right
         tree(Q)(Tau)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         tree(P)(upsilon [ I ] Tau)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> I : treeNode . val
         (P +Int 1) |-> Q : treeNode . left
         (P +Int 2) |-> Q' : treeNode . right
         tree(Q)(Tau)
         tree(Q')(Sigma)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         tree(P)(Tau [ I ] Sigma)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .


*** Definition of Lists of Trees ***
  op list{tree} : -> HeapLabel .

 ceq < config >
       < k > derive(P') ~> K </ k >
       < heap >
         list{tree}(P)(Alpha)
         H
       </ heap >
       < form > Phi </ form >
       CfgItems
     </ config >
     < counter > N </ counter >
   = < config >
       < k > derive(P') ~> K </ k >
       < heap > H </ heap >
       < form > Phi /\ (P === 0) /\ (Alpha === epsilon) </ form >
       CfgItems
     </ config >
     < config >
       < k > K </ k >
       < heap >
         P |-> FreeInt(N) : treeNodeList . val
         (P +Int 1) |-> FreeInt(N +Int 1) : treeNodeList . next
         tree(FreeInt(N))(FreeTree(N +Int 2))
         list{tree}(FreeInt(N +Int 1))(FreeSeq(N +Int 3))
         H
       </ heap >
       < form >
         Phi /\ ~(P === 0) /\ ~(FreeInt(N) === 0) /\
         (Alpha === [FreeTree(N +Int 2)] @ FreeSeq(N +Int 3))
       </ form >
       CfgItems
     </ config >
     < counter > N +Nat 4 </ counter >
  if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq < heap > list{tree}(0)(Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ Alpha === epsilon </ form > .

  rl < config >
       < heap >
         P |-> 0 : treeNodeList . val
         (P +Int 1) |-> 0 : treeNodeList . next
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list{tree}(P)([upsilon])
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> I : treeNodeList . val
         (P +Int 1) |-> 0 : treeNodeList . next
         tree(I)(Tau)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list{tree}(P)([Tau])
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> 0 : treeNodeList . val
         (P +Int 1) |-> Q : treeNodeList . next
         list{tree}(Q)(Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list{tree}(P)([upsilon] @ Alpha)
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .

  rl < config >
       < heap >
         P |-> I : (treeNodeList . val)
         (P +Int 1) |-> Q : (treeNodeList . next)
         tree(I)(Tau)
         list{tree}(Q)(Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list{tree}(P)([Tau] @ Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
endm

