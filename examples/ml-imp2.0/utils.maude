---load ml-prelude.maude
---load ml-imp.maude


mod PL-META-TERM is including PL-BOOL + PL-QID .
*** types
  sorts Sort Kind Type .
  subsorts Sort Kind < Type < Qid .
  op <Qids> : -> Sort [special (id-hook QuotedIdentifierSymbol (sortQid))] .
  op <Qids> : -> Kind [special (id-hook QuotedIdentifierSymbol (kindQid))] .


*** terms
  sorts Constant Variable GroundTerm Term NeGroundTermList GroundTermList NeTermList TermList .
  subsorts Constant Variable < Qid Term .
  subsorts Constant < GroundTerm < Term NeGroundTermList < NeTermList .
  subsorts NeGroundTermList < NeTermList GroundTermList < TermList .
  op <Qids> : -> Constant [special (id-hook QuotedIdentifierSymbol (constantQid))] .
  op <Qids> : -> Variable [special (id-hook QuotedIdentifierSymbol (variableQid))] .
  op .emptyTermList : -> GroundTermList [ctor] .
  op _:_ : NeGroundTermList GroundTermList -> NeGroundTermList [ctor assoc id: .emptyTermList gather (e E) prec 121] .
  op _:_ : GroundTermList NeGroundTermList -> NeGroundTermList [ctor ditto] .
  op _:_ : GroundTermList GroundTermList -> GroundTermList [ctor ditto] .
  op _:_ : NeTermList TermList -> NeTermList [ctor ditto] .
  op _:_ : TermList NeTermList -> NeTermList [ctor ditto] .
  op _:_ : TermList TermList -> TermList [ctor ditto] .
  op _[_] : Qid NeGroundTermList -> GroundTerm [ctor] .
  op _[_] : Qid NeTermList -> Term [ctor] .

*** utils for constant/variables
  op getName : Constant -> Qid .
  op getType : Constant -> Type .
  var C : Constant .
  op getName : Variable -> Qid .
  op getType : Variable -> Type .
  var V : Variable .
  eq getName (C) = qid (substrString (string (C), 0, rfindString (string (C), ".", lengthString (string (C))))) .
  eq getType (C) = qid (substrString (string (C), rfindString (string (C), ".", lengthString (string (C))) +Nat 1, lengthString (string (C)))) .
  eq getName (V) = qid (substrString (string (V), 0, rfindString (string (V), ":", lengthString (string (V))))) .
  eq getType (V) = qid (substrString (string (V), rfindString (string (V), ":", lengthString (string (V))) +Nat 1, lengthString (string (V)))) .


  sort Module .
  sort ResultPair .
  op metaReduce : Module Term ~> ResultPair
     [special (
        id-hook MetaLevelOpSymbol	(metaReduce)

        op-hook qidSymbol		(<Qids> : ~> Qid)
        op-hook metaTermSymbol		(_[_] : Qid NeTermList ~> Term)
        op-hook metaArgSymbol		(_:_ : NeTermList NeTermList ~> NeTermList)

        term-hook trueTerm		(true)
        term-hook falseTerm		(false))] .


  op downTerm : Term Universal -> Universal
        [poly (2 0)
         special (
           id-hook MetaLevelOpSymbol	(metaDownTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .


  op upTerm : Universal -> Term
        [poly (1) strat(0)
         special (
           id-hook MetaLevelOpSymbol	(metaUpTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair)
) ] .
endm


---mod VAR-UTILS is inc CONFIG + PL-META-TERM + MAUDE-IF-THEN-ELSE .
mod VAR-UTILS is inc IMP + PL-META-TERM + MAUDE-IF-THEN-ELSE .
  op get?VarSet : Formula -> Set{MathObj++} .
  op get?VarSet : Bag -> Set{MathObj++} .
  op get?VarSet : TermList -> Set{MathObj++} .
  op get!VarSet : Formula -> Set{MathObj++} .
  op get!VarSet : Bag -> Set{MathObj++} .
  op get!VarSet : TermList -> Set{MathObj++} .
  op getFreeVarSet : Formula -> Set{MathObj++} .
  op getFreeVarSet : Bag -> Set{MathObj++} .
  op getFreeVarSet : TermList -> Set{MathObj++} .

  op getFreeMap : Bag -> Map .
  op getFreeMap : TermList -> Map .
  op getFreeBag : Bag -> Bag .
  op getFreeBag : TermList -> Bag .

  var Obj : MathObj++ .
  var Phi : Formula .
  var Cfgs : Bag .

  eq get?VarSet(Cfgs) = get?VarSet(upTerm(Cfgs)) .
  eq get?VarSet(Phi) = get?VarSet(upTerm(Phi)) .
  eq get!VarSet(Cfgs) = get!VarSet(upTerm(Cfgs)) .
  eq get!VarSet(Phi) = get!VarSet(upTerm(Phi)) .
  eq getFreeVarSet(Cfgs) = getFreeVarSet(upTerm(Cfgs)) .
  eq getFreeVarSet(Phi) = getFreeVarSet(upTerm(Phi)) .

  eq getFreeMap(Cfgs) = getFreeMap(upTerm(Cfgs)) .
  eq getFreeBag(Cfgs) = getFreeBag(upTerm(Cfgs)) .

  var Q : Qid .
  var QC : Constant .
  vars QT NT NT' : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .

  eq get?VarSet((QT : QTNeList)) = get?VarSet(QT) & get?VarSet(QTNeList) .
  eq get?VarSet(.emptyTermList) = .Set{MathObj++} .
  eq get?VarSet(QC) = if downTerm(QC, errorObj) :: ?MathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
 ceq get?VarSet(Q[QT]) = downTerm(Q[QT], .Set{MathObj++})
  if substrString(string(Q), 0, 1) ==Bool "?" .
  eq get?VarSet(Q[QTList]) = get?VarSet(QTList) [owise] .

  eq getFreeVarSet((QT : QTNeList))
   = getFreeVarSet(QT) & getFreeVarSet(QTNeList) .
  eq getFreeVarSet(.emptyTermList) = .Set{MathObj++} .
  eq getFreeVarSet(QC) = if downTerm(QC, errorObj) :: FreeMathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
  eq getFreeVarSet('skolem[NT : QT])
   = downTerm('skolem[NT : QT], .Set{MathObj++}) .
  eq getFreeVarSet(Q[QTList]) = getFreeVarSet(QTList) [owise] .

  eq getFreeMap((QT : QTNeList))
   = getFreeMap(QT) getFreeMap(QTNeList) .
  eq getFreeMap(.emptyTermList) = (.).Map .
  eq getFreeMap(QC) = if downTerm(QC, (.).Map) :: FreeMapItem then
     downTerm(QC, (.).Map) else (.).Map fi [print QC] .
  eq getFreeMap(Q[QTList]) = getFreeMap(QTList) [owise] .
endm


mod CONFIG-SCOLEM is inc VAR-UTILS .
  op skolemTerm : Term TermList -> TermList .
  op co-skolemTerm : TermList -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT NT NT' : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .

  eq skolemTerm(NT, (QT : QTNeList))
   = skolemTerm(NT, QT) : skolemTerm(NT, QTNeList) .
  eq skolemTerm(NT, .emptyTermList) = .emptyTermList .
  eq skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 1) ==Bool "?" then
       'skolem[NT : QC]
     else
       QC
     fi .
  eq skolemTerm(NT, '?Int[QT]) = 'skolem[NT : '?Int[QT]] .
  eq skolemTerm(NT, '?Seq[QT]) = 'skolem[NT : '?Seq[QT]] .
  eq skolemTerm(NT, '?Tree[QT]) = 'skolem[NT : '?Tree[QT]] .
  eq skolemTerm(NT, '?MSet[QT]) = 'skolem[NT : '?MSet[QT]] .
  eq skolemTerm(NT, 'skolem[NT' : QT]) = 'skolem[NT' : QT] .
  eq skolemTerm(NT, Q[QTList]) = Q[skolemTerm(NT, QTList)] [owise] .
 
  eq co-skolemTerm((QT : QTNeList))
   = co-skolemTerm(QT) : co-skolemTerm(QTNeList) .
  eq co-skolemTerm(.emptyTermList) = .emptyTermList .
  eq co-skolemTerm(QC)
   = if substrString(string(getType(QC)), 0, 4) ==Bool "Free" then
       'co-skolem[QC]
     else
       QC
     fi .
  eq co-skolemTerm('skolem[NT : QT]) = 'co-skolem['skolem[NT : QT]] .
  eq co-skolemTerm(Q[QTList]) = Q[co-skolemTerm(QTList)] [owise] .


  var N : Nat .
  var Cfgs : Bag .

  eq skolemize(N, Cfgs)
   = downTerm(skolemTerm(upTerm(N), upTerm(Cfgs)), errorBag) .
  eq co-skolemize(Cfgs)
   = downTerm(co-skolemTerm(upTerm(Cfgs)), errorBag) .
endm


---mod APPLY-SUBST is inc CONFIG + PL-META-TERM .
mod APPLY-SUBST is inc IMP + PL-META-TERM .
  sort MetaSubst .
  op .MetaSubst : -> MetaSubst .
  op _;_ : MetaSubst MetaSubst -> MetaSubst [assoc comm id: .MetaSubst] .
  op _<-_ : Term Term -> MetaSubst .
  op upSubst : Subst -> MetaSubst .

  var Obj Obj' : MathObj++ .
  var List List' : List .
  var Bag Bag' : Bag .
  var Set Set' : Set .
  var Map Map' : Map .
  var Subst Subst' : Subst .
  eq upSubst((Obj <- Obj') ; Subst)
   = (upTerm(Obj) <- upTerm(Obj')) ; upSubst(Subst) .
  eq upSubst((List <- List') ; Subst)
   = (upTerm(List) <- upTerm(List')) ; upSubst(Subst) .
   eq upSubst((Bag <- Bag') ; Subst)
   = (upTerm(Bag) <- upTerm(Bag')) ; upSubst(Subst) .
   eq upSubst((Set <- Set') ; Subst)
   = (upTerm(Set) <- upTerm(Set')) ; upSubst(Subst) .
   eq upSubst((Map <- Map') ; Subst)
   = (upTerm(Map) <- upTerm(Map')) ; upSubst(Subst) . 
  eq upSubst(.Subst) = .MetaSubst .

  op substTerm : TermList MetaSubst -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT QT' NT : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .
  var MetaSubst : MetaSubst .

  eq substTerm((QT : QTNeList), MetaSubst)
   = substTerm(QT, MetaSubst) : substTerm(QTNeList, MetaSubst) .
  eq substTerm(.emptyTermList, MetaSubst) = .emptyTermList .
  eq substTerm(QT, ((QT <- QT') ; MetaSubst)) = QT' .
  eq substTerm('skolem[NT : QT], MetaSubst) = 'skolem[NT : QT] .
  eq substTerm('co-skolem[QT], MetaSubst) = 'co-skolem[QT] .
  eq substTerm(QC, MetaSubst) = QC [owise] .
  eq substTerm(Q[QTList], MetaSubst)
   = Q[substTerm(QTList, MetaSubst)] [owise] .

  var Cfgs : Bag .
  var Phi : Formula .
  --- apply substitution on a configuration
  eq applySubst(Cfgs, Subst)
   = downTerm(substTerm(upTerm(Cfgs), upSubst(Subst)), errorBag) .
  --- apply substitution on a substitution
  eq applySubst(Phi, Subst)
   = downTerm(substTerm(upTerm(Phi), upSubst(Subst)), FalseFormula) .
  --- apply substitution on a substitution
  eq applySubst(Subst, Subst')
   = downTerm(substTerm(upTerm(Subst), upSubst(Subst')), .Subst) .
endm


mod CONFIG-UTILS is inc APPLY-SUBST + CONFIG-SCOLEM .
  var I : Int++ .
  eq I : : IntSort = I :: Int .
endm
