// MaxSubSeq2.ssc
//Author:Rosemary Monahan
// 15 Mar 2007
// Max_Monotone_SubSeq (A Method of Programming, Dijkstra & Feijen)

//Not verified with Simplify

using Microsoft.Contracts;

public class C 
{

  public static void Main() {
    int[] a = new int[] { 4, 0, 12, 64, -10, 20 };
    int s = MaxSubSeq(a);
    System.Console.WriteLine("The sum is {0}", s);
  } //end Main
   
    
   
   
   public static int MaxSubSeq(int[]! b)
   requires 0<=b.Length;
   /*ensures result ==  max{int k in (0..b.Length); 
                        max{int h in (0:b.Length-k),   
                          ( (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] <= b[j]}})
                             ||
                            (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] >= b[j]}})
                           ); h}};    
                           */                     
   {
    int n = 1;
    int v = 1;
    int q = 1;
    int w = 1;
    
      if (b.Length == 0)
      {
       q = 0;
      }   
      else 
      {
          while (n < b.Length)
          invariant 0< n;
          invariant n <= b.Length;
          invariant q ==  max{int k in (0..n); 
                        max{int h in (0:n-k),   
                          ( (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] <= b[j]}})
                             ||
                            (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] >= b[j]}})
                           ); h}}; 
           {
            
            assert q ==  max{int k in (0..n); 
                        max{int h in (0:n-k),   
                          ( (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] <= b[j]}})
                             ||
                            (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] >= b[j]}})
                           ); h}}; 
            if (b[n] > b[n-1])
            { w=1;
              v++;
            }
            else if (b[n] < b[n-1])
                  { w++;
                    v=1;
                  }
                  else if (b[n] == b[n-1])
                  {
                      w++;
                      v++;
                  }
                  q = max{q,max{v,w}};
                  n++;
          
       assert q ==  max{int k in (0..n); 
                        max{int h in (0:n-k),   
                          ( (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] <= b[j]}})
                             ||
                            (forall{int i in (k:k+h-1);forall{int j in (i+1:k+h);b[i] >= b[j]}})
                           ); h}}; 
              }//od
            
       } //outer fi
       return q;               
   }//MaxSubSeq
}//Class


      