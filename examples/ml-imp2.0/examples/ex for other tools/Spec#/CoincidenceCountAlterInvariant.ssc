// CoincidenceCountAlterInvariant.ssc
// Rosemary Monahan & Rustan Leino
// 22th March 2007
/* Given 2 integer arrays in monotomnically increasing order, find the number of values occurring in both 
   sequences (Coincidence count, A Method of Programming, Dijkstra & Feijen)
   Efficient version, Improved invariant.
   See CoincidenceCountEfficient for an alternative version

   assume statements needed to assist the verifier
*/ 

using System;
using Microsoft.Contracts;

  class CoincidenceCount
{
   [Rep] public int[]! f = new int[] {2,4};
   [Rep] public int[]! g = new int[] {1,4,6};

  public int Coincidence()  
  requires forall{int i in (0: f.Length), int j in (i+1: f.Length); f[i] < f[j]};
  requires forall{int i in (0: g.Length), int j in (i+1: g.Length); g[i] < g[j]};

  ensures result == count{int i in (0: f.Length), int j in (0: g.Length); f[i] == g[j]};
  {  
    int ct = 0;
    int m = 0;
    int n = 0; 

    while( (m < f.Length) && (n < g.Length))
    invariant 0<= m;
    invariant m <=f.Length; 
    invariant 0<= n;
    invariant n <=g.Length;
    invariant ct + count{int i in (m: f.Length), int j in (n:g.Length); f[i] == g[j]} == 
              count{int i in (0:f.Length), int j in (0:g.Length); f[i] == g[j]};
    {          
        if (f[m] < g[n])
        { assume forall{int j in (n: g.Length); g[n] <= g[j]};
          assert count{int i in (m: m+1), int j in (n:g.Length); f[i] == g[j]} == 0;

          m++;
          
        }
        else if (g[n] == f[m])
        {
            //both arrays are  ordered - see pre
	          //assume forall{int j in (n: g.Length); g[n] <= g[j]};
            //assume forall{int i in (m: f.Length); f[m] <= f[i]};
	          //There is one value in the remainer of g that equals f[m]	
	          //assume count{int i in (m: m+1), int j in (n:g.Length); f[i] == g[j]} == 1;
	          //equivalent to
            assume count{int j in (n:g.Length); f[m] == g[j]} == 1;

	          //There is one value in the remainer of f that equals g[n]
	          assume forall{int i in (m: f.Length); count{int j in (n: n+1); f[i] == g[j]} == 1}; 
	          assert exists{int i in (m: f.Length); f[i] == g[n]} == true;

            assert ct + 1 + count{int i in (m+1: f.Length), int j in (n+1:g.Length); f[i] == g[j]} == 
                    count{int i in (0:f.Length), int j in (0:g.Length); f[i] == g[j]}; 
          ct++;
          /*
          assert ct + count{int i in (m+1: f.Length), int j in (n+1:g.Length); f[i] == g[j]} == 
                    count{int i in (0:f.Length), int j in (0:g.Length); f[i] == g[j]}; 
             */       
          m++;
          
          /*assert ct + count{int i in (m: f.Length), int j in (n+1:g.Length); f[i] == g[j]} == 
                    count{int i in (0:f.Length), int j in (0:g.Length); f[i] == g[j]};
         */
          n++;
          
        //Invariant 
          assert ct + count{int i in (m: f.Length), int j in (n:g.Length); f[i] == g[j]} == 
                    count{int i in (0:f.Length), int j in (0:g.Length); f[i] == g[j]};
        
        }
        else
        { assume forall{int i in (m: f.Length); f[m] <= f[i]};
          assert forall{int i in (m: f.Length); count{int j in (n: n+1); f[i] == g[j]} == 0};

          n++;
          
        }//esle
   }//elihw
  return ct; 
 } //method
}//class
