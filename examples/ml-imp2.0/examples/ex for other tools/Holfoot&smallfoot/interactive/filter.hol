use (Globals.HOLDIR ^ "/examples/separationLogic/src/holfoot/header.sml");

open listTheory rich_listTheory

(******************************************************************************)
(* Parse the main file                                                        *)
(******************************************************************************)

val file = concat [examplesDir, "/interactive/filter.dsf"];


(******************************************************************************)
(* Verify specification                                                       *)
(******************************************************************************)

(* holfoot_set_goal_procedures file ["list_filter"] *)
val filter_TAC = 
  (*do everything till while loop*)
  xHF_SOLVE_TAC [stop_at_while] THEN
  HF_STEP_TAC 1 THEN
  Tactical.REVERSE CONJ_TAC THEN1 (
     (*body of original function*)
     HF_CONTINUE_TAC THEN
     (*at the beginning of the loop nothing is filtered*)
     REPEAT GEN_TAC THEN Q.EXISTS_TAC `[]` THEN
     xHF_CONTINUE_TAC [do_case_splits] THEN     
     SIMP_TAC list_ss [GSYM RIGHT_EXISTS_AND_THM, GSYM LEFT_EXISTS_AND_THM,
        GSYM LEFT_FORALL_IMP_THM, FILTER_APPEND] THEN
     xHF_SOLVE_TAC [ add_rewrites [NULL_EQ, FILTER_EQ_NIL] ] 
  ) THEN

  (* while loop *)
  xHF_SOLVE_TAC [generate_vcs] THEN
  REPEAT STRIP_TAC THENL [
     FULL_SIMP_TAC list_ss [] THEN
     HF_ELIM_COMMENTS_TAC,

     HF_ELIM_COMMENTS_TAC THEN
     Q.EXISTS_TAC `data_fc` THEN
     FULL_SIMP_TAC (list_ss++ListConv1.list_eq_simp_ss) [NULL_EQ, FILTER_EQ_NIL],

     HF_ELIM_COMMENTS_TAC THEN
     Q.EXISTS_TAC `data1` THEN
     FULL_SIMP_TAC (list_ss++ListConv1.list_eq_simp_ss) [],

     HF_ELIM_COMMENTS_TAC THEN
     Q.EXISTS_TAC `data1 ++ [date] ++ data_fc'` THEN
     FULL_SIMP_TAC (list_ss++ListConv1.list_eq_simp_ss) [
        NULL_EQ, FILTER_EQ_NIL, FILTER_APPEND,
        BUTFIRSTN_APPEND1, TAKE_APPEND1,
        BUTFIRSTN_APPEND2, TAKE_APPEND2,
        BUTFIRSTN_LENGTH_APPEND, BUTFIRSTN_LENGTH_NIL]
  ]

val spec_thm = prove (spec_t, filter_TAC)

(*or*)

val spec_thm = holfoot_tac_verify_spec file NONE 
   [("list_filter", filter_TAC)]




(******************************************************************************)
(* Using loop specs                                                           *)
(******************************************************************************)

val file2 = concat [examplesDir, "/interactive/filter.dsf2"];
val spec_t2 = parse_holfoot_file file2


(******************************************************************************)
(* Verify specification                                                       *)
(******************************************************************************)

(* holfoot_set_goal_procedures file2 ["list_filter"] *)
val filter2_TAC = 
xHF_SOLVE_TAC [stop_at_while] THEN HF_STEP_TAC 1 THEN
REPEAT STRIP_TAC THENL [
   HF_SOLVE_TAC,

   Cases_on ` yc = lc` THEN ASM_SIMP_TAC std_ss [] THENL [
      xHF_SOLVE_TAC [no_case_splits],

      HF_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `data++[zdata]` THEN
      xHF_CONTINUE_TAC [use_asms] THEN
      SIMP_TAC std_ss [GSYM APPEND_ASSOC, APPEND] THEN
      HF_SOLVE_TAC
   ],

   HF_SOLVE_TAC
];

val spec2_thm = prove (spec_t2, filter2_TAC) 

(*or*)

val spec2_thm = holfoot_tac_verify_spec file2 NONE 
   [("list_filter", filter2_TAC)]
