mod FORMULA is inc PL-BOOL + PL-STRING .
  sorts Truth Atom NtFormula Formula .
  subsort Atom < NtFormula .
  subsort Truth NtFormula < Formula .  

  ops TrueFormula FalseFormula : -> Truth .
  op @_ : Bool -> Atom [prec 0] .
  op _/\_ : NtFormula Formula -> NtFormula
  [prec 55 assoc comm id: TrueFormula] .
  op _/\_ : Formula Formula -> Formula [ditto] .
  op ~_ : Atom -> Atom [prec 0] .
  op ~_ : Formula -> NtFormula [ditto] .
  op _\/_ : NtFormula Formula -> NtFormula
  [prec 59 assoc comm id: FalseFormula] .
  op _\/_ : Formula Formula -> Formula [ditto] .
  op _===>_ : Formula Formula -> NtFormula [prec 61] .

  op check-sat : Formula -> String .

  var Atom : Atom .
  vars NtPhi NtPhi1 NtPhi2 NtPhi' : NtFormula .
  vars Phi Phi1 Phi2 Phi' : Formula .

  eq  @ true =  TrueFormula .
  eq @ false = FalseFormula .

  eq  ~(TrueFormula) = FalseFormula .
  eq ~(FalseFormula) =  TrueFormula .
  eq ~(~(Phi)) = Phi .

  eq  TrueFormula \/  TrueFormula =  TrueFormula .
  eq FalseFormula /\ FalseFormula = FalseFormula .
  eq  TrueFormula \/ NtPhi =  TrueFormula .
  eq FalseFormula /\ NtPhi = FalseFormula .
  eq NtPhi /\ NtPhi = NtPhi .
  eq NtPhi \/ NtPhi = NtPhi .
  eq NtPhi /\ ~(NtPhi) = FalseFormula .
  eq NtPhi \/ ~(NtPhi) =  TrueFormula .

  eq Phi ===>  TrueFormula = TrueFormula .
  eq Phi ===> FalseFormula = ~ Phi .
---  leads to in infinite rewriting
---  eq FalseFormula ===> Phi = TrueFormula .
  eq  TrueFormula ===> Phi = Phi .


  eq Atom /\ Phi1 ===> Atom /\ Phi2 = Atom /\ Phi1 ===> Phi2 .

  eq Phi ===> (NtPhi1 \/ NtPhi2) = (Phi ===> NtPhi1) \/ (Phi ===> NtPhi2) .

--- very, very bad eqs
---   eq NtPhi /\ (NtPhi1 \/ NtPhi2) = (NtPhi /\ NtPhi1) \/ (NtPhi /\ NtPhi2) .
---   eq (NtPhi1 \/ NtPhi2) ===> Phi = (NtPhi1 ===> Phi) \/ (NtPhi2 ===> Phi) .

--- bad, bad eq
  eq NtPhi /\ (NtPhi1 \/ NtPhi2) ===> NtPhi'
   = (NtPhi /\ NtPhi1 ===> NtPhi') \/ (NtPhi /\ NtPhi2 ===> NtPhi') [owise] .
endm


mod MATHEMATICAL-OBJECT is inc FORMULA + PL-NAT .
***(
?Sort stands for bound symbolic mathematical objects
!Sort stands for unbound symbolic mathematical objects
FreeSort stands for unbound symbolic mathematical objects
Sort stands for ground, non-symbolic mathematical objects
Sort++ stands for all the above
***)
  sorts ?MathObj !MathObj FreeMathObj MathObj MathObj++ .
  sorts List{MathObj++} Set{MathObj++} .
  subsort ?MathObj !MathObj FreeMathObj MathObj < MathObj++ .
  subsort MathObj++ < List{MathObj++} Set{MathObj++} .
  op skolem : Nat ?MathObj -> FreeMathObj [strat(0)] .
  op co-skolem : Nat FreeMathObj -> !MathObj [strat(0)] .

  op .List{MathObj++} : -> List{MathObj++} .
  op _`,_ : List{MathObj++} List{MathObj++} -> List{MathObj++}
  [assoc id: .List{MathObj++}] .

  op .Set{MathObj++} : -> Set{MathObj++} .
  op _&_ : Set{MathObj++} Set{MathObj++} -> Set{MathObj++}
  [assoc comm id: .Set{MathObj++}] .
  eq Obj & Obj = Obj .

  op errorObj : -> [MathObj++] .


  --- must not be comm (why?)
  op _===_ : MathObj++ MathObj++ -> Atom [comm] .
  op _===_ : List{MathObj++} List{MathObj++} -> Atom [ditto] .

  vars Obj Obj1 Obj1' Obj2 Obj2' : MathObj++ .
  vars ObjList1 ObjList2 : List{MathObj++} .

  eq Obj === Obj = TrueFormula .
  eq (Obj1, Obj1', ObjList1) === (Obj2, Obj2', ObjList2)
   = (Obj1 === Obj2) /\ (Obj1' === Obj2') /\ (ObjList1 === ObjList2) .
  eq .List{MathObj++} === .List{MathObj++} = TrueFormula .
endm


mod MATHEMATICAL-INT is inc MATHEMATICAL-OBJECT + PL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?Int !Int FreeInt Int++ .   --- sort Int already defined
  subsort ?Int !Int FreeInt Int < Int++ .
  subsort ?Int < ?MathObj .
  subsort !Int < !MathObj .
  subsort FreeInt < FreeMathObj .
  subsort Int < MathObj .
  subsort Int++ < MathObj++ .

  op ?Int : Nat -> ?Int .
  op !Int : Nat -> !Int .
  op FreeInt : Nat -> FreeInt .
  op skolem : Nat ?Int -> FreeInt [ditto] .
  op co-skolem : Nat FreeInt -> !Int [ditto] .

--- define operations to be used symbolically, as well as desired properties
  ops _+Int_ _-Int_ _*Int_ _/Int_ _%Int_ : Int++ Int++ -> Int++ [ditto] .
  ops _<=Int_ _<Int_ _>=Int_ _>Int_ : Int++ Int++ -> Bool [ditto] .
  ops _<<Int_ _>>Int_ : Int++ Int++ -> Int++ [ditto] .
  ops -Int_ ~Int_ : Int++ -> Int++ [ditto] .
  op _==Int_ : Int++ Int++ -> Bool [ditto] .

  op bool2int : Bool -> Int++ .
  eq bool2int(true) = 1 .
  eq bool2int(false) = 0 .

  var B : Bool .
  var I J K I1 I2 J1 J2 N : Int++ .
  var NzI : NzInt . 
  var Phi Phi1 Phi2 : Formula .

  eq @ (I ==Int J) = I === J .

  eq I +Int (-Int I) = 0 .
  eq 0 +Int I = I .
  eq I *Int (I1 +Int I2) = (I *Int I1) +Int (I *Int I2) .
  eq (-Int I) *Int J = -Int (I *Int J) .
  eq -Int (-Int I) = I .
  eq 1 *Int I = I .
  eq I -Int J = I +Int (-Int J) .
  eq -Int (I +Int J) = (-Int I) +Int (-Int J) .
---  stack overflow
---  eq I +Int (J /Int 2) = (I +Int I +Int J) /Int 2 .

  eq -Int I === 0 = I === 0 .
  eq I +Int K === J +Int K = I === J .
 ceq I1 === J1 /\ Phi1 ===> I2 === J2 /\ Phi2 = I1 === J1 /\ Phi1 ===> Phi2
  if (-Int I1) +Int (-Int I2) +Int J1 +Int J2 ==Bool 0 .

  eq I <=Int J = J >=Int I .
  eq I <Int J = J >Int I .
  eq I >Int J = I +Int (-Int 1) >=Int J . 
 ceq I >=Int J = I +Int (-Int J) >=Int 0 if J =/=Bool 0 .
  eq ~(@(I >=Int 0)) = @((-Int I) +Int (-Int 1) >=Int 0) .

 ceq @(I >=Int 0) /\ @(J >=Int 0) = (I === 0) if I +Int J ==Bool 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) = @(I >=Int 0) if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ Phi1 ===> @(J >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> @(K >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int (-Int J) +Int K >=Int 0 .

  eq (bool2int(B) === 0) = ~(@ B) .
  eq (bool2int(B) === NzI) = @ B .
  eq (0 === bool2int(B)) = ~(@ B) .
  eq (NzI === bool2int(B)) = @ B .

  eq (I:Int === J:Int) = @(I:Int ==Bool J:Int) .
  
  op abs : Int++ -> Int++ .
  
 ceq abs(I) = (-Int I) if I <=Int 0 .
  eq abs(I) = I [owise] .
  
  op moduloo : Int++ Int++ -> Int++ .
  
 ceq moduloo(I,J) = moduloo( I -Int J, J) if (I >=Int J) .
  eq moduloo(I,J) = I [owise] .

endm

