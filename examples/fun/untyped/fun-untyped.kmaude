in ../../../k-prelude
in fun-untyped-syntax
in ../fun-programs


mod FUN-UNTYPED-SEMANTICS is including FUN-DESUGARED-SYNTAX + K .
--- We need values when we define the semantics
  sort Val .
  subsort Int Bool < Val < Exp .

--- We have to subsort all the syntactic categories to K, and the lists of values
--- to KResult.  Recall that the second argument of a function application is a list
--- of expressions, so that becomes a result when it becomes a list of values
  subsort List{Exp} Binding < K .
  subsort List{Val} < KResult .

  ops env store nextLoc : -> CellLabel .
  configuration <T>
                     <k> .K </k>
                     <env> .Map </env>
                     <store> .Map </store>
                     <nextLoc> 0 </nextLoc>
                   </T> 

  rule <k> X => V _</k> <env>_ X |-> L _</env> <store>_ L |-> V _</store> 
  rule I1 + I2 => I1 +Int I2 
  rule _-_(I1,I2) => _-Int_(I1,I2) 
  rule I1 * I2 => I1 *Int I2 
  rule I1 / I2 => I1 /Int I2 if I2 =/=Bool 0 
  rule I1 % I2 => I1 %Int I2 if I2 =/=Bool 0
  rule - I => -Int I 
  rule I1 < I2 => I1 <Int I2 
  rule I1 <= I2 => I1 <=Int I2 
  rule I1 > I2 => I1 >Int I2 
  rule I1 >= I2 => I1 >=Int I2 
  rule V1 == V2 => V1 ==Bool V2 
  rule V1 != V2 => V1 =/=Bool V2 
  rule T1 and T2 => T1 andBool T2 
  rule T1 or T2 => T1 orBool T2 
  rule not(T) => notBool(T) 
  op closure : Map List{Id} Exp -> Val .
  rule <k> fun Xl -> E => closure(Env,Xl,E) _</k> <env> Env </env> 
  rule <k> closure(Env,Xl,E) Vl => [Vl] ~> bindTo(Xl) ~> E ~> env(Env') _</k> <env> Env' =>  Env </env> 
  rule <k> let Xl = El in E => [El] ~> bindTo(Xl) ~> E ~> env(Env) _</k> <env> Env </env> 
  rule <k> letrec Xl = El in E => bindTo(Xl) ~> [El] ~> writeTo(Xl) ~> E ~> env(Env) _</k> <env> Env </env> 
  op cc : Map K -> Val .
  rule <k> (callcc V => V cc(Env,K)) ~> K </k> <env> Env </env> 
  rule <k> cc(Env,K) V ~>  _  => V ~> K </k> <env>  _  => Env </env> 
  rule if true then E else  _  => E 
  rule if false then  _  else E => E 
  rule car [V,Vl] => V 
  rule cdr [V,Vl] => [Vl] 
  rule null? [.List{Id}] => true 
  rule null? [V,Vl] => false 
  rule cons V [Vl] => [V,Vl] 
  rule <k> ref V => L _</k> <store>_ .Map => L |-> V _</store> <nextLoc> L => sNat L </nextLoc> 
  rule <k> & X => L _</k> <env>_ X |-> L _</env> 
  rule <k> * L => V _</k> <store>_ L |-> V _</store> 
  rule <k> L := V => V  _</k> <store>_ L |-> ( _  => V) _</store> 
  rule V1 ; V2 => V2 

----------------------------------------------
--- Auxilliary declarations and operations ---
----------------------------------------------
--- List{Val}
  sort List{Val} .
  subsort Val < List{Val} < List{Exp} .
  op _`,_ : List{Val} List{Val} -> List{Val} [ditto] .
--- length
  op |_| : List{Id} -> Nat .  eq | .List{Id} | = 0 .  eq | X,Xl | = sNat(| Xl |) .
--- generate sequence of locations
  op _from_ : Nat Nat -> List{K} .  eq 0 from N1 = .List{K} .  eq sNat N2 from N1 = (N1,,(N2 from sNat N1)) .
--- environment recovery
  op env : Map -> K .
  rule (env( _ ) ~> env(Env) => env(Env)) [structural] 
  rule <k> env(Env) => .K _</k> <env>  _  => Env </env> [structural] 
  rule <k> V ~> (env(Env) => .K) _</k> <env>  _  => Env </env> [structural] 
--- bindTo and writeTo
  ops bindTo writeTo : List{Id} -> K .
  rule <k> [Vl] ~> bindTo(Xl) => .K _</k>
          <env> Env =>  Env[| Xl | from N / getList{K}(Xl)] </env>
          <store>_ .Map => | Xl | from N |-> getList{K}(Vl) _</store>
          <nextLoc> N => N +Nat | Xl | </nextLoc> 
  rule <k> bindTo(Xl) => .K _</k>
          <env> Env =>  Env[| Xl | from N / getList{K}(Xl)] </env>
          <nextLoc> N => N +Nat | Xl | </nextLoc> 
  rule <k> [Vl] ~> writeTo(Xl) => .K _</k>
          <env> Env </env>
          <store> Sigma => Sigma[getList{K}(Vl) / Env(getList{K}(Xl))] _</store> 

--- variable declarations; we put them last because we are going to infer them automatically in the future
  var I I1 I2 : Int .  var X : Id .  var E : Exp .  var V V1 V2 : Val .  var Xl : List{Id} .  var El : List{Exp} .  var Vl : List{Val} .
  var L N N1 N2 : Nat .  var T T1 T2 : Bool .  var Env Env' Sigma : Map .  var K : K .
endm


mod FUN-UNTYPED is including FUN-UNTYPED-SEMANTICS + FUN-PROGRAMS .
--- make sure the name of the final module is the capitalized version of the file name
  op run : KLabel -> Bag .
  eq run(L:KLabel) = run(L:KLabel,.List{K}) .
  op run : KLabel List{K} -> Bag .
  eq run(L:KLabel,L:List{K}) = <T> <k> L:KLabel(.List{K}) </k> <env> .Map </env> <store> .Map </store> <nextLoc> 0 </nextLoc> </T> .
endm
