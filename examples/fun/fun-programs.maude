mod FUN-PROGRAMS is including FUN-SYNTAX .
        op a :  -> Id .    op b :  -> Id .    op c :  -> Id .    op d :  -> Id .    op e :  -> Id .    op f :  -> Id .    op g :  -> Id .    op h :  -> Id .    op i :  -> Id .    op j :  -> Id .    op k :  -> Id . 
                 op l :  -> Id .    op m :  -> Id .    op n :  -> Id .    op o :  -> Id .    op p :  -> Id .    op q :  -> Id .    op r :  -> Id .    op s :  -> Id .    op t :  -> Id .    op u :  -> Id .    op v :  -> Id .    op w :  -> Id .    op x :  -> Id .    op y :  -> Id .    op z :  -> Id .
                 op factorial :  -> Id .    op max :  -> Id .    op map :  -> Id .    op return :  -> Id .    op throw :  -> Id .    op aux :  -> Id .    op continuation :  -> Id .    op value :  -> Id .    op exit :  -> Id .    op goto :  -> Id .    op cadr :  -> Id .
                 op f00 :  -> Id .    op f01 :  -> Id .    op f02 :  -> Id .    op f03 :  -> Id .    op f04 :  -> Id .    op f05 :  -> Id .    op f06 :  -> Id .    op f07 :  -> Id .    op f08 :  -> Id .    op f09 :  -> Id .    op f10 :  -> Id .    op f11 :  -> Id .    op f12 :  -> Id .    op f13 :  -> Id .    op f14 :  -> Id . 

        op p1 :  -> Exp .    op p2 :  -> Exp .    op p3 :  -> Exp .    op p4 :  -> Exp .    op p5 :  -> Exp .    op p6 :  -> Exp .    op p7 :  -> Exp .    op p8 :  -> Exp .    op p9 :  -> Exp .    op p10 :  -> Exp .    op p11 :  -> Exp .    op p12 :  -> Exp .    op p13 :  -> Exp .    op p14 :  -> Exp . 
                  op p15-1 :  -> Exp .    op p15-2 :  -> Exp .    op p16 :  -> Exp .    op p17 :  -> Exp .    op p18 :  -> Exp .    op p19 :  -> Exp .    op p20 :  -> Exp .    op p21 :  -> Exp .    op p22 :  -> Exp .    op p23 :  -> Exp .    op p24 :  -> Exp .    op p25 :  -> Exp . 
                  op p26-1 :  -> Exp .    op p26-2 :  -> Exp .    op p27-1 :  -> Exp .    op p27-2 :  -> Exp .    op p27-3 :  -> Exp .    op p28 :  -> Exp .    op p29 :  -> Exp .    op p30 :  -> Exp .    op p31 :  -> Exp . 


 
  eq p1 =  (
    letrec factorial x =  if x <= 0 then 1 else x *  factorial(x -  1)
    in factorial (factorial 4)
  ) .



    
  eq p2 =  (
    letrec max l = 
             if null? (cdr l)
             then car l
             else let x =  max (cdr l)
                  in if (x <=  car l)
                     then car l
                     else x
    in max [1, 3, 5, 2, 4, 0, -1, -5]
  ) .
 


       
  eq p3 =  (
    let cadr l =  (car (cdr l))
    in cadr [1, 3, 5, 2, 4, 0, -1, -5]
  ) .
 


       
  eq p4 =  (
    letrec cadr l =  (car (cdr l))
    in cadr [1, 3, 5, 2, 4, 0, -1, -5]
  ) .
 


          
  eq p4 =  (
    letrec cadr l x =  (car (cdr l))
    in cadr [1, 3, 5, 2, 4, 0, -1, -5] true
  ) .
 


   
  eq p6 =  (
    let (x,y,z) =  (1,2,3)
    in x +  y +  z
  ) .


      
  eq p21 =  (
    fun (x,y,z) ->  y
  ) .
  


     
  eq p7 =  (
    let f(x,y,z) =  x +  y +  z
    in f(1,2,3)
  ) .


  eq p8 =  (
    let f (a, b) (x, y)	=  a(x,y) +  b(x,y)
    in f (fun (x, y) ->  x *  y, fun (x, y) ->  x +  y) (1,2)
  ) .


          
      
      
             
  eq p5 =  (
    letrec
      max l x y
        =  if null? (cdr l)
          then car l
          else let x =  max(cdr l) x y
               in if (x <=  car l)
                  then car l
                  else x
    and
      factorial x
        =  if x <=  0
          then 1
          else x *  factorial(x -  1)
    in factorial (max [1, 3, factorial 4, 2, 5, 0, -1, -5] true 5)
  ) .



  eq p9 =  (
    letrec
      max l (x, y) = 
        if (*  x) !=  y
        then -1
        else if null? (cdr l)
             then (car l)
             else let x =  max (cdr l) ((x :=  (*  x) +  1 ;  x), y +  1)
                  in if (x <=  car l)
                     then (car l)
                     else x
    and
      map f l =  
        if null?  l
        then [] 
        else cons (f (car l)) (map f (cdr l))
    and
      factorial x = 
        if x <=  0
        then 1
        else x *  factorial(x -  1)
    in max (map factorial [1, 2, 3, 4, 5, factorial 5]) (ref 1, 1)
  ) .


    
  eq p10 =  (
    let f x y =  (x :=  (*  x) +  2 ;  y :=  (*  y) +  3)
    and x =  ref 0
    in (f x x ;  *  x)
  ) .
 


      
  eq p11 =  (
    let x =  1
    in letrec x =  2
       and    y =  x
       in y
  ) .


     
  eq p12 =  (
    let f x =  x +  x
    in let y =  ref 5
       in f (y :=  (*  y) +  3 ;  *  y)
  ) .


        
      
  eq p13 =  (
    let f =  let c =  ref 0
            in (
                 c :=  (*  c) +  100 ; 
                 fun x ->  (
                            c :=  (*  c) +  1000 ; 
                            x +  x +  (*  c)
                          )
               )
    in let y =  ref 0
       in f(y :=  (*  y) +  1 ;  *  y) +  f(0)
  ) .

      
  eq p14 =  (
    let f x =  x :=  * x +  1
    and x =  7
    in [x, (f(&  x) ;  x), (f(&  x) ;  x)]
  ) .

   
  eq p15-1 =  (
    let f ()  =  7
    in f
  ) .
  


   
  eq p15-2 =  (
    let x =  7
    in let f ()  =  x
       in f()
  ) .
 

  
  eq p16 =  (
    let f x =  x
    in f
  ) .
  


   
  eq p17 =  (
    let f x =  x
    in f 3
  ) .
 


  
  eq p18 =  (
    let f =  fun x ->  x
     in if (f true) then (f 2) else (f 3)
  ) .
 


  
  eq p19 =  (
    let f =  fun x ->  let y =  x in y
    in (fun x ->  f) 7
  ) .
 


           
                   
  eq p20 =  (
    let f =  let r =  ref [] 
            in fun x ->  (r :=  cons x (*  r) ;  x)
    in if f true then f 3 else f 4
  ) .


          
  eq p22 =  ( 
    let f00 =  fun x ->  fun y ->  x in
      let f01 =  fun x ->  f00 (f00 x) in
        let f02 =  fun x ->  f01 (f01 x) in
          let f03 =  fun x ->  f02 (f02 x) in
            let f04 =  fun x ->  f03 (f03 x) in
              let f05 =  fun x ->  f04 (f04 x) in
                let f06 =  fun x ->  f05 (f05 x) in
                  let f07 =  fun x ->  f06 (f06 x) in
                    let f08 =  fun x ->  f07 (f07 x) in
                       f08
  ) .


  
  eq p23 =  (
    callcc (fun k ->  7)
  ) .
 


  
  eq p24 =  (
    callcc (fun k ->  k 7)
  ) .
 


  
  eq p25 =  (
    callcc (fun k ->  k 7 +  3)
  ) .



  
  eq p30 =  (
    (callcc (fun k ->  7)) +  3
  ) .
 

  
  eq p31 =  (
    (callcc (fun k ->  k 7 +  5)) +  3
  ) .
 


       
  eq p26-1 =  (
    let f l return =  (
          if null? (l)
          then return 0
          else return 1 ; 
          0 /  0
        )
    in callcc (f [] )
  ) .


       
  eq p26-2 =  (
    let f l =  callcc (fun return ->  (
          if null? (l)
          then return 0
          else return 1 ; 
          0 /  0
        ) )
    in f [1,2]
  ) .


        
          
  eq p27-1 =  (
    letrec f l = 
             if null? (l)
             then 1
             else if (car l) ==  0
                  then 0
                  else (car l) *  f(cdr l)
    in f [1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9]
  ) .


    
    
  eq p27-2 =  (
    let f l =  callcc (fun throw ->  (
                letrec aux l = 
                         if null? (l)
                         then 1
                         else if (car l) ==  0
                              then throw 0
                              else (car l) *  aux(cdr l)
                in aux l
              ) )
    in f [1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9]
  ) .


      
        op try_catch(_)_ :  Exp  Id  Exp -> Exp . 
            
  eq try E catch(X:Id) E':Exp
      =  callcc (fun continuation ->  (fun throw ->  E:Exp)(fun value ->  continuation ((fun X ->  E') value))) .
        
  eq p27-3 =  (
    let f l =  try
                letrec aux l = 
                         if null? (l)
                         then 1
                         else if (car l) ==  0
                              then throw 0
                              else (car l) *  aux(cdr l)
                in aux l
              catch(x)
                x
    in f [1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9]
  ) .


    
  eq p29 =  (
   let goto =  0 and n =  0
   in callcc (fun exit ->  (
        callcc (fun k ->  (&  goto :=  k)) ;         
        if n <  100
        then &  n :=  n +  1
        else exit n ; 
        goto 0
      ) )
  ) .

var E' : Exp . var X : Id . var E : Exp .  endm
