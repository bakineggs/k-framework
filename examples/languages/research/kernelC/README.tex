% Type the command ``make pdf'' to generate the PDF poster of this language.
% Alternatively, type in the equivalent command
% kompile kernelc.k -l KERNELC -style bb -pdf KERNELC-SYNTAX KERNELC-THREADS-SYNTAX KERNELC-DESUGARED-SYNTAX KERNELC-SEMANTICS  KERNELC-SIMPLE-MALLOC  KERNELC-CONSISTENT-MEMORY KERNELC-CONSISTENT-THREADS KERNELC -topmatter README.tex

% The generated simple-untyped.pdf file is easier to read than the actual ASCII files.
\newcommand{\KERNELC}{{\sc KernelC}\xspace}
\setlength{\parindent}{1em}
\title{\KERNELC --- a C-like language}
\author{Traian Florin \c{S}erb\u{a}nu\c{t}\u{a} and Grigore Ro\c{s}u}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{latexComment}
\section{Abstract}
\KERNELC defines a nontrivial subset of the C language, which is used to exemplify several runtime analysis capabilities of \K definitions, as well as concurrency power and easiness in defining and exploring relaxed memory models.  
{\sc KernelC} allows writing C programs with addition and subtraction, increment, assignment, basic comparison operators and logical connectives, ternary if, basic input/output and random library functions, expression statements, statement composition and blocks, conditional, while loop, function declaration and invocations, variable declarations, memory allocation, freeing, and dereferencing (including array dereferencing).  
We additionally allow {\tt \#include} directives, which make our programs fully specified by including the standard library headers, and thus compilable and executable with a C compiler.
It is expressive enough to be able to write C functions as the one below (which can be used for copying zero-terminated arrays):
\[\begin{array}{l}
\terminal{void}
{
  {\terminal{arrCpy}
  }
  (\terminal{int}{
    \ast\terminal{a}
    }, \terminal{int}{
     \ast\terminal{b}
     }
     ) }
     \terminal{\{} \\
     \ \ \terminal{while}   (
     {  
       {\ast\terminal{a}}
       \terminal{++}
     }\terminal{=}
     {
     {\ast\terminal{b}}
     \terminal{++}
     }
     )\terminal{\{\}} 
   \\ \terminal{\}}
   \end{array}\]
   
Without modifying anything but the configuration, the language is then extended with the following concurrency constructs:  thread creation, lock-based synchronization and thread join.

\subsection{Restrictions}
To keep things simple, we only allow int and void as a basic types.  Moreover, we only allow the reference operator for the {\tt scanf} function, which basically means that one cannot get the address for local variables (for heap allocated variables the address is returned automatically by the allocation function).  Also, to avoid dealing with control, as it is not particularly relevant in the context of runtime verification, we only allow return statements at the end of a function body.

\subsection{Research based on \KERNELC}
\KERNELC originated in the study of memory safety for C and first presented in the following paper:
\begin{quote}
Grigore Ro\c su, Wolfram Schulte, and Traian-Florin \c Serb\u anu\c t\u a:
\href{http://dx.doi.org/10.1007/978-3-642-04694-0_10}{Runtime Verification of C Memory Safety}.

Runtime Verification (RV'09), Lecture Notes in Computer Science 5779: 132--151. 2009
\end{quote}

Since then it has been expanded and used for expressing and verifing concurrency features and anomalies for both sequentially-consistent and relaxed memory models, as detailed in Chapter 5 of:

\begin{quote}
  Traian-Florin \c Serb\u anu\c t\u a: \href{https://www.ideals.illinois.edu/handle/2142/18252}{A Rewriting Approach to Concurrent Programming Language Design and Semantics}

  PhD Thesis, University of Illinois, December 2010
\end{quote}


The verification ideas prototyped in \KERNELC were succesfully applied to the full \K definition of the C language.
\begin{quote}
  Chucky Ellison and Grigore Ro\c su: \href{http://c-semantics.googlecode.com}{The C-semantics project --- Semantics of C in the \K Framework}
\end{quote}

\end{latexComment}

\vspace*{3ex}
