% Type the command ``make pdf'' to generate the PDF poster of this language.
% Alternatively, type in the equivalent command
% kompile.pl simple-untyped.k -l SIMPLE-UNTYPED -style bb -pdf SIMPLE-UNTYPED-SYNTAX SIMPLE-UNTYPED-DESUGARED-SYNTAX SIMPLE-UNTYPED-SEMANTICS SIMPLE-UNTYPED -topmatter README.tex
% The generated simple-untyped.pdf file is easier to read than the actual ASCII files.

\setlength{\parindent}{1em}
\title{SIMPLE --- Untyped}
\author{Grigore Ro\c{s}u and Traian Florin \c{S}erb\u{a}nu\c{t}\u{a}}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{latexComment}
\section{Abstract}
This is the \K semantic definition of the untyped SIMPLE language.
SIMPLE is intended to be a pedagogical language that captures the
essence of the imperative programming paradigm, extended with several
features often encountered in imperative programming languages.
A program consists of a set of global variable declarations and
function definitions.  Like in C, function definitions cannot be
nested and each program must have one function called \texttt{main},
which is invoked when the program is executed.  To make it more
interesting and to highlight some of \K's strengths, SIMPLE includes
the following features in addition to the conventional imperative
expression and statement constructs:
\begin{itemize}
\item Multidimensional arrays and array references.  An array evaluates
to an array reference, which is a special value holding a location where
the elements of the array start together with the size of the array;
the elements of the array can be array references themselves when the
array is multi-dimensional.  Array references are ordinary values, so
they can be assigned to variables and passed/received by functions.
\item Functions and function references.  Functions can have zero or
more parameters and can return abruptly using a \texttt{return} statement.
SIMPLE is call-by-value with static scoping.  Function names evaluate to
function references, which hereby become ordinary values in the language,
same like the array references.
\item Blocks with locals.  SIMPLE allows variables to be declared
anywhere, their scope being the most nested block containing them.
\item Input/Output.  The expression \texttt{read()} evaluates to the
next value in the input buffer, and the statement \texttt{write(e)}
evaluates \texttt{e} and outputs its value to the output buffer.  The
input and output buffers are lists of values.
\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as
an exception can be caught and bound).
\item Concurrency via dynamic thread creation/termination and
synchronization.  One can spawn a thread to execute any statement.
The spawned thread shares with its parent its environment at creation time.
Threads can be synchronized via reentrant locks which can be acquired and
released, as well as through rendezvous.

\end{itemize}
Like in many other languages, some of SIMPLE's constructs can be
desugared into a smaller set of basic constructs.  We do that in a 
dedicated module between the syntax and the semantics, and we only
give semantics to the core constructs.

\paragraph{Note:}{
This \K semantic definition of SIMPLE below is more commented than most
of our other \K definitions, because it is intended to be the first
non-trivial \K definition that the new user of the \K framework sees, and
because it actually can serve as a quick introduction to \K.  The reader
interested in reading more about \K is referred to
\begin{quote}
Grigore Ro\c su, Traian-Florin \c Serb\u anu\c t\u a:
\href{http://dx.doi.org/10.1016/j.jlap.2010.03.012}{An overview of the K semantic framework}.

Journal of Logic and Algebraic Programming, 79(6): 397-434 (2010)
\end{quote}
}
\end{latexComment}

\vspace*{3ex}
