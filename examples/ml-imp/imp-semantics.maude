load imp-syntax.maude

mod UTILS is including PL-INT .
  op isInt : Int -> Bool .
  var I : Int .
---  eq isInt(I) = I :: Int .
endm

mod IMP-SEMANTICS is including IMP-DESUGARED-SYNTAX + UTILS .
---  subsort List{Val} <  KResult . 
---  subsort Stmts List{Exp} < K .
  subsort Val <  KResult .
  subsort Stmts Exp < K .

  vars N N1 N2 L : Nat .
  vars I I' I1 I2 : Int++ .
  var NzI : NzInt .
  vars F X : Id .
  ---var Xl : List{Id} .
  var V V1 V2 : Val .
  ---var Vl : List{Val} .
  var E E1 E2 : Exp .
  var S S1 S2 : Stmt .
  var Ss : Stmts .
  var K : K .
  var Phi : Formula .
  var CfgItems : Bag .


  ops feasible infeasible : -> CellLabel .
  ops config k env heap form subst newSym newImpl : -> CellLabel .

  mb configuration < T > 
                  < feasible > 0 </ feasible >
                  < infeasible > 0 </ infeasible >
                  < config >
                    < k > (.).K </ k >
                    < env > (.).Map </ env >
                    < heap > (.).Map </ heap >
                    < form > TrueFormula </ form >
                    < subst > (.).K </ subst >
                    < newSym > 0 </ newSym >
                    < newImpl > 0 </ newImpl >
                  </ config >
                </ T > : KSentence .


  mb rule I1 + I2 => I1 +Int I2 : KSentence .
  mb rule _-_(I1, I2) => _-Int_(I1, I2) : KSentence .
  mb rule _*_(I1, I2) => I1 *Int I2 : KSentence .
  mb rule I1 / I2 => I1 /Int I2 : KSentence .
  mb rule I1 % I2 => I1 %Int I2 : KSentence .
  mb rule - I => -Int I : KSentence .
  mb rule I1 >= I2 => ?_(I1 >=Int I2) : KSentence .
  mb rule I1 > I2 => ?_(I1 >Int I2) : KSentence .
  mb rule I1 <= I2 => ?_(I1 <=Int I2) : KSentence .
  mb rule I1 < I2 => ?_(I1 <Int I2) : KSentence .
  mb rule I1 == I2 => ?_(I1 ==Int I2) : KSentence .

---  rule I && E => (I ? 1 : 0) && E if notBool(isInt(I))
  mb rule NzI && E => E : KSentence .
  mb rule 0 && E => 0 : KSentence .
---  rule I || E => (I ? 1 : 0) || E if notBool(I :: Int)
  mb rule NzI || E => NzI : KSentence .
  mb rule 0 || E => E : KSentence .
---  rule ! I => I ? 0 : 1 if notBool(I :: Int)
  mb rule ! NzI => 1 : KSentence .
  mb rule ! 0 => 1 : KSentence .

  mb rule
    < config >
      < k > (I ? E1 : E2) ~> K </ k >
      CfgItems
    </ config >
  =>
    < config >
      < k > E1 ~> K </ k >
      CfgItems
    </ config >
    < config >
      < k > E2 ~> K </ k >
      CfgItems
    </ config > : KSentence .
  mb rule NzI ? E1 : E2 => E1 : KSentence .
  mb rule 0 ? E1 : E2 => E2 : KSentence .

  mb rule V ; => (.).K : KSentence .
  mb rule {} => (.).K : KSentence .
  mb rule {Ss} => Ss : KSentence .
  mb rule S1 S2 => S1 ~> S2 : KSentence .

  mb rule
    < k > X => V  ...</ k > 
    < env >...  X |-> V  ...</ env > : KSentence .
  mb rule
    < k > X = V ; => (.).K  ...</ k >
    < env >...  X |-> ( ?  => V)  ...</ env > : KSentence .

---
---  mb rule
---    < k > [* I => V] </ k >
---    < heap > </ heap >
---  : KSentence .
---  mb context * [HOLE] = ? ; : KSentence .
---  mb rule
---    < k > [* I = V ; => .K] </ k >
---    < heap > </ heap >
---  : KSentence .
---

---  rule if (I) S1 else S2 => if (I ? 1 : 0) S1 else S2 if notBool(I :: Int)
  mb rule if (NzI) S else  ?  => S : KSentence .
  mb rule if (0)  ?  else S => S : KSentence .
ops form feasible newImpl newSym k subst heap infeasible env T config : -> CellLabel .  endm

