in match-imp

mod TEST is inc IMP .
  ops !E !E1 !E2 : -> !Env .
  ops !H !H1 !H2 : -> !Heap .
  op H : -> FreeHeap .
  ops a b c d e f g h i j k l m n o p q r s t u v x y z w src dest root temp change : -> PVar .
  ops ?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n ?o ?p ?q ?r ?s ?t ?u ?v ?x ?y ?z ?w : -> ?Int .
  ops ?temp ?change : -> ?Int .
  ops !a !b !c !d !e !f !g !h !i !j !k !l !m !n !o !p !q !r !s !t !u !v !x !y !z !w : -> !Int .
  ops a0 b0 c0 d0 e0 f0 g0 h0 i0 j0 k0 l0 m0 n0 o0 p0 q0 r0 s0 t0 u0 v0 x0 y0 z0 w0 : -> FreeInt .
  ops src0 dest0 root0 : -> FreeInt .
  ops ?A ?B ?A' ?B' ?C ?L ?X : -> ?IntSeq .
  ops A B L : -> FreeIntSeq .
  ops ?T ?TL ?TR : -> ?IntTree .
  ops !T !TL !TR : -> !IntTree .
  op T : -> FreeIntTree .
  op ?TS : -> ?IntTreeSeq .


  op pSum : -> K .
  eq pSum = (
        assume <config> <env> n |-> n0 </env>
                        <heap> .Heap </heap> <form> @(n0 >=Int 0) </form> </config> ;
        s = 0 ;
        invariant <config> <env> n |-> ?n ;; s |-> (((n0 +Int (-Int ?n)) *Int (n0 +Int ?n +Int 1)) /Int 2) </env>
                          <heap> .Heap </heap> <form> @(?n >=Int 0) /\ @(n0 >=Int 0) </form> </config> ;
        while (n > 0) {
            s = s + n ;
            n = n - 1 ;
        }
        assert <config> <env> n |-> 0 ;; s |-> ((n0 *Int (n0 +Int 1)) /Int 2) </env>
                       <heap> .Heap </heap> <form> @(n0 >=Int 0) </form> </config> ;
  ) .

 
  op pListReverse : -> K .
  eq pListReverse = (
    assume <config> <env> x |-> ?x </env>
                    <heap> list(?x)(A) </heap> <form> TrueFormula </form> </config> ;
    p = 0 ;
    invariant <config> <env> p |-> ?p ;; x |-> ?x </env>
                       <heap> list(?p)(?B) ** list(?x)(?C) </heap>
                       <form> rev(A) === rev(?C) :: ?B </form> </config> ;
    while(x != 0) {
      y = *(x + 1) ;
      *(x + 1) = p ;
      p = x ;
      x = y ;
    }
    assert <config> <env> p |-> ?p </env>
                    <heap> list(?p)(rev(A)) </heap> <form> TrueFormula </form> </config> ;
  ) .


op pListAppendNotNull : -> K .
eq pListAppendNotNull = (
    assume <config> <env> a |-> a0 ;; b |-> b0 </env>
                    <heap> list(a0)(A) ** list(b0)(B) ** H </heap>
                    <form> ~(a0 === 0) </form> </config> ;
    x = a ;
    invariant <config> <env> a |-> a0 ;; x |-> ?x ;; !E </env>
                       <heap> lseg(a0,?x)(?A) ** list(?x)(?X) ** !H </heap>
                       <form> ?A :: ?X === A /\ ~(?x === 0) </form> </config> ;
    while (* (x + 1) != 0) {
        x = *(x + 1) ;
    }
    *(x + 1) = b ;
    assert <config> <env> a |-> a0 </env>
                    <heap> list(a0)(A :: B) ** H </heap> <form> ~(a0 === 0) </form> </config> ;
) .


op pListAppend : -> K .
eq pListAppend = (
    assume <config> <env> a |-> a0 ;; b |-> b0 </env>
                    <heap> list(a0)(A) ** list(b0)(B) </heap>
                    <form> TrueFormula </form> </config> ;
    if (a != 0) {
        x = a ;
        invariant <config> <env> a |-> a0 ;; x |-> ?x ;; !E </env>
                           <heap> lseg(a0,?x)(?A) ** list(?x)(?X) ** !H </heap>
                           <form> ?A :: ?X === A /\ ~(?x === 0) </form> </config> ;
        while (* (x + 1) != 0) {
            x = *(x + 1) ;
        }
        *(x + 1) = b ;
    }
    else {
        a = b ;
    }
    assert <config> <env> a |-> ?a </env>
                    <heap> list(?a)(A :: B) </heap>
                   <form> (~(a0 === 0) /\ (?a === a0)) \/
                          ((a0 === 0) /\ (?a === b0)) </form> </config> ;
  ) .


  op pListLength : -> K .
  eq pListLength = (
    assume <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                    <heap> list(a0)(A) </heap> <form> TrueFormula </form> </config> ;
    x = a ;
    l = 0 ;
    invariant <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                       <heap> lseg(a0,?x)(?A) ** list(?x)(?X) </heap>
                       <form> ?A :: ?X === A /\ ?l === len(?A) </form> </config> ;
    while (x != 0) {
        x = *(x + 1) ;
        l = l + 1 ;
    }
    assert <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                    <heap> list(a0)(A) </heap> <form> ?l === len(A) </form> </config> ;
  ) .


  op pDListLength : -> K .
  eq pDListLength = (
    assume <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                    <heap> dlseg(a0,b0)(0,0,A) </heap> <form> TrueFormula </form> </config> ;
    x = a ;
    l = 0 ;
    invariant <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                       <heap> dlseg(a0,?y)(?x,0,?A) ** dlseg(?x,b0)(0,?y,?X) </heap>
                       <form> ?A :: ?X === A /\ ?l === len(?A) </form> </config> ;
    while (x != 0) {
        x = *(x + 1) ;
        l = l + 1 ;
    }
    assert <config> <env> a |-> a0 ;; x |-> ?x ;; l |-> ?l </env>
                    <heap> dlseg(a0,b0)(0,0,A) </heap> <form> ?l === len(A) </form> </config> ;
  ) .


  op pEnqueue : -> K .
  eq pEnqueue = (
    assume <config> <env> q |-> q0 ;; n |-> ?n </env>
                    <heap> queue(q0)(A) ** ?n |-> e0 : node ** (?n +Int 1) |-> ?x : next </heap> <form> ~(q0 === 0) </form> </config> ;
    if (q != 0) {
        if (* q != 0) {
            *(*(q + 1) + 1) = n ;
        }
        else {
            * q = n ;
        }
        *(q + 1) = n ;
    }
    assert <config> <env> q |-> q0 ;; n |-> ?n </env>
                    <heap> queue(q0)(A :: e0) </heap> <form> ~(q0 === 0) </form> </config> ;
  ) .


  op pDequeue : -> K .
  eq pDequeue = (
    assume <config> <env> q |-> q0 ;; r |-> ?r </env>
                    <heap> queue(q0)(A) </heap> <form> TrueFormula </form> </config> ;
    r = 0 ;
    if (q != 0) {
        if (* q != 0) {
            r = * q ;
            if (* q == *(q + 1)) {
                * q = 0 ;
                *(q + 1) = 0 ;
                --- little extra help to unfold the queue heap pattern
                derive(?Int(1)) ;
            }
            else {
                * q = *(r + 1) ;
            }
        }
    }
    assert <config> <env> q |-> q0 ;; r |-> ?r </env>
                    <heap> ?r |-> ?e : node ** (?r +Int 1) |-> ?x : next ** queue(q0)(?A) </heap> <form> (A === ?e :: ?A) </form> </config>
           <config> <env> q |-> q0 ;; r |-> ?r </env>
                    <heap> queue(q0)(A) </heap> <form> (?r === 0) /\ (A === epsilon) </form> </config> ;
  ) .


  op pQueueTransferOwner : -> K .
  eq pQueueTransferOwner = (
    assume <config> <env> dest |-> dest0 ;; src |-> src0 ;; n |-> ?n </env>
                    <heap> queue(dest0)(A) ** queue(src0)(B) </heap> <form> TrueFormula </form> </config> ;
    if (src != 0) {
        if (dest != 0) {
            if (* src != 0) {
                n = * src ;
                if (* src == *(src + 1)) {
                    * src = 0 ;
                    *(src + 1) = 0 ;
                    --- little extra help to unfold the queue heap pattern
                    derive(?Int(1)) ;
                }
                else {
                    * src = *(n + 1) ;
                }

                if (* dest != 0) {
                    *(*(dest + 1) + 1) = n ;
                }
                else {
                    * dest = n ;
                }
                *(dest + 1) = n ;
            }
        }
    }
    assert <config> <env> dest |-> dest0 ;; src |-> src0 ;; n |-> ?n </env>
                    <heap> queue(dest0)(A :: ?e) ** queue(src0)(?B) </heap> <form> (B === ?e :: ?B) </form> </config>
           <config> <env> dest |-> dest0 ;; src |-> src0 ;; n |-> ?n </env>
                    <heap> queue(dest0)(A) ** queue(src0)(B) </heap> <form> (dest0 === 0) \/ (src0 === 0) \/ (B === epsilon) </form> </config> ;
  ) .


  op pStealQueue : -> K .
  eq pStealQueue = (
    assume <config> <env> dest |-> dest0 ;; src |-> src0 </env>
           <heap> queue(dest0)(A) ** queue(src0)(B) </heap> <form> TrueFormula </form> </config> ;
    if (src != 0) {
        if (dest != 0) {
            if (* src != 0) {
                if (* dest != 0) {
                    *(*(dest + 1) + 1) = * src ;
                } else {
                    * dest = * src ;
                }
                *(dest + 1) = *(src + 1) ;
            }
            free(src) ;
        }
    }
    assert <config> <env> dest |-> dest0 ;; src |-> src0 </env>
                    <heap> queue(dest0)(A :: B) </heap> <form> TrueFormula </form> </config>
           <config> <env> dest |-> dest0 ;; src |-> src0 </env>
                    <heap> queue(dest0)(A) ** queue(src0)(B) </heap> <form> (dest0 === 0) \/ (src0 === 0) </form> </config> ;
  ) .


  op pTreeMirror : -> K .
  eq pTreeMirror = (
    assume <config> <env> root |-> root0 ;; x |-> ?x </env>
                    <heap> tree(root0)(T) </heap> <form> TrueFormula </form> </config> ;
    if (root != 0) {
        --- swap the left and right subtrees
        x = *(root + 1) ;
        *(root + 1) = *(root + 2) ;
        *(root + 2) = x ;
        --- mirror(*(root + 1))
        x = *(root + 1) ;
        assert <config> <env> x |-> !l ;; !E </env>
                        <heap> tree(!l)(!TR) ** !H1 </heap>
                        <form> TrueFormula </form> </config> ;
        assume <config> <env> x |-> !l ;; !E </env>
                        <heap> tree(!l)(mirror(!TR)) ** !H1 </heap>
                        <form> TrueFormula </form> </config> ;
        --- mirror(*(root + 2))
        x = *(root + 2) ;
        assert <config> <env> x |-> !r ;; !E </env>
                        <heap> tree(!r)(!TL) ** !H2 </heap>
                        <form> TrueFormula </form> </config> ;
        assume <config> <env> x |-> !r ;; !E </env>
                        <heap> tree(!r)(mirror(!TL)) ** !H2 </heap>
                        <form> TrueFormula </form> </config> ;
    }
    assert <config> <env> root |-> root0 ;; x |-> ?x </env>
                    <heap> tree(root0)(mirror(T)) </heap> <form> TrueFormula </form> </config> ;
  ) .


  op pTreeToList : -> K .
  eq pTreeToList = (
    assume <config> <env> root |-> root0 ;; x |-> ?x ;; n |-> ?n </env>
                    <heap> tree(root0)(T) ** list(?x)(A) </heap> <form> TrueFormula </form> </config> ;
    if (root != 0) {
        n = alloc(node,next) ;
        * n = * root ;
        --- x = treeToList(root->right, x);
        assert <config> <env> root |-> root0 ;; x |-> ?x ;; !E1 </env>
                        <heap> root0 |-> !v : node ** (root0 +Int 1) |-> !l : left ** (root0 +Int 2) |-> !r : right
                            ** tree(!r)(!TR) ** list(?x)(A) ** !H1 </heap>
                        <form> TrueFormula </form> </config> ;
        assume <config> <env> root |-> root0 ;; x |-> ?x ;; !E1 </env>
                        <heap> root0 |-> !v : node ** (root0 +Int 1) |-> !l : left ** (root0 +Int 2) |-> !r : right
                            ** list(?x)(tree2list(!TR) :: A) ** !H1 </heap>
                        <form> TrueFormula </form> </config> ;
        *(n + 1) = x ;
        x = n ;
        --- x = treeToList(t -> left, x)
        assert <config> <env> root |-> root0 ;; x |-> ?x ;; !E2 </env>
                        <heap> root0 |-> !v : node ** (root0 +Int 1) |-> !l : left ** (root0 +Int 2) |-> !r : right
                            ** tree(!l)(!TL) ** list(?x)(!v :: tree2list(!TR) :: A) </heap>
                        <form> TrueFormula </form> </config> ;
        watch ;
        assume <config> <env> root |-> root0 ;; x |-> ?x ;; !E2 </env>
                        <heap> root0 |-> !v : node ** (root0 +Int 1) |-> !l : left ** (root0 +Int 2) |-> !r : right
                            ** list(?x)(tree2list(!TL) :: !v :: tree2list(!TR) :: A) </heap>
                        <form> TrueFormula </form> </config> ;
        free(root) ;
    }
    assert <config> <env> root |-> root0 ;; x |-> ?x ;; n |-> ?n </env>
                    <heap> list(?x)(tree2list(T) :: A) </heap> <form> TrueFormula </form> </config> ;
  ) .


  op pTreeToListWhile : -> K .
  eq pTreeToListWhile = (
    assume <config> <env> root |-> root0 ;; a |-> ?a ;; s |-> ?s ;; t |-> ?t ;; l |-> ?l ;; r |-> ?r ;; x |-> ?x ;; n |-> ?n </env>
                    <heap> tree(root0)(T) </heap> <form> TrueFormula </form> </config> ;
    a = 0 ;
    s = 0 ;
    if (root != 0) {
        s = alloc(node, next) ;
        * s = root ;
        *(s + 1) = 0 ;
        invariant <config> <env> root |-> root0 ;; a |-> ?a ;; s |-> ?s ;; t |-> ?t ;; l |-> ?l ;; r |-> ?r ;; x |-> ?x ;; n |-> ?n </env>
                           <heap> tree-list(?s)(?TS) ** list(?a)(?A) </heap>
                           <form> tree2list(T) === tree-list2list(rev'(?TS)) :: ?A </form> </config> ;
        while (s != 0) {
            x = s ;
            s = *(s + 1) ;
            t = * x ;
            free(x) ;

            l = *(t + 1) ;
            r = *(t + 2) ;
            *(t + 1) = 0 ;
            *(t + 2) = 0 ;
            
            if (l != NULL) {
                x = alloc(node, next) ;
                * x = l ;
                *(x + 1) = s ;
                s = x ;
            }

            if (r != NULL) {
                x = alloc(node, next) ;
                * x = t ;
                *(x + 1) = s ;
                s = x ;
                x = alloc(node, next) ;
                * x = r ;
                *(x + 1) = s ;
                s = x ;
            } else {
                n = alloc(node, next) ;
                * n = * t ;
                free(t) ;
                *(n + 1) = a ;
                a = n ;
            }
        }
    }
    assume <config> <env> root |-> root0 ;; a |-> ?a ;; s |-> 0 ;; t |-> ?t ;; l |-> ?l ;; r |-> ?r ;; x |-> ?x ;; n |-> ?n </env>
                    <heap> list(?a)(tree2list(T)) </heap> <form> TrueFormula </form> </config> ;
  ) .


  op pArrayAccess : -> K .
  eq pArrayAccess = (
    assume <config> <env> a |-> a0 ;; n |-> n0 ;; i |-> i0 ;; x |-> x0 </env>
                    <heap> array(a0,0,n0)(A) </heap> <form> ~(a0 === 0) /\ @(i0 >=Int 0) /\ @(n0 >Int i0) </form> </config> ;
    * (a + i) = x ;
    assert <config> <env> a |-> a0 ;; n |-> n0 ;; i |-> i0 ;; x |-> x0 </env>
                    <heap> array(a0,0,n0)(?A :: x0 :: ?B) </heap> <form> ~(a0 === 0) </form> </config> ;
  ) .


  op pListMergeSort : -> K .
  eq pListMergeSort = (
    assume <config> <env> l |-> l0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(l0)(L) </heap> <form> TrueFormula </form> </config> ;
    if (l != NULL && *(l + 1)) {
        --- split the list in two
        a = NULL ;
        b = NULL ;
        *(*(l + 1)) = *(*(l + 1)) ;
        invariant <config> <env> l |-> l0 ;; a |-> 0 ;; b |-> 0 ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> l0 |-> ?v : node ** (l0 +Int 1) |-> ?n : next ** ?n |-> ?u : node ** (?n +Int 1) |-> ?l : next ** list(?l)(?L) </heap>
---                            <form> ~(l0 === 0) /\ L === ?v :: ?u :: ?L </form> </config>
---                         little extra help, assert ~(?n === 0)
                           <form> ~(l0 === 0) /\ ~(?n === 0) /\ L === ?v :: ?u :: ?L </form> </config>
                  <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> list(?a)(?A) ** list(?b)(?B) ** list(?l)(?L) </heap>
                           <form> list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?L) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        while (l != NULL) {
            e = l ;
            l = * (e + 1)
            * (e + 1) = a ;
            a = e ;
            if (l != NULL) {
                e = l ;
                l = * (e + 1)
                * (e + 1) = b ;
                b = e ;
            }
            
        }

        --- sort the first half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?a)(?A) ** list(?b)(?B) </heap>
                    <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;

        --- sort the second half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B') </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') /\ list2bag(?B) === list2bag(?B') /\ isSorted(?B') </form> </config> ;

        --- merge the two halves
        h = 0 ;
        t = 0 ;
        --- little extra help to unfold the queue heap pattern
        * a = * a ;
        * b = * b ;
        invariant <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> queue(?h,?t)(?C) ** list(?a)(?A) ** list(?b)(?B) </heap>
                           <form> ((~(?a === 0) /\ ~(?b === 0)) \/ (~(?h === 0) /\ ~(?t === 0)))
                               /\ list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?C)
                               /\ @(min(list2bag(?A)) >=Int max(list2bag(?C))) /\ @(min(list2bag(?B)) >=Int max(list2bag(?C)))
                               /\ isSorted(?A) /\ isSorted(?B) /\ isSorted(?C) </form> </config> ;
        while (a != 0 && b != 0) {
            if (* b > * a) {
                e = a ;
                a = *(a + 1) ;
            }
            else {
                e = b ;
                b = *(b + 1) ;
            }

            if (h != 0) {
                *(t + 1) = e ;
            }
            else {
                h = e ;
            }
            t = e ;
        }

        if (a != 0) {
            *(t + 1) = a ;
        }
        else {
            *(t + 1) = b ;
        }

        l = h ;
    }
    assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?l)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;
  ) .


  op pListLengthMergeSort : -> K .
  eq pListLengthMergeSort = (
    assume <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?h)(L) </heap> <form> n0 === len(L) </form> </config> ;
    if (n > 1) {
        --- split the list in two
        x = h ;
        i = 0 ;
        invariant <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> lseg(?h,?x)(?A) ** list(?x)(?B) </heap>
                           <form> n0 === len(L) /\ @(n0 >Int 1) /\ L === ?A :: ?B /\ ?i === len(?A) /\ @(?i >=Int 0) /\ @(n0 >Int ?i +Int ?i) </form> </config> ;
        while (n - 2 > i + i) {
            x = *(x + 1) ;
            i = i + 1 ;
        }
        t = x ;
        x = *(t + 1) ;
        *(t + 1) = 0 ;

        --- sort the first half
        assert <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?h)(?A) ** list(?x)(?B) </heap> <form> n0 === len(L) /\ @(n0 >Int 1) /\ L === ?A :: ?B /\ ?i +Int 1 === len(?A) </form> </config> ;
        assume <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?x)(?B) </heap> <form> n0 === len(L) /\ @(n0 >Int 1) /\ L === ?A :: ?B /\ ?i +Int 1 === len(?A)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;

        --- sort the second half
        assert <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?x)(?B) </heap>
                        <form> n0 === len(L) /\ @(n0 >Int 1) /\ L === ?A :: ?B /\ ?i +Int 1 === len(?A) /\ n0 +Int (-Int (?i +Int 1)) === len(?B)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;

        assume <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B') </heap>
                        <form> n0 === len(L) /\ @(n0 >Int 1) /\ L === ?A :: ?B /\ ?i +Int 1 === len(?A) /\ n0 +Int (-Int (?i +Int 1)) === len(?B)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') /\ list2bag(?B) === list2bag(?B') /\ isSorted(?B') </form> </config> ;

        --- merge the two halves
        h = 0 ;
        t = 0 ;
        --- little extra help to unfold the queue heap pattern
        * a = * a ;
        * b = * b ;
        invariant <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> queue(?h,?t)(?C) ** list(?a)(?A) ** list(?b)(?B) </heap>
                           <form> ((~(?a === 0) /\ ~(?b === 0)) \/ (~(?h === 0) /\ ~(?t === 0)))
                               /\ list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?C)
                               /\ @(min(list2bag(?A)) >=Int max(list2bag(?C))) /\ @(min(list2bag(?B)) >=Int max(list2bag(?C)))
                               /\ isSorted(?A) /\ isSorted(?B) /\ isSorted(?C) </form> </config> ;
        while (a != 0 && b != 0) {
            if (* b > * a) {
                e = a ;
                a = *(a + 1) ;
            }
            else {
                e = b ;
                b = *(b + 1) ;
            }

            if (h != 0) {
                *(t + 1) = e ;
            }
            else {
                h = e ;
            }
            t = e ;
        }

        if (a != 0) {
            *(t + 1) = a ;
        }
        else {
            *(t + 1) = b ;
        }
    }
    assert <config> <env> x |-> ?x ;; i |-> ?i ;; n |-> n0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?h)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;
  ) .


  op pListQuickSort : -> K .
  eq pListQuickSort = (
    assume <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                    <heap> list(?l)(L) </heap> <form> TrueFormula </form> </config> ;
    if (l != 0) {
        p = l ;
        x = *(l + 1) ;
        *(p + 1) = 0 ;
        a = 0 ;
        b = 0 ;
        invariant <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                           <heap> ?p |-> ?v : node ** (?p +Int 1) |-> 0 : next ** list(?a)(?A) ** list(?b)(?B) ** list(?x)(?C) </heap>
                           <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) &' list2bag(?C)
                               /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) </form> </config> ;
        while(x != 0) {
            y = x ;
            x = *(x + 1) ;
            if (* y > * p) {
                *(y + 1) = b ;
                b = y ;
            }
            else {
                *(y + 1) = a ;
                a = y ;
            }
        }

        --- a = quicksort(a);
        assert <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> ?p |-> ?v : node ** (?p +Int 1) |-> 0 : next ** list(?a)(?A) ** list(?b)(?B) </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B)
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) </form> </config> ;
        assume <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> ?p |-> ?v : node ** (?p +Int 1) |-> 0 : next ** list(?a)(?A') ** list(?b)(?B) </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') </form> </config> ;

        --- b = quicksort(b);
        assert <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> ?p |-> ?v : node ** (?p +Int 1) |-> 0 : next ** list(?a)(?A') ** list(?b)(?B) </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') </form> </config> ;
        assume <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> ?p |-> ?v : node ** (?p +Int 1) |-> 0 : next ** list(?a)(?A') ** list(?b)(?B') </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A') /\ list2bag(?B) === list2bag(?B')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') /\ isSorted(?B') </form> </config> ;

        --- l = append(a, p);
        assert <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> list(?p)(?v) ** list(?a)(?A') ** list(?b)(?B') </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A') /\ list2bag(?B) === list2bag(?B')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') /\ isSorted(?B') </form> </config> ;
        assume <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> list(?l)(?A' :: ?v) ** list(?b)(?B') </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A') /\ list2bag(?B) === list2bag(?B')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') /\ isSorted(?B') </form> </config> ;

        --- l = append(l, b);
        assert <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> list(?l)(?A' :: ?v) ** list(?b)(?B') </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A') /\ list2bag(?B) === list2bag(?B')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') /\ isSorted(?B') </form> </config> ;
        assume <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                        <heap> list(?l)(?A' :: ?v :: ?B') </heap>
                        <form> list2bag(L) === ?v &' list2bag(?A) &' list2bag(?B) /\ list2bag(?A) === list2bag(?A') /\ list2bag(?B) === list2bag(?B')
                            /\ @(?v >=Int max(list2bag(?A))) /\ @(min(list2bag(?B)) >=Int ?v) /\ isSorted(?A') /\ isSorted(?B') </form> </config> ;
    }
    assert <config> <env> l |-> ?l ;; p |-> ?p ;; x |-> ?x ;; y |-> ?y ;; a |-> ?a ;; b |-> ?b </env>
                    <heap> list(?l)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;
  ) .


  op pListBubbleSort : -> K .
  eq pListBubbleSort = (
    assume <config> <env> l |-> l0 ;; x |-> ?x ;; y |-> ?y ;; change |-> ?change ;; temp |-> ?temp </env>
                    <heap> list(l0)(L) </heap> <form> TrueFormula </form> </config> ;
    if (l != 0) {
        change = 1 ;
        invariant <config> <env> l |-> l0 ;; x |-> ?x ;; y |-> ?y ;; change |-> ?change ;; temp |-> ?temp </env>
                           <heap> list(l0)(?L) </heap> <form> ~(l0 === 0) /\ list2bag(L) === list2bag(?L)
                               /\ (?change === 0 /\ isSorted(?L) \/ ?change === 1) </form> </config> ;
        while (change == 1) {
            change = 0 ;
            x = l ;
            y = *(l + 1) ;
            invariant <config> <env> l |-> l0 ;; x |-> ?x ;; y |-> ?y ;; change |-> ?change ;; temp |-> ?temp </env>
                               <heap> lseg(l0,?x)(?A) ** ?x |-> ?v : node ** (?x +Int 1) |-> ?y : next ** list(?y)(?B) </heap>
                               <form> ~(l0 === 0) /\ list2bag(L) === list2bag(?L) /\ ?L === ?A :: ?v :: ?B
                                   /\ (?change === 0 /\ isSorted(?A :: ?v) \/ ?change === 1) </form> </config> ;
            while (y != 0) {
                if (* x > * y) {
                    change = 1 ;
                    temp = * x ;
                    * x = * y ;
                    * y = temp ;
                }
                x = y ;
                y = *(y + 1) ;
            }
        }
    }
    assert <config> <env> l |-> l0 ;; x |-> ?x ;; y |-> ?y ;; change |-> ?change ;; temp |-> ?temp </env>
                    <heap> list(l0)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;    
  ) .


  op pListInsertionSort : -> K .
  eq pListInsertionSort = (
    assume <config> <env> l |-> ?l ;; x |-> ?x ;; y |-> ?y ;; e |-> ?e </env>
                    <heap> list(?l)(L) </heap> <form> TrueFormula </form> </config> ;
    x = l ;
    l = NULL ;
    invariant <config> <env> l |-> ?l ;; x |-> ?x ;; y |-> ?y ;; e |-> ?e </env>
                       <heap> list(?l)(?L) ** list(?x)(?X) </heap>
                       <form> list2bag(L) === list2bag(?L) &' list2bag(?X) /\ isSorted(?L) </form> </config> ;    
    while (x != 0) {
        e = x ;
        x = *(x + 1) ;
        if (l != NULL) {
            if (* e > * l) {
                y = l ;
                invariant <config> <env> l |-> ?l ;; x |-> ?x ;; y |-> ?y ;; e |-> ?e </env>
                          <heap> lseg(?l,?y)(?A) ** ?y |-> ?u : node ** (?y +Int 1) |-> ?n : next ** list(?n)(?B)
                              ** ?e |-> ?v : node ** (?e +Int 1) |-> ?x : next ** list(?x)(?X) </heap>
                          <form> list2bag(L) === list2bag(?L) &' list2bag(?v :: ?X) /\ isSorted(?L)
                              /\ ?L === ?A :: ?u :: ?B /\ @(max(list2bag(?A) &' ?u) <Int ?v) </form> </config> ;
                while (*(y + 1) != NULL && * e > *(*(y + 1))) {
                    y = *(y + 1) ;
                }
                *(e + 1) = *(y + 1) ;
                *(y + 1) = e ;
            }
            else {
                *(e + 1) = l ;
                l = e ;
            }
        }
        else {
            *(e + 1) = NULL ;
            l = e ;
        }
    
    }
    assert <config> <env> l |-> ?l ;; x |-> ?x ;; y |-> ?y ;; e |-> ?e </env>
                    <heap> list(?l)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;    
  ) .


  op pDebug : -> K .
  eq pDebug = (
    assume <config> <env> l |-> l0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(l0)(L) </heap> <form> TrueFormula </form> </config> ;
    if (l != NULL && *(l + 1)) {
        --- split the list in two
        a = NULL ;
        b = NULL ;
        *(*(l + 1)) = *(*(l + 1)) ;
        invariant <config> <env> l |-> l0 ;; a |-> 0 ;; b |-> 0 ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> l0 |-> ?v : node ** (l0 +Int 1) |-> ?n : next ** ?n |-> ?u : node ** (?n +Int 1) |-> ?l : next ** list(?l)(?L) </heap>
---                            <form> ~(l0 === 0) /\ L === ?v :: ?u :: ?L </form> </config>
---                         little extra help, assert ~(?n === 0)
                           <form> ~(l0 === 0) /\ ~(?n === 0) /\ L === ?v :: ?u :: ?L </form> </config>
                  <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> list(?a)(?A) ** list(?b)(?B) ** list(?l)(?L) </heap>
                           <form> list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?L) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        while (l != NULL) {
            e = l ;
            l = * (e + 1)
            * (e + 1) = a ;
            a = e ;
            if (l != NULL) {
                e = l ;
                l = * (e + 1)
                * (e + 1) = b ;
                b = e ;
            }
            
        }

        --- sort the first half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?a)(?A) ** list(?b)(?B) </heap>
                    <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;

        --- sort the second half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B') </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') /\ list2bag(?B) === list2bag(?B') /\ isSorted(?B') </form> </config> ;

        --- merge the two halves
        h = 0 ;
        t = 0 ;
        --- little extra help to unfold the queue heap pattern
        * a = * a ;
        * b = * b ;
        invariant <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> queue(?h,?t)(?C) ** list(?a)(?A) ** list(?b)(?B) </heap>
                           <form> ((~(?a === 0) /\ ~(?b === 0)) \/ (~(?h === 0) /\ ~(?t === 0)))
                               /\ list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?C)
                               /\ @(min(list2bag(?A)) >=Int max(list2bag(?C))) /\ @(min(list2bag(?B)) >=Int max(list2bag(?C)))
                               /\ isSorted(?A) /\ isSorted(?B) /\ isSorted(?C) </form> </config> ;
        while (a != 0 && b != 0) {
            if (* b > * a) {
                e = a ;
                a = *(a + 1) ;
            }
            else {
                e = b ;
                b = *(b + 1) ;
            }

            if (h != 0) {
                *(t + 1) = e ;
            }
            else {
                h = e ;
            }
            t = e ;
        }

        if (a != 0) {
            *(t + 1) = a ;
        }
        else {
            *(t + 1) = b ;
        }

        l = h ;
    }
    assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?l)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;
  ) .

  op pSchorrWaite : -> K .
  eq pSchorrWaite = (
    --- //@ assume [cleanGraph[graph](root)] ;
    t = root ;
    p = NULL ;
    ***(
    //@ inv t == NULL && [stackInGraph[graph](p) ** ?rest]
        || [ (cleanGraph[graph])(?in)(t) ** stackInGraph[graph](nodes(graph) MINUS ?in)(p) ** ?rest]
        || [markedGraph[graph](?in)(t) ** stackInGraph[graph](nodes(graph) MINUS ?in)(p) ** ?rest]
    ***) 
    while (p != NULL || (t != NULL && * t == 0)) {
      if (t == NULL || * t == 1) {
        if (*(p + 1) == 1) {       --- POP      t, p, p->r = p, p->r, t
          q = t ;                  --- q = t
          t = p ;                  --- t = p
          p = *(p + 3) ;           --- p = p -> right
          *(t + 3) = q ;           --- t -> right = q
        }
        else {                     --- SWING    t, p->r, p->l = p->r, p->l, t && p->c = 1
          q = t ;                  --- q = t
          t = *(p + 3) ;           --- t = p -> right
          *(p + 3) = *(p + 2) ;    --- p -> right = p -> left
          *(p + 2) = q ;           --- p -> left = q
          *(p + 1) = 1 ;           --- p -> c = 1
        }
      }
      else {                       --- PUSH     p, t, t->l = t, t->l, p && t->m = 1 && t->c = 0
        q = p ;                    --- q = p
        p = t ;                    --- p = t
        t = *(t + 2) ;             --- t = t -> left
        *(p + 2) = q ;             --- p -> left = q
        * p = 1 ;                  --- p -> m = 1
        *(p + 1) = 0 ;             --- p -> c = 0
      }
    }

    --- return(t)
    --- //@ assert [markedGraph[graph](result)]
  ) .
endm

---set print attribute on .


rew [| pSum |] .
rew [| pListReverse |] .
rew [| pListAppendNotNull |] .
rew [| pListAppend |] .
rew [| pListLength |] .
rew [| pDListLength |] .
rew [| pEnqueue |] .
rew [| pDequeue |] .
rew [| pQueueTransferOwner |] .
rew [| pStealQueue |] .
rew [| pTreeMirror |] .
rew [| pTreeToList |] .
rew [| pTreeToListWhile |] .
rew [| pListBubbleSort |] .
rew [| pListInsertionSort |] .
rew [| pListQuickSort |] .
rew [| pListMergeSort |] .

***(
rew [| pListLengthMergeSort |] .
rew [| pArrayAccess |] .
rew [| pSchorrWaite |] .
***)

--- rew [| pListLengthMergeSort |] .

eof

search
    <config>
<env> p |-> 0 ;; x |-> ?x ;; y |-> ?y </env>
<heap>
     list ?x A
</heap>
<form> TrueFormula </form>
<menv> .MatchEnv </menv>
<newSym> 0 </newSym>
<newImpl> 0 </newImpl>
    </config>
===>
    <config>
   <env> p |-> ?p ;; x |-> ?x ;; y |-> ?x </env>
   <heap>
        list ?p ?B
     ** list ?x ?C
   </heap>
   <form> ~ (?p === 0) /\ rev(A) === rev(?C) :: ?B </form>
    </config>
---=>* <form> F:Formula </form> <menv> MatchEnv:MatchEnv </menv> .
=>* S:Set{ConfigItem} .


