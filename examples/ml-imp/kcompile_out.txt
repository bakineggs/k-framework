Maude> Usage: compile <ModuleName> .
Error while wrapping Syntax lists into K
To reproduce load k-prelude and then the generated module.

---K-MAUDE-GENERATED-OUTPUT-BEGIN---
mod IMP is including K-CONTEXTS . including K-DESTRUCTORS . including K-POLYMORPHIC-VARIABLES . including K-QUOTED-LABELS . including K-TECHNIQUE . including K-WHERE . including PL-BOOL . including PL-ID . including PL-INT . sorts Annot Exp Result Stmt Stmts Val . subsort Annot < K . subsort Annot < Stmts . subsort Exp < K . subsort Id < Exp . subsort Id < K . subsort Int < Exp . subsort Int < K . subsort Int < KResult . subsort Int < Val . subsort Nat < Exp . subsort Nat < K . subsort Nat < KResult . subsort Nat < Val . subsort NzInt < Builtins . subsort NzInt < Exp . subsort NzInt < K . subsort NzInt < KResult . subsort NzInt < Val . subsort NzNat < Builtins . subsort NzNat < Exp . subsort NzNat < Int . subsort NzNat < K . subsort NzNat < KResult . subsort NzNat < Val . subsort Stmt < K . subsort Stmt < Stmts . subsort Stmts < K . subsort Val < Exp . subsort Val < K . subsort Val < KResult . subsort Zero < Builtins . subsort Zero < Exp . subsort Zero < Int . subsort Zero < K . subsort Zero < KResult . subsort Zero < Val . op $hasMapping : Map K -> Bool . op ?_ : Bool -> Int . op NULL : -> Exp . op T : -> CellLabel . op _-_ : Bag Bag -> Bag . op _-_ : Set Set -> Set . op _==Int_ : Int Int -> Bool . op _`[undef/_`] : Map List{K}-> Map . op _in_ : BagItem Bag -> Bool . op _in_ : K Bag -> Bool . op _in_ : K Set -> Bool . op _in_ : SetItem Set -> Bool . op _|->_ : List{K}List{K}-> Map . op `{`} : -> Stmt . op check : KLabel -> Result . op config : -> CellLabel . op env : -> CellLabel . op feasible : -> CellLabel . op form : -> CellLabel . op heap : -> CellLabel . op infeasible : -> CellLabel . op isInt : Int -> Bool . op k : -> CellLabel . op keys_ : Map -> Set . op newImpl : -> CellLabel . op newSym : -> CellLabel . op subst : -> CellLabel . op while`(_`)_ : Exp Stmt -> Stmt . op !_ : Exp -> Exp[prec 5 metadata "strict"]. op *_ : Exp -> Exp[prec 10 metadata "strict"]. op -_ : Exp -> Exp[metadata "strict"]. op //`assert_ : Bag -> Annot[strat(0)prec 99]. op //`assume_ : Bag -> Annot[strat(0)prec 99]. op //`invariant_ : Bag -> Annot[strat(0)prec 99]. op //`post_ : Bag -> Annot[strat(0)prec 99]. op //`pre_ : Bag -> Annot[strat(0)prec 99]. op _!=_ : Exp Exp -> Exp[prec 35]. op _%_ : Exp Exp -> Exp[prec 29 gather(E e)metadata "strict"]. op _&&_ : Exp Exp -> Exp[prec 55 gather(E e)metadata "strict(1)"]. op _*_ : Exp Exp -> Exp[prec 31 gather(E e)metadata "strict"]. op _+_ : Exp Exp -> Exp[prec 33 gather(E e)metadata "strict"]. op _-_ : Exp Exp -> Exp[prec 33 gather(E e)metadata "strict"]. op _/_ : Exp Exp -> Exp[prec 31 gather(E e)metadata "strict"]. op _; : Exp -> Stmt[prec 60 metadata "strict"]. op _<=_ : Exp Exp -> Exp[prec 35 metadata "strict"]. op _<_ : Exp Exp -> Exp[prec 35 metadata "strict"]. op _==_ : Exp Exp -> Exp[prec 35 metadata "strict"]. op _=_; : Exp Exp -> Stmt[prec 2 metadata "strict(2)"]. op _>=_ : Exp Exp -> Exp[prec 35 metadata "strict"]. op _>_ : Exp Exp -> Exp[prec 35 metadata "strict"]. op _?_:_ : Exp Exp Exp -> Exp[prec 59 metadata "strict(1)"]. op __ : Stmts Stmts -> Stmts[prec 100 gather(e E)]. op _`(_`) : Map List{K}-> List{K}[prec 0]. op _`[_/_`] : Map List{K}List{K}-> Map[prec 0]. op _feasible`and_infeasible`paths : Nat Nat -> Result[format(g! d d d d d o)]. op _||_ : Exp Exp -> Exp[prec 57 gather(E e)metadata "strict(1)"]. op `[|_`,_`,_|`] : Nat Nat Bag -> Result[strat(0 1 2 3 0)]. op `{_`} : Stmts -> Stmt[gather(&)]. op if`(_`)_ : Exp Stmt -> Stmt[prec 95]. op if`(_`)_else_ : Exp Stmt Stmt -> Stmt[prec 93 metadata "strict(1)"]. op return_; : Exp -> Stmt[metadata "strict"]. eq NULL = 0 . eq $hasMapping(__(M:Map,_|->_(D:K,R:K)),D:K)= true . eq _!=_(E1:Exp,E2:Exp)= !_(_==_(E1:Exp,E2:Exp)). eq _-_((.).Bag,Bag:Bag)=(.).Bag . eq _-_((.).Set,Set:Set)=(.).Set . eq _-_(__(Bag:Bag,BagItem:BagItem),Bag':Bag)= if_then_else_fi(_in_(BagItem:BagItem,Bag':Bag),_-_(Bag:Bag,Bag':Bag),__(BagItem:BagItem,_-_(Bag:Bag,Bag':Bag))). eq _-_(__(Set:Set,SetItem:SetItem),Set':Set)= if_then_else_fi(_in_(SetItem:SetItem,Set':Set),_-_(Set:Set,Set':Set),__(SetItem:SetItem,_-_(Set:Set,Set':Set))). eq _`(_`)(Map:Map,.List`{K`})= .List`{K`} . eq _`(_`)(Map:Map,_`,`,_(K1:K,NList1:NeList{K}))= _`,`,_(_`(_`)(Map:Map,K1:K),_`(_`)(Map:Map,NList1:NeList{K})). eq _`[_/_`](Map:Map,K2:K,_`,`,_(K1:K,NList1:NeList{K}))= _`[_/_`](_`[_/_`](Map:Map,K2:K,K1:K),K2:K,NList1:NeList{K}). eq _`[_/_`](Map:Map,List:List{K},.List`{K`})= Map:Map . eq _`[_/_`](Map:Map,_`,`,_(K1:K,NList1:NeList{K}),_`,`,_(K2:K,NList2:NeList{K}))= _`[_/_`](_`[_/_`](Map:Map,K1:K,K2:K),NList1:NeList{K},NList2:NeList{K}). eq _`[undef/_`](Map:Map,.List`{K`})= Map:Map . eq _`[undef/_`](Map:Map,_`,`,_(K1:K,NList1:NeList{K}))= _`[undef/_`](_`[undef/_`](Map:Map,K1:K),NList1:NeList{K}). eq _`[undef/_`](__(Map:Map,_|->_(K1:K,K2:K)),K1:K)= Map:Map . eq _in_(BagItem:BagItem,__(Bag:Bag,BagItem:BagItem))= true . eq _in_(K:K,__(Bag:Bag,BagItem(K:K)))= true . eq _in_(K:K,__(Set:Set,SetItem(K:K)))= true . eq _in_(SetItem:SetItem,__(Set:Set,SetItem:SetItem))= true . eq _|->_(.List`{K`},List:List{K})=(.).Map . eq _|->_(_`,`,_(K1:K,NList1:NeList{K}),K2:K)= __(_|->_(K1:K,K2:K),_|->_(NList1:NeList{K},K2:K)). eq _|->_(_`,`,_(K1:K,NList1:NeList{K}),_`,`,_(K2:K,NList2:NeList{K}))= __(_|->_(K1:K,K2:K),_|->_(NList1:NeList{K},NList2:NeList{K})). eq check(K:KLabel)= `[|_`,_`,_|`](0,0,<_>_</_>(T,<_>_</_>(config,<_>_</_>(k,_`(_`)(K:KLabel,.List`{K`}),k),config),T)). eq if`(_`)_(E:Exp,S:Stmt)= if`(_`)_else_(E:Exp,S:Stmt,`{`}). eq isInt(I:Int)=(I:Int :: Int). eq keys_(.)=(.).Set . eq keys_(__(Map:Map,_|->_(K1:K,K2:K)))= __(SetItem(K1:K),keys_(Map:Map)). eq $hasMapping(M:Map,D:K)= false[owise]. eq _in_(BagItem:BagItem,Bag:Bag)= false[owise]. eq _in_(K:K,Bag:Bag)= false[owise]. eq _in_(K:K,Set:Set)= false[owise]. eq _in_(SetItem:SetItem,Set:Set)= false[owise]. rl `{`} =>(.).K[metadata "computational rule"]. rl !_(0)=> 1[metadata "computational rule"]. rl !_(NzI:NzInt)=> 1[metadata "computational rule"]. rl -_(I:Int)=> -Int_(I:Int)[metadata "computational rule"]. rl <_>_</_>(config,__(CfgItems:Bag,<_>_</_>(k,_~>_(_?_:_(I:Int,E1:Exp,E2:Exp),K:K),k)),config)=> __(<_>_</_>(config,__(CfgItems:Bag,<_>_</_>(k,_~>_(E1:Exp,K:K),k)),config),<_>_</_>(config,__(CfgItems:Bag,<_>_</_>(k,_~>_(E2:Exp,K:K),k)),config))[metadata "computational rule"]. rl _%_(I1:Int,I2:Int)=> _%Int_(I1:Int,I2:Int)[metadata "computational rule"]. rl _&&_(0,E:Exp)=> 0[metadata "computational rule"]. rl _&&_(NzI:NzInt,E:Exp)=> E:Exp[metadata "computational rule"]. rl _*_(I1:Int,I2:Int)=> _*Int_(I1:Int,I2:Int)[metadata "computational rule"]. rl _+_(I1:Int,I2:Int)=> _+Int_(I1:Int,I2:Int)[metadata "computational rule"]. rl _-_(I1:Int,I2:Int)=> _-Int_(I1:Int,I2:Int)[metadata "computational rule"]. rl _/_(I1:Int,I2:Int)=> _/Int_(I1:Int,I2:Int)[metadata "computational rule"]. rl _;(V:Val)=>(.).K[metadata "computational rule"]. rl _<=_(I1:Int,I2:Int)=> ?_(_<=Int_(I1:Int,I2:Int))[metadata "computational rule"]. rl _<_(I1:Int,I2:Int)=> ?_(_<Int_(I1:Int,I2:Int))[metadata "computational rule"]. rl _==_(I1:Int,I2:Int)=> ?_(_==Int_(I1:Int,I2:Int))[metadata "computational rule"]. rl _>=_(I1:Int,I2:Int)=> ?_(_>=Int_(I1:Int,I2:Int))[metadata "computational rule"]. rl _>_(I1:Int,I2:Int)=> ?_(_>Int_(I1:Int,I2:Int))[metadata "computational rule"]. rl _?_:_(0,E1:Exp,E2:Exp)=> E2:Exp[metadata "computational rule"]. rl _?_:_(NzI:NzInt,E1:Exp,E2:Exp)=> E1:Exp[metadata "computational rule"]. rl __(S1:Stmt,S2:Stmt)=> _~>_(S1:Stmt,S2:Stmt)[metadata "computational rule"]. rl __(<_>_</_>(k,_~>_(X:Id,?8:K),k),<_>_</_>(env,__(?7:Map,_|->_(X:Id,V:Val)),env))=> __(<_>_</_>(k,_~>_(V:Val,?8:K),k),<_>_</_>(env,__(?7:Map,_|->_(X:Id,V:Val)),env))[metadata "computational rule"]. rl __(<_>_</_>(k,_~>_(_=_;(X:Id,V:Val),?10:K),k),<_>_</_>(env,__(?8:Map,_|->_(X:Id,?9:List{K})),env))=> __(<_>_</_>(k,?10:K,k),<_>_</_>(env,__(?8:Map,_|->_(X:Id,V:Val)),env))[metadata "computational rule"]. rl _||_(0,E:Exp)=> E:Exp[metadata "computational rule"]. rl _||_(NzI:NzInt,E:Exp)=> NzI:NzInt[metadata "computational rule"]. rl `{_`}(Ss:Stmts)=> Ss:Stmts[metadata "computational rule"]. rl if`(_`)_else_(0,?4:Stmt,S:Stmt)=> S:Stmt[metadata "computational rule"]. rl if`(_`)_else_(NzI:NzInt,S:Stmt,?5:Stmt)=> S:Stmt[metadata "computational rule"]. crl _&&_(I:Int,E:Exp)=> _&&_(_?_:_(I:Int,1,0),E:Exp)if notBool_(isInt(I:Int))[metadata "computational rule"]. endm
---K-MAUDE-GENERATED-OUTPUT-END-----

Maude> Bye.
