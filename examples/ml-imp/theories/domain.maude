mod MATHEMATICAL-DOMAIN is
  inc MATHEMATICAL-SEQUENCE + MATHEMATICAL-MULTISET + MATHEMATICAL-TREE .

  var Obj : MathObjSymbolic .
  var I : IntSymbolic .
  vars T TL TR : TreeSymbolic .

  op tree2seq : TreeSymbolic -> NeSeqSymbolic .
***(
  op tree2seq : TreePatternExistential -> SeqPatternExistential [ditto] .
  op tree2seq : TreeFunctionExistential -> SeqFunctionExistential [ditto] .
  op tree2seq : TreeUniversal -> SeqUniversal [ditto] .
  op tree2seq : Tree -> NeSeq [ditto] .
***)
  eq tree2seq(TL [ Obj ] TR) = tree2seq(TL) ::: [Obj] ::: tree2seq(TR) .
  eq tree2seq(upsilon) = epsilon .
  op tree2mset : TreeSymbolic -> NeMSetSymbolic .
***(
  op tree2mset : TreePatternExistential -> MSetPatternExistential [ditto] .
  op tree2mset : TreeFunctionExistential -> MSetFunctionExistential [ditto] .
  op tree2mset : TreeUniversal -> MSetUniversal [ditto] .
  op tree2mset : Tree -> NeMSet [ditto] .
***)
  eq tree2mset(TL [ Obj ] TR) = tree2mset(TL) U {| Obj |} U tree2mset(TR) .
  eq tree2mset(upsilon) = empty .
  op isBst : TreeSymbolic -> Atom .
  eq isBst(TL [I] TR) = @(max(tree2mset(TL)) <=Int I) /\
                        @(I <Int min(tree2mset(TR))) /\
                        isBst(TL) /\ isBst(TR) .
  eq isBst(upsilon) = TrueFormula .

  vars NeA NeA' : NeSeqSymbolic .

  op seq2mset : SeqSymbolic -> NeMSetSymbolic .
***(
  op seq2mset : SeqPatternExistential -> MSetPatternExistential [ditto] .
  op seq2mset : SeqFunctionExistential -> MSetFunctionExistential [ditto] .
  op seq2mset : SeqUniversal -> MSetUniversal [ditto] .
  op seq2mset : Seq -> NeMSet [ditto] .
***)
  eq seq2mset(NeA ::: NeA') = seq2mset(NeA) U seq2mset(NeA') .
  eq seq2mset([Obj]) = {| Obj |} .
  eq seq2mset(epsilon) = empty .

  op isSorted : SeqSymbolic -> Atom .
  eq isSorted(NeA ::: NeA')
   = @(min(seq2mset(NeA')) >=Int max(seq2mset(NeA))) /\
     isSorted(NeA) /\ isSorted(NeA') .
  eq isSorted([I]) = TrueFormula .
  eq isSorted(epsilon) = TrueFormula .

  vars Phi Phi1 Phi2 : Formula .
  var A : SeqSymbolic .

  eq @(1 +Int (-Int len(A)) >=Int 0) /\ Phi1 ===> isSorted(A) /\ Phi2
   = @(1 +Int (-Int len(A)) >=Int 0) /\ Phi1 ===> Phi2 .
endm

