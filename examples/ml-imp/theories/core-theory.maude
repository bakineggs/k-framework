mod FORMULA is inc PL-BOOL + PL-STRING .
  sorts Truth Atom NtFormula Formula .
  subsort Atom < NtFormula .
  subsort Truth NtFormula < Formula .
  

  ops TrueFormula FalseFormula : -> Truth .
  op @_ : Bool -> Atom [prec 0] .
  op _/\_ : NtFormula Formula -> NtFormula
  [prec 55 assoc comm id: TrueFormula] .
  op _/\_ : Formula Formula -> Formula [ditto] .
  op ~_ : Atom -> Atom [prec 0] .
  op ~_ : Formula -> NtFormula [ditto] .
  op _\/_ : NtFormula Formula -> NtFormula
  [prec 59 assoc comm id: FalseFormula] .
  op _\/_ : Formula Formula -> Formula [ditto] .
  op _===>_ : Formula Formula -> NtFormula [prec 61] .

  op check-sat : Formula -> String .

  var Atom : Atom .
  vars NtPhi NtPhi1 NtPhi2 NtPhi' : NtFormula .
  vars Phi Phi1 Phi2 Phi' : Formula .

  eq  @ true =  TrueFormula .
  eq @ false = FalseFormula .
  
  --- junk
  op form-to-bool : Formula -> Bool .
  eq form-to-bool(TrueFormula) = true .
  eq form-to-bool(FalseFormula) = false .
  --- end-of-junk

  eq  ~(TrueFormula) = FalseFormula .
  eq ~(FalseFormula) =  TrueFormula .
  eq ~(~(Phi)) = Phi .

  eq  TrueFormula \/  TrueFormula =  TrueFormula .
  eq FalseFormula /\ FalseFormula = FalseFormula .
  eq  TrueFormula \/ NtPhi =  TrueFormula .
  eq FalseFormula /\ NtPhi = FalseFormula .
  eq NtPhi /\ NtPhi = NtPhi .
  eq NtPhi \/ NtPhi = NtPhi .
  eq NtPhi /\ ~(NtPhi) = FalseFormula .
  eq NtPhi \/ ~(NtPhi) =  TrueFormula .

  eq Phi ===>  TrueFormula = TrueFormula .
  eq Phi ===> FalseFormula = ~ Phi .
---  leads to in infinite rewriting
---  eq FalseFormula ===> Phi = TrueFormula .
  eq  TrueFormula ===> Phi = Phi .


  eq Atom /\ Phi1 ===> Atom /\ Phi2 = Atom /\ Phi1 ===> Phi2 .

  eq Phi ===> (NtPhi1 \/ NtPhi2) = (Phi ===> NtPhi1) \/ (Phi ===> NtPhi2) .

--- very, very bad eqs
---   eq NtPhi /\ (NtPhi1 \/ NtPhi2) = (NtPhi /\ NtPhi1) \/ (NtPhi /\ NtPhi2) .
---   eq (NtPhi1 \/ NtPhi2) ===> Phi = (NtPhi1 ===> Phi) \/ (NtPhi2 ===> Phi) .

--- bad, bad eq
  eq NtPhi /\ (NtPhi1 \/ NtPhi2) ===> NtPhi'
   = (NtPhi /\ NtPhi1 ===> NtPhi') \/ (NtPhi /\ NtPhi2 ===> NtPhi') [owise] .
endm


mod MATHEMATICAL-OBJECT is inc FORMULA + PL-NAT .
***(
?Sort stands for bound symbolic mathematical objects
!Sort stands for unbound symbolic mathematical objects
FreeSort stands for unbound symbolic mathematical objects
Sort stands for ground, non-symbolic mathematical objects
Sort++ stands for all the above
***)
  sorts MathObjPatternExistential MathObjFunctionExistential MathObjUniversal MathObj MathObjSymbolic .
  sorts List{MathObjSymbolic} Set{MathObjSymbolic} .
  subsort MathObjPatternExistential MathObjFunctionExistential MathObjUniversal MathObj < MathObjSymbolic .
  subsort MathObjSymbolic < List{MathObjSymbolic} Set{MathObjSymbolic} .
  op skolem : Nat MathObjPatternExistential -> MathObjUniversal [strat(0)] .
  op co-skolem : MathObjUniversal -> MathObjFunctionExistential [strat(0)] .

  op .List{MathObjSymbolic} : -> List{MathObjSymbolic} .
  op _`,_ : List{MathObjSymbolic} List{MathObjSymbolic} -> List{MathObjSymbolic}
  [assoc id: .List{MathObjSymbolic}] .

  op .Set{MathObjSymbolic} : -> Set{MathObjSymbolic} .
  op _&_ : Set{MathObjSymbolic} Set{MathObjSymbolic} -> Set{MathObjSymbolic}
  [assoc comm id: .Set{MathObjSymbolic}] .
  eq Obj & Obj = Obj .

  op errorObj : -> [MathObjSymbolic] .


  --- must not be comm 
  op _===_ : MathObjSymbolic MathObjSymbolic -> Atom .
  op _===_ : List{MathObjSymbolic} List{MathObjSymbolic} -> Atom [ditto] .

  vars Obj Obj1 Obj1' Obj2 Obj2' : MathObjSymbolic .
  vars ObjList1 ObjList2 : List{MathObjSymbolic} .

  eq Obj === Obj = TrueFormula .
  eq (Obj1, Obj1', ObjList1) === (Obj2, Obj2', ObjList2)
   = (Obj1 === Obj2) /\ (Obj1' === Obj2') /\ (ObjList1 === ObjList2) .
  eq .List{MathObjSymbolic} === .List{MathObjSymbolic} = TrueFormula .
endm


mod MATHEMATICAL-INT is inc MATHEMATICAL-OBJECT + PL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts IntPatternExistential IntFunctionExistential IntUniversal IntSymbolic .   --- sort Int already defined
  subsort IntPatternExistential IntFunctionExistential IntUniversal Int < IntSymbolic .
  subsort IntPatternExistential < MathObjPatternExistential .
  subsort IntFunctionExistential < MathObjFunctionExistential .
  subsort IntUniversal < MathObjUniversal .
  subsort Int < MathObj .
  subsort IntSymbolic < MathObjSymbolic .

  op IntPatternExistential : Nat -> IntPatternExistential .
  op IntFunctionExistential : Nat -> IntFunctionExistential .
  op skolem : Nat IntPatternExistential -> IntUniversal [ditto] .
  op co-skolem : IntUniversal -> IntFunctionExistential [ditto] .

--- define operations to be used symbolically, as well as desired properties
  ops _+Int_ _-Int_ _*Int_ _/Int_ _%Int_ : IntSymbolic IntSymbolic -> IntSymbolic [ditto] .
  ops _<=Int_ _<Int_ _>=Int_ _>Int_ : IntSymbolic IntSymbolic -> Bool [ditto] .
  op -Int_ : IntSymbolic -> IntSymbolic [ditto] .
  op _==Int_ : IntSymbolic IntSymbolic -> Bool [ditto] .

  op ?_ : Bool -> IntSymbolic .
  eq ?_(true) = 1 .
  eq ?_(false) = 0 .

  var B : Bool .
  vars I J K I1 I2 J1 J2 N : IntSymbolic .
  vars Phi Phi1 Phi2 : Formula .

  eq @ (I ==Int J) = I === J .

  eq I +Int (-Int I) = 0 .
  eq 0 +Int I = I .
  eq I *Int (I1 +Int I2) = (I *Int I1) +Int (I *Int I2) .
  eq (-Int I) *Int J = -Int (I *Int J) .
  eq -Int (-Int I) = I .
  eq 1 *Int I = I .
  eq I -Int J = I +Int (-Int J) .
  eq -Int (I +Int J) = (-Int I) +Int (-Int J) .
---  stack overflow
---  eq I +Int (J /Int 2) = (I +Int I +Int J) /Int 2 .

  eq I +Int K === J +Int K = I === J .
 ceq I1 === J1 /\ Phi1 ===> I2 === J2 /\ Phi2 = I1 === J1 /\ Phi1 ===> Phi2
  if (-Int I1) +Int (-Int I2) +Int J1 +Int J2 ==Bool 0 .

  eq I <=Int J = J >=Int I .
  eq I <Int J = J >Int I .
  eq I >Int J = I +Int (-Int 1) >=Int J . 
 ceq I >=Int J = I +Int (-Int J) >=Int 0 if J =/=Bool 0 .
  eq ~(@(I >=Int 0)) = @((-Int I) +Int (-Int 1) >=Int 0) .

 ceq @(I >=Int 0) /\ @(J >=Int 0) = (I === 0) if I +Int J ==Bool 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) = @(I >=Int 0) if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ Phi1 ===> @(J >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> @(K >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int (-Int J) +Int K >=Int 0 .

  eq (?(B) === 0) = ~(@ B) .
  eq (?(B) === 1) = @ B .
  eq (0 === ?(B)) = ~(@ B) .
  eq (1 === ?(B)) = @ B .

  eq (I:Int === J:Int) = @(I:Int ==Bool J:Int) .

endm

