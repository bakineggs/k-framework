load ml-prelude.maude


mod PL-META-TERM is including PL-BOOL + PL-QID .
*** types
  sorts Sort Kind Type .
  subsorts Sort Kind < Type < Qid .
  op <Qids> : -> Sort [special (id-hook QuotedIdentifierSymbol (sortQid))] .
  op <Qids> : -> Kind [special (id-hook QuotedIdentifierSymbol (kindQid))] .


*** terms
  sorts Constant Variable GroundTerm Term NeGroundTermList GroundTermList NeTermList TermList .
  subsorts Constant Variable < Qid Term .
  subsorts Constant < GroundTerm < Term NeGroundTermList < NeTermList .
  subsorts NeGroundTermList < NeTermList GroundTermList < TermList .
  op <Qids> : -> Constant [special (id-hook QuotedIdentifierSymbol (constantQid))] .
  op <Qids> : -> Variable [special (id-hook QuotedIdentifierSymbol (variableQid))] .
  op empty : -> GroundTermList [ctor] .
  op _:_ : NeGroundTermList GroundTermList -> NeGroundTermList [ctor assoc id: empty gather (e E) prec 121] .
  op _:_ : GroundTermList NeGroundTermList -> NeGroundTermList [ctor ditto] .
  op _:_ : GroundTermList GroundTermList -> GroundTermList [ctor ditto] .
  op _:_ : NeTermList TermList -> NeTermList [ctor ditto] .
  op _:_ : TermList NeTermList -> NeTermList [ctor ditto] .
  op _:_ : TermList TermList -> TermList [ctor ditto] .
  op _[_] : Qid NeGroundTermList -> GroundTerm [ctor] .
  op _[_] : Qid NeTermList -> Term [ctor] .

*** utils for constant/variables
  op getName : Constant -> Qid .
  op getType : Constant -> Type .
  var C : Constant .
  op getName : Variable -> Qid .
  op getType : Variable -> Type .
  var V : Variable .
  eq getName (C) = qid (substrString (string (C), 0, rfindString (string (C), ".", lengthString (string (C))))) .
  eq getType (C) = qid (substrString (string (C), rfindString (string (C), ".", lengthString (string (C))) +Nat 1, lengthString (string (C)))) .
  eq getName (V) = qid (substrString (string (V), 0, rfindString (string (V), ":", lengthString (string (V))))) .
  eq getType (V) = qid (substrString (string (V), rfindString (string (V), ":", lengthString (string (V))) +Nat 1, lengthString (string (V)))) .


  sort Module .
  sort ResultPair .
  op metaReduce : Module Term ~> ResultPair
     [special (
        id-hook MetaLevelOpSymbol	(metaReduce)

        op-hook qidSymbol		(<Qids> : ~> Qid)
        op-hook metaTermSymbol		(_[_] : Qid NeTermList ~> Term)
        op-hook metaArgSymbol		(_:_ : NeTermList NeTermList ~> NeTermList)

        term-hook trueTerm		(true)
        term-hook falseTerm		(false))] .


  op downTerm : Term Universal -> Universal
        [poly (2 0)
         special (
           id-hook MetaLevelOpSymbol	(metaDownTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .


  op upTerm : Universal -> Term
        [poly (1) strat(0)
         special (
           id-hook MetaLevelOpSymbol	(metaUpTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair)
) ] .

endm


mod VAR-UTILS is inc MATHEMATICAL-OBJECT + PL-META-TERM .
  op get?VarSet : Formula -> Set{MathObj++} .
  op get?VarSet : TermList -> Set{MathObj++} .
  op get!VarSet : Formula -> Set{MathObj++} .
  op get!VarSet : TermList -> Set{MathObj++} .
  op getFreeVarSet : Formula -> Set{MathObj++} .
  op getFreeVarSet : TermList -> Set{MathObj++} .

  var Phi : Formula .
  var Obj : MathObj++ .

  eq get?VarSet(Phi) = get?VarSet(upTerm(Phi)) .
  eq get!VarSet(Phi) = get!VarSet(upTerm(Phi)) .
  eq getFreeVarSet(Phi) = getFreeVarSet(upTerm(Phi)) .

  var Q : Qid .  var QC : Constant .  vars QT NT NT' : Term .
  var QTList : TermList .  var QTNeList : NeTermList .
  eq get?VarSet((QT : QTNeList)) = get?VarSet(QT) & get?VarSet(QTNeList) .
  eq get?VarSet(empty) = .Set{MathObj++} .
  eq get?VarSet(QC) = if downTerm(QC, errorObj) :: ?MathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
 ceq get?VarSet(Q[QT]) = downTerm(Q[QT], .Set{MathObj++})
  if substrString(string(Q), 0, 1) ==Bool "?" .
  eq get?VarSet(Q[QTList]) = get?VarSet(QTList) [owise] .

  eq getFreeVarSet((QT : QTNeList))
   = getFreeVarSet(QT) & getFreeVarSet(QTNeList) .
  eq getFreeVarSet(empty) = .Set{MathObj++} .
  eq getFreeVarSet(QC) = if downTerm(QC, errorObj) :: FreeMathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
  eq getFreeVarSet('skolem[NT : QT])
   = downTerm('skolem[NT : QT], .Set{MathObj++}) .
  eq getFreeVarSet(Q[QTList]) = getFreeVarSet(QTList) [owise] .
endm


mod APPLY-SUBST is inc CONFIG + PL-META-TERM .
  sort MetaSubst .
  op .MetaSubst : -> MetaSubst .
  op _;_ : MetaSubst MetaSubst -> MetaSubst [assoc comm id: .MetaSubst] .
  op _<-_ : Term Term -> MetaSubst .
  op upSubst : Subst -> MetaSubst .

  var Obj Obj' : MathObj++ .
  var Subst Subst' : Subst .
  eq upSubst((Obj <- Obj') ; Subst)
   = (upTerm(Obj) <- upTerm(Obj')) ; upSubst(Subst) .
  eq upSubst(.Subst) = .MetaSubst .

  op substTerm : TermList MetaSubst -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT QT' NT : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .
  var MetaSubst : MetaSubst .

  eq substTerm((QT : QTNeList), MetaSubst)
   = substTerm(QT, MetaSubst) : substTerm(QTNeList, MetaSubst) .
  eq substTerm(empty, MetaSubst) = empty .
  eq substTerm(QT, ((QT <- QT') ; MetaSubst)) = QT' .
  eq substTerm('skolem[NT : QT], MetaSubst) = 'skolem[NT : QT] .
  eq substTerm(QC, MetaSubst) = QC [owise] .
  eq substTerm(Q[QTList], MetaSubst)
   = Q[substTerm(QTList, MetaSubst)] [owise] .

  var Cfgs : Bag .
  var Phi : Formula .
  --- apply substitution on a configuration
  eq Cfgs[Subst]
   = downTerm(substTerm(upTerm(Cfgs), upSubst(Subst)), errorBag) .
  --- apply substitution on a substitution
  eq Phi[Subst]
   = downTerm(substTerm(upTerm(Phi), upSubst(Subst)), FalseFormula) .
  --- apply substitution on a substitution
  eq Subst[Subst']
   = downTerm(substTerm(upTerm(Subst), upSubst(Subst')), .Subst) .
endm


mod SKOL is inc CONFIG + PL-META-TERM .
  op skolemTerm : Term TermList -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT NT NT' : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .

  eq skolemTerm(NT, (QT : QTNeList))
   = skolemTerm(NT, QT) : skolemTerm(NT, QTNeList) .
  eq skolemTerm(NT, empty) = empty .
  eq skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 1) ==Bool "?" then
       'skolem[NT : QC]
     else
       QC
     fi .
  eq skolemTerm(NT, '?Int[QT]) = 'skolem[NT : '?Int[QT]] .
  eq skolemTerm(NT, '?Seq[QT]) = 'skolem[NT : '?Seq[QT]] .
  eq skolemTerm(NT, '?Tree[QT]) = 'skolem[NT : '?Tree[QT]] .
  eq skolemTerm(NT, '?MSet[QT]) = 'skolem[NT : '?MSet[QT]] .
  eq skolemTerm(NT, 'skolem[NT' : QT]) = 'skolem[NT' : QT] .
  eq skolemTerm(NT, Q[QTList]) = Q[skolemTerm(NT, QTList)] [owise] .

  var N : Nat .
  var Cfgs : Bag .
  eq skolemize(N, Cfgs)
   = downTerm(skolemTerm(upTerm(N), upTerm(Cfgs)), errorBag) .
endm


mod MB-CONDITION is inc CONFIG .
  var I : Int++ .
  eq I : : IntSort = I :: Int .
endm

