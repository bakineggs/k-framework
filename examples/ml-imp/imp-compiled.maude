load ../../tools/../k-prelude

mod IMP is including K-CONDITION-SEARCH .
including K-CONFIG .
including K-CONTEXTS .
including K-DESTRUCTORS .
including K-OPEN-CELLS .
including K-POLYMORPHIC-VARIABLES .
including K-QUOTED-LABELS .
including K-RULES .
including K-TECHNIQUE .
including K-WHERE .
including PL-BOOL .
including PL-ID .
including PL-INT .
including PL-NAT .
sorts !Int !Map !MathObj ?Int ?Map ?MathObj Annot Atom Exp Formula FreeInt
    FreeMap FreeMathObj Int++ List{MathObj++}LocType MathObj MathObj++
    NtFormula Result Set{MathObj++}Stmt Stmts Subst SubstItem Truth Val .
    subsort !Int < !MathObj .
subsort !Int < Builtins .
subsort !Int < Exp .
subsort !Int < Int++ .
subsort !Int < K .
subsort !Int < KResult .
subsort !Int < List{MathObj++}.
subsort !Int < MathObj++ .
subsort !Int < Set{MathObj++}.
subsort !Int < Val .
subsort !Map < Map .
subsort !MathObj < Builtins .
subsort !MathObj < K .
subsort !MathObj < KResult .
subsort !MathObj < List{MathObj++}.
subsort !MathObj < MathObj++ .
subsort !MathObj < Set{MathObj++}.
subsort ?Int < ?MathObj .
subsort ?Int < Builtins .
subsort ?Int < Exp .
subsort ?Int < Int++ .
subsort ?Int < K .
subsort ?Int < KResult .
subsort ?Int < List{MathObj++}.
subsort ?Int < MathObj++ .
subsort ?Int < Set{MathObj++}.
subsort ?Int < Val .
subsort ?Map < Map .
subsort ?MathObj < Builtins .
subsort ?MathObj < K .
subsort ?MathObj < KResult .
subsort ?MathObj < List{MathObj++}.
subsort ?MathObj < MathObj++ .
subsort ?MathObj < Set{MathObj++}.
subsort Annot < K .
subsort Annot < Stmts .
subsort Atom < Formula .
subsort Atom < NtFormula .
subsort Exp < K .
subsort FreeInt < Builtins .
subsort FreeInt < Exp .
subsort FreeInt < FreeMathObj .
subsort FreeInt < Int++ .
subsort FreeInt < K .
subsort FreeInt < KResult .
subsort FreeInt < List{MathObj++}.
subsort FreeInt < MathObj++ .
subsort FreeInt < Set{MathObj++}.
subsort FreeInt < Val .
subsort FreeMap < Map .
subsort FreeMathObj < Builtins .
subsort FreeMathObj < K .
subsort FreeMathObj < KResult .
subsort FreeMathObj < List{MathObj++}.
subsort FreeMathObj < MathObj++ .
subsort FreeMathObj < Set{MathObj++}.
subsort Id < Exp .
subsort Id < K .
subsort Int < Exp .
subsort Int < Int++ .
subsort Int < K .
subsort Int < KResult .
subsort Int < List{MathObj++}.
subsort Int < MathObj .
subsort Int < MathObj++ .
subsort Int < Set{MathObj++}.
subsort Int < Val .
subsort Int++ < Builtins .
subsort Int++ < Exp .
subsort Int++ < K .
subsort Int++ < KResult .
subsort Int++ < List{MathObj++}.
subsort Int++ < MathObj++ .
subsort Int++ < Set{MathObj++}.
subsort Int++ < Val .
subsort MathObj < Builtins .
subsort MathObj < K .
subsort MathObj < KResult .
subsort MathObj < List{MathObj++}.
subsort MathObj < MathObj++ .
subsort MathObj < Set{MathObj++}.
subsort MathObj++ < Builtins .
subsort MathObj++ < K .
subsort MathObj++ < KResult .
subsort MathObj++ < List{MathObj++}.
subsort MathObj++ < Set{MathObj++}.
subsort Nat < Exp .
subsort Nat < Int++ .
subsort Nat < K .
subsort Nat < KResult .
subsort Nat < List{MathObj++}.
subsort Nat < MathObj .
subsort Nat < MathObj++ .
subsort Nat < Set{MathObj++}.
subsort Nat < Val .
subsort NtFormula < Formula .
subsort NzInt < Builtins .
subsort NzInt < Exp .
subsort NzInt < Int++ .
subsort NzInt < K .
subsort NzInt < KResult .
subsort NzInt < List{MathObj++}.
subsort NzInt < MathObj .
subsort NzInt < MathObj++ .
subsort NzInt < Set{MathObj++}.
subsort NzInt < Val .
subsort NzNat < Builtins .
subsort NzNat < Exp .
subsort NzNat < Int .
subsort NzNat < Int++ .
subsort NzNat < K .
subsort NzNat < KResult .
subsort NzNat < List{MathObj++}.
subsort NzNat < MathObj .
subsort NzNat < MathObj++ .
subsort NzNat < Set{MathObj++}.
subsort NzNat < Val .
subsort Stmt < K .
subsort Stmt < Stmts .
subsort Stmts < K .
subsort Subst < Builtins .
subsort SubstItem < Builtins .
subsort SubstItem < Subst .
subsort Truth < Formula .
subsort Val < Exp .
subsort Val < K .
subsort Val < KResult .
subsort Zero < Builtins .
subsort Zero < Exp .
subsort Zero < Int .
subsort Zero < Int++ .
subsort Zero < K .
subsort Zero < KResult .
subsort Zero < List{MathObj++}.
subsort Zero < MathObj .
subsort Zero < MathObj++ .
subsort Zero < Set{MathObj++}.
subsort Zero < Val .
op !Int : Nat -> !Int .
op $hasMapping : Map K -> Bool .
op .List`{MathObj++`} : -> List{MathObj++}.
op .Set`{MathObj++`} : -> Set{MathObj++}.
op .Subst : -> Subst .
op ?Env : Nat -> ?Map .
op ?Heap : Nat -> ?Map .
op ?Int : Nat -> ?Int .
op ?_ : Bool -> Int++ .
op ?n : -> ?Int .
op ?s : -> ?Int .
op FalseFormula : -> Truth .
op NULL : -> Exp .
op T : -> CellLabel .
op TrueFormula : -> Truth .
op VALID : Formula -> Bool .
op _-_ : Bag Bag -> Bag .
op _-_ : Set Set -> Set .
op _:_ : Int++ KLabel -> KResult .
op _<-_ : Bag Bag -> SubstItem .
op _<-_ : List List -> SubstItem .
op _<-_ : Map Map -> SubstItem .
op _<-_ : MathObj++ MathObj++ -> SubstItem .
op _<-_ : Set Set -> SubstItem .
op _===_ : List{MathObj++}List{MathObj++}-> Atom .
op _===_ : MathObj++ MathObj++ -> Atom .
op _==Int_ : Int++ Int++ -> Bool .
op _`(_`)`(_`) : KLabel List{MathObj++}List{MathObj++}-> Map .
op _`[undef/_`] : Map List{K}-> Map .
op _in_ : BagItem Bag -> Bool .
op _in_ : K Bag -> Bool .
op _in_ : K Set -> Bool .
op _in_ : SetItem Set -> Bool .
op _|->_ : List{K}List{K}-> Map .
op `{`} : -> Stmt .
op config : -> CellLabel .
op derive : Int++ -> K .
op env : -> CellLabel .
op errorBag : ->[Bag].
op errorObj : ->[List{MathObj++}].
op feasible : -> CellLabel .
op form : -> CellLabel .
op heap : -> CellLabel .
op infeasible : -> CellLabel .
op isInt : Int -> Bool .
op k : -> CellLabel .
op keys_ : Map -> Set .
op load : Int++ -> Exp .
op mlcheck : KLabel -> Result .
op n : -> Id .
op n0 : -> FreeInt .
op newImpl : -> CellLabel .
op newSym : -> CellLabel .
op pSum : -> Stmts .
op s : -> Id .
op skolem : Nat ?Map -> FreeMap .
op store : Int++ Exp -> Exp .
op subst : -> CellLabel .
op while`(_`)_ : Exp Stmt -> Stmt .
op !_ : Exp -> Exp[prec 5 metadata "strict"].
op *_ : Exp -> Exp[prec 10 metadata "strict"].
op -Int_ : Int++ -> Int++[special(id-hook MinusSymbol op-hook succSymbol(sNat_
    : Nat ~> NzNat)op-hook minusSymbol(-Int_ : NzNat ~> NzInt))].
op -_ : Exp -> Exp[metadata "strict"].
op //`assert_ : Bag -> Annot[strat(0)prec 99].
op //`assume_ : Bag -> Annot[strat(0)prec 99].
op //`invariant_ : Bag -> Annot[strat(0)prec 99].
op //`post_ : Bag -> Annot[strat(0)prec 99].
op //`pre_ : Bag -> Annot[strat(0)prec 99].
op <_>_</_> : CellLabel Formula CellLabel -> BagItem[prec 0 format(nib g b o+
    -b g b o)].
op <_>_</_> : CellLabel Subst CellLabel -> BagItem[prec 0 format(nib g b o+ -b
    g b o)].
op @_ : Bool -> Atom[prec 0].
op _!=_ : Exp Exp -> Exp[prec 35].
op _%Int_ : Int++ Int++ -> Int++[prec 31 gather(E e)special(id-hook
    NumberOpSymbol(rem)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook
    minusSymbol(-Int_ : NzNat ~> NzInt))].
op _%_ : Exp Exp -> Exp[prec 29 gather(E e)metadata "strict"].
op _&&_ : Exp Exp -> Exp[prec 55 gather(E e)metadata "strict(1)"].
op _&_ : Set{MathObj++}Set{MathObj++}-> Set{MathObj++}[assoc comm id:
    .Set`{MathObj++`}].
op _*Int_ : Int++ Int++ -> Int++[assoc comm prec 31 special(id-hook
    ACU_NumberOpSymbol(*)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook
    minusSymbol(-Int_ : NzNat ~> NzInt))].
op _*_ : Exp Exp -> Exp[prec 31 gather(E e)metadata "strict"].
op _+Int_ : Int++ Int++ -> Int++[assoc comm prec 33 special(id-hook
    ACU_NumberOpSymbol(+)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook
    minusSymbol(-Int_ : NzNat ~> NzInt))].
op _+_ : Exp Exp -> Exp[prec 33 gather(E e)metadata "strict"].
op _-Int_ : Int++ Int++ -> Int++[prec 33 gather(E e)special(id-hook
    NumberOpSymbol(-)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook
    minusSymbol(-Int_ : NzNat ~> NzInt))].
op _-_ : Exp Exp -> Exp[prec 33 gather(E e)metadata "strict"].
op _/Int_ : Int++ Int++ -> Int++[prec 31 gather(E e)special(id-hook
    NumberOpSymbol(quo)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook
    minusSymbol(-Int_ : NzNat ~> NzInt))].
op _/\_ : Formula Formula -> Formula[assoc comm id: TrueFormula prec 55].
op _/\_ : NtFormula Formula -> NtFormula[assoc comm id: TrueFormula prec 55].
op _/_ : Exp Exp -> Exp[prec 31 gather(E e)metadata "strict"].
op _; : Exp -> Stmt[prec 60 metadata "strict"].
op _;_ : Subst Subst -> Subst[assoc comm id: .Subst].
op _<=Int_ : Int++ Int++ -> Bool[prec 37 special(id-hook NumberOpSymbol(
    <=)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook minusSymbol(-Int_ :
    NzNat ~> NzInt)term-hook trueTerm(true)term-hook falseTerm(false))].
op _<=_ : Exp Exp -> Exp[prec 35 metadata "strict"].
op _<Int_ : Int++ Int++ -> Bool[prec 37 special(id-hook NumberOpSymbol(
    <)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook minusSymbol(-Int_ : NzNat
    ~> NzInt)term-hook trueTerm(true)term-hook falseTerm(false))].
op _<_ : Exp Exp -> Exp[prec 35 metadata "strict"].
op _===>_ : Bag Bag -> Bag[frozen(1 2)].
op _===>_ : Formula Formula -> NtFormula[prec 61].
op _==_ : Exp Exp -> Exp[prec 35 metadata "strict"].
op _=>_ : Formula Formula -> Formula[prec 125].
op _=>_ : Subst Subst -> Subst[prec 125].
op _=_; : Exp Exp -> Stmt[prec 2 metadata "strict(2)"].
op _>=Int_ : Int++ Int++ -> Bool[prec 37 special(id-hook NumberOpSymbol(
    >=)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook minusSymbol(-Int_ :
    NzNat ~> NzInt)term-hook trueTerm(true)term-hook falseTerm(false))].
op _>=_ : Exp Exp -> Exp[prec 35 metadata "strict"].
op _>Int_ : Int++ Int++ -> Bool[prec 37 special(id-hook NumberOpSymbol(
    >)op-hook succSymbol(sNat_ : Nat ~> NzNat)op-hook minusSymbol(-Int_ : NzNat
    ~> NzInt)term-hook trueTerm(true)term-hook falseTerm(false))].
op _>_ : Exp Exp -> Exp[prec 35 metadata "strict"].
op _?_:_ : Exp Exp Exp -> Exp[prec 59 metadata "strict(1)"].
op _\/_ : Formula Formula -> Formula[assoc comm id: FalseFormula prec 59].
op _\/_ : NtFormula Formula -> NtFormula[assoc comm id: FalseFormula prec 59].
op __ : Stmts Stmts -> Stmts[prec 100 gather(e E)].
op _`(_`) : Map List{K}-> List{K}[prec 0].
op _`,_ : List{MathObj++}List{MathObj++}-> List{MathObj++}[assoc id:
    .List`{MathObj++`}].
op _`[_/_`] : Map List{K}List{K}-> Map[prec 0].
op _`[_`] : Bag Subst -> Bag[strat(2 0)prec 0].
op _`[_`] : Formula Subst -> Formula[strat(2 0)prec 0].
op _`[_`] : Subst Subst -> Subst[strat(2 0)prec 0].
op _feasible`and_infeasible`paths : Nat Nat -> Result[format(g! d d d d d o)].
op _||_ : Exp Exp -> Exp[prec 57 gather(E e)metadata "strict(1)"].
op `[|_`,_`,_|`] : Nat Nat Bag -> Result[strat(0 1 2 3 0)].
op `{_`} : Stmts -> Stmt[gather(&)].
op if`(_`)_ : Exp Stmt -> Stmt[prec 95].
op if`(_`)_else_ : Exp Stmt Stmt -> Stmt[prec 93 metadata "strict(1)"].
op return_ : Exp -> Exp[metadata "strict"].
op skolem : Nat ?Int -> FreeInt[strat(0)].
op skolem : Nat ?MathObj -> FreeMathObj[strat(0)].
op skolemize : Nat Bag -> Bag[strat(0)].
op ~_ : Atom -> Atom[prec 0].
op ~_ : Formula -> NtFormula[prec 0].
mb configuration_(<_>_</_>(T,__(<_>_</_>(feasible,0,feasible),__(<_>_</_>(
    infeasible,0,infeasible),<_>_</_>(config,__(<_>_</_>(k,(.).K,k),__(
    <_>_</_>(subst,(.).K,subst),__(<_>_</_>(newSym,0,newSym),__(<_>_</_>(
    newImpl,0,newImpl),__(<_>_</_>(env,(.).Map,env),__(<_>_</_>(heap,(.).Map,
    heap),<_>_</_>(form,TrueFormula,form))))))),config))),T)): KSentence .
mb context_(_=_;(*_(`[HOLE`]:Exp),?:Exp)): KSentence .
mb rule_(<_>_...</_>(k,_=>_(*_(I:Int++),_~>_(derive(I:Int++),load(I:Int++))),
    k)): KSentence .
mb rule_(<_>_...</_>(k,_=>_(_=_;(*_(I:Int++),V:Val),_~>_(derive(I:Int++),store(
    I:Int++,V:Val))),k)): KSentence .
mb rule_(<_>_</_>(k,_=>_(_~>_(//`invariant_(Cfgs:Bag),_~>_(while`(_`)_(E:Exp,
    S:Stmt),K:K)),_~>_(//`assert_(Cfgs:Bag),_`(_`)('if`(_`)_else_,_`,`,_(E:Exp,
    _`,`,_(`{_`}(__(S:Stmt,//`assert_(Cfgs:Bag))),K:K))))),k)): KSentence .
mb rule_(_=>_(`{`},(.).K)): KSentence .
mb rule_(_=>_(!_(0),1)): KSentence .
mb rule_(_=>_(!_(NzI:NzInt),1)): KSentence .
mb rule_(_=>_(-_(I:Int++),-Int_(I:Int++))): KSentence .
mb rule_(_=>_(<_>..._...</_>(config,<_>_...</_>(k,//`assume_(.),k),config),(
    .).Bag)): KSentence .
mb rule_(_=>_(<_>_</_>(config,__(CfgItems:Bag,__(<_>_</_>(k,_~>_(_?_:_(I:Int++,
    E1:Exp,E2:Exp),K:K),k),<_>_</_>(form,Phi:Formula,form))),config),__(
    <_>_</_>(config,__(CfgItems:Bag,__(<_>_</_>(k,_~>_(E1:Exp,K:K),k),<_>_</_>(
    form,_/\_(Phi:Formula,~_(_===_(I:Int++,0))),form))),config),<_>_</_>(
    config,__(CfgItems:Bag,__(<_>_</_>(k,_~>_(E2:Exp,K:K),k),<_>_</_>(form,
    _/\_(Phi:Formula,_===_(I:Int++,0)),form))),config)))): KSentence .
mb rule_(_=>_(_%_(I1:Int++,I2:Int++),_%Int_(I1:Int++,I2:Int++))): KSentence .
mb rule_(_=>_(_&&_(0,E:Exp),0)): KSentence .
mb rule_(_=>_(_&&_(NzI:NzInt,E:Exp),E:Exp)): KSentence .
mb rule_(_=>_(_*_(I1:Int++,I2:Int++),_*Int_(I1:Int++,I2:Int++))): KSentence .
mb rule_(_=>_(_+_(I1:Int++,I2:Int++),_+Int_(I1:Int++,I2:Int++))): KSentence .
mb rule_(_=>_(_-_(I1:Int++,I2:Int++),_-Int_(I1:Int++,I2:Int++))): KSentence .
mb rule_(_=>_(_/_(I1:Int++,I2:Int++),_/Int_(I1:Int++,I2:Int++))): KSentence .
mb rule_(_=>_(_;(V:Val),(.).K)): KSentence .
mb rule_(_=>_(_<=_(I1:Int++,I2:Int++),?_(_<=Int_(I1:Int++,I2:Int++)))):
    KSentence .
mb rule_(_=>_(_<_(I1:Int++,I2:Int++),?_(_<Int_(I1:Int++,I2:Int++)))): KSentence
    .
mb rule_(_=>_(_==_(I1:Int++,I2:Int++),?_(_==Int_(I1:Int++,I2:Int++)))):
    KSentence .
mb rule_(_=>_(_>=_(I1:Int++,I2:Int++),?_(_>=Int_(I1:Int++,I2:Int++)))):
    KSentence .
mb rule_(_=>_(_>_(I1:Int++,I2:Int++),?_(_>Int_(I1:Int++,I2:Int++)))): KSentence
    .
mb rule_(_=>_(_?_:_(0,E1:Exp,E2:Exp),E2:Exp)): KSentence .
mb rule_(_=>_(_?_:_(NzI:NzInt,E1:Exp,E2:Exp),E1:Exp)): KSentence .
mb rule_(_=>_(__(S1:Stmt,S2:Stmt),_~>_(S1:Stmt,S2:Stmt))): KSentence .
mb rule_(_=>_(_||_(0,E:Exp),E:Exp)): KSentence .
mb rule_(_=>_(_||_(NzI:NzInt,E:Exp),NzI:NzInt)): KSentence .
mb rule_(_=>_(`{_`}(Ss:Stmts),Ss:Stmts)): KSentence .
mb rule_(_=>_(if`(_`)_else_(0,?:Stmt,S:Stmt),S:Stmt)): KSentence .
mb rule_(_=>_(if`(_`)_else_(NzI:NzInt,S:Stmt,?:Stmt),S:Stmt)): KSentence .
mb rule_(__(<_>..._...</_>(env,_|->_(X:Id,V:Val),env),<_>_...</_>(k,_=>_(X:Id,
    V:Val),k))): KSentence .
mb rule_(__(<_>..._...</_>(env,_|->_(X:Id,_=>_(?:List{K},V:Val)),env),
    <_>_...</_>(k,_=>_(_=_;(X:Id,V:Val),(.).K),k))): KSentence .
mb rule_(__(<_>..._...</_>(heap,_|->_(I:Int++,?:List{K}),heap),<_>_...</_>(k,
    _=>_(derive(I:Int++),(.).K),k))): KSentence .
mb rule_(__(<_>..._...</_>(heap,_|->_(I:Int++,V:Val),heap),<_>_...</_>(k,_=>_(
    load(I:Int++),V:Val),k))): KSentence .
mb rule_(__(<_>..._...</_>(heap,_|->_(I:Int++,_=>_(?:List{K},V:Val)),heap),
    <_>_...</_>(k,_=>_(store(I:Int++,V:Val),(.).K),k))): KSentence .
mb rule_(__(_=>_((.).Bag,<_>_</_>(config,__(CfgItems:Bag,__(<_>_</_>(k,K:K,k),
    __(<_>_</_>(subst,Subst:Subst,subst),__(<_>_</_>(newSym,M:Nat,newSym),__(
    <_>_</_>(newImpl,N:Nat,newImpl),<_>_</_>(form,_/\_(Phi:Formula,_`[_`](
    Phi':Formula,Subst:Subst)),form)))))),config)),<_>..._...</_>(config,__(
    <_>_</_>(k,_=>_(_~>_(//`assume_(__(Cfgs:Bag,<_>_</_>(config,__(
    CfgItems:Bag,<_>_</_>(form,Phi':Formula,form)),config))),K:K),_~>_(
    //`assume_(Cfgs:Bag),K:K)),k),__(<_>_</_>(subst,Subst:Subst,subst),__(
    <_>_</_>(newSym,M:Nat,newSym),__(<_>_</_>(newImpl,N:Nat,newImpl),<_>_</_>(
    form,Phi:Formula,form))))),config))): KSentence .
mb rule_if_(<_>_</_>(config,__(_=>_(CfgItems:Bag,skolemize(N:Nat,
    CfgItems:Bag)),__(<_>_</_>(subst,_=>_(Subst:Subst,Subst':Subst),subst),__(
    <_>_</_>(newSym,M:Nat,newSym),__(<_>_</_>(newImpl,_=>_(N:Nat,_+Int_(N:Nat,
    1)),newImpl),<_>_...</_>(k,_=>_(//`assert_(Cfgs:Bag),//`assume_(Cfgs:Bag)),
    k))))),config),search_(_=>_(_===>_(<_>_</_>(config,__(CfgItems:Bag,__(
    <_>_</_>(subst,Subst:Subst,subst),<_>_</_>(newImpl,N:Nat,newImpl))),
    config),Cfgs:Bag),<_>_</_>(config,__(<_>_</_>(subst,Subst':Subst,subst),
    <_>_</_>(form,TrueFormula,form)),config)))): KSentence .
eq NULL = 0 .
eq pSum = __(//`assume_(<_>_</_>(config,__(__(<_>_</_>(heap,(.).Map,heap),
    <_>_</_>(form,@_(_>=Int_(n0,0)),form)),<_>_</_>(env,__(_|->_(n,n0),_|->_(s,
    ?s)),env)),config)),__(_=_;(s,0),__(//`invariant_(<_>_</_>(config,__(__(
    <_>_</_>(heap,(.).Map,heap),<_>_</_>(form,_/\_(@_(_>=Int_(?n,0)),@_(
    _>=Int_(n0,0))),form)),<_>_</_>(env,__(_|->_(n,?n),_|->_(s,_/Int_(_*Int_(
    _+Int_(n0,-Int_(?n)),_+Int_(n0,_+Int_(?n,1))),2))),env)),config)),__(
    while`(_`)_(_>_(n,0),`{_`}(__(_=_;(s,_+_(s,n)),_=_;(n,_-_(n,1))))),
    //`assert_(<_>_</_>(config,__(__(<_>_</_>(heap,(.).Map,heap),<_>_</_>(form,
    @_(_>=Int_(n0,0)),form)),<_>_</_>(env,__(_|->_(n,0),_|->_(s,_/Int_(_*Int_(
    n0,_+Int_(n0,1)),2))),env)),config)))))).
eq $hasMapping(__(M:Map,_|->_(D:K,R:K)),D:K)= true .
eq -Int_(-Int_(I:Int++))= I:Int++ .
eq -Int_(_+Int_(I:Int++,J:Int++))= _+Int_(-Int_(I:Int++),-Int_(J:Int++)).
eq @_(false)= FalseFormula .
eq @_(true)= TrueFormula .
eq @_(_==Int_(I:Int++,J:Int++))= _===_(I:Int++,J:Int++).
eq VALID(TrueFormula)= true .
eq _!=_(E1:Exp,E2:Exp)= !_(_==_(E1:Exp,E2:Exp)).
eq _&_(Obj:MathObj++,Obj:MathObj++)= Obj:MathObj++ .
eq _*Int_(I:Int++,_+Int_(I1:Int++,I2:Int++))= _+Int_(_*Int_(I:Int++,I1:Int++),
    _*Int_(I:Int++,I2:Int++)).
eq _*Int_(I:Int++,1)= I:Int++ .
eq _*Int_(J:Int++,-Int_(I:Int++))= -Int_(_*Int_(I:Int++,J:Int++)).
eq _+Int_(0,I:Int++)= I:Int++ .
eq _+Int_(I:Int++,-Int_(I:Int++))= 0 .
eq _-Int_(I:Int++,J:Int++)= _+Int_(I:Int++,-Int_(J:Int++)).
eq _-_((.).Bag,Bag:Bag)=(.).Bag .
eq _-_((.).Set,Set:Set)=(.).Set .
eq _-_(__(Bag:Bag,BagItem:BagItem),Bag':Bag)= if_then_else_fi(_in_(
    BagItem:BagItem,Bag':Bag),_-_(Bag:Bag,Bag':Bag),__(BagItem:BagItem,_-_(
    Bag:Bag,Bag':Bag))).
eq _-_(__(Set:Set,SetItem:SetItem),Set':Set)= if_then_else_fi(_in_(
    SetItem:SetItem,Set':Set),_-_(Set:Set,Set':Set),__(SetItem:SetItem,_-_(
    Set:Set,Set':Set))).
eq _/\_(FalseFormula,FalseFormula)= FalseFormula .
eq _/\_(FalseFormula,NtPhi:NtFormula)= FalseFormula .
eq _/\_(NtPhi:NtFormula,NtPhi:NtFormula)= NtPhi:NtFormula .
eq _/\_(NtPhi:NtFormula,~_(NtPhi:NtFormula))= FalseFormula .
eq _<=Int_(I:Int++,J:Int++)= _>=Int_(J:Int++,I:Int++).
eq _<Int_(I:Int++,J:Int++)= _>Int_(J:Int++,I:Int++).
eq _===>_(Phi:Formula,FalseFormula)= ~_(Phi:Formula).
eq _===>_(Phi:Formula,TrueFormula)= TrueFormula .
eq _===>_(Phi:Formula,_\/_(NtPhi1:NtFormula,NtPhi2:NtFormula))= _\/_(_===>_(
    Phi:Formula,NtPhi1:NtFormula),_===>_(Phi:Formula,NtPhi2:NtFormula)).
eq _===>_(TrueFormula,Phi:Formula)= Phi:Formula .
eq _===>_(_/\_(Phi1:Formula,Atom:Atom),_/\_(Phi2:Formula,Atom:Atom))= _===>_(
    _/\_(Phi1:Formula,Atom:Atom),Phi2:Formula).
eq _===_(.List`{MathObj++`},.List`{MathObj++`})= TrueFormula .
eq _===_(0,?_(B:Bool))= ~_(@_(B:Bool)).
eq _===_(I:Int,J:Int)= @_(_==Bool_(I:Int,J:Int)).
eq _===_(Obj:MathObj++,Obj:MathObj++)= TrueFormula .
eq _===_(?_(B:Bool),0)= ~_(@_(B:Bool)).
eq _===_(?_(B:Bool),1)= @_(B:Bool).
eq _===_(_+Int_(I:Int++,K:Int++),_+Int_(J:Int++,K:Int++))= _===_(I:Int++,
    J:Int++).
eq _===_(_`,_(Obj1:MathObj++,_`,_(Obj1':MathObj++,ObjList1:List{MathObj++})),
    _`,_(Obj2:MathObj++,_`,_(Obj2':MathObj++,ObjList2:List{MathObj++})))= _/\_(
    _/\_(_===_(Obj1':MathObj++,Obj2':MathObj++),_===_(ObjList1:List{MathObj++},
    ObjList2:List{MathObj++})),_===_(Obj1:MathObj++,Obj2:MathObj++)).
eq _===_(1,?_(B:Bool))= @_(B:Bool).
eq _>Int_(I:Int++,J:Int++)= _>=Int_(_+Int_(I:Int++,-1),J:Int++).
eq _\/_(NtPhi:NtFormula,NtPhi:NtFormula)= NtPhi:NtFormula .
eq _\/_(NtPhi:NtFormula,~_(NtPhi:NtFormula))= TrueFormula .
eq _\/_(TrueFormula,NtPhi:NtFormula)= TrueFormula .
eq _\/_(TrueFormula,TrueFormula)= TrueFormula .
eq _`(_`)(Map:Map,.List`{K`})= .List`{K`} .
eq _`(_`)(Map:Map,_`,`,_(K1:K,NList1:NeList{K}))= _`,`,_(_`(_`)(Map:Map,K1:K),
    _`(_`)(Map:Map,NList1:NeList{K})).
eq _`[_/_`](Map:Map,K2:K,_`,`,_(K1:K,NList1:NeList{K}))= _`[_/_`](_`[_/_`](
    Map:Map,K2:K,K1:K),K2:K,NList1:NeList{K}).
eq _`[_/_`](Map:Map,List:List{K},.List`{K`})= Map:Map .
eq _`[_/_`](Map:Map,_`,`,_(K1:K,NList1:NeList{K}),_`,`,_(K2:K,NList2:NeList{
    K}))= _`[_/_`](_`[_/_`](Map:Map,K1:K,K2:K),NList1:NeList{K},NList2:NeList{
    K}).
eq _`[undef/_`](Map:Map,.List`{K`})= Map:Map .
eq _`[undef/_`](Map:Map,_`,`,_(K1:K,NList1:NeList{K}))= _`[undef/_`](
    _`[undef/_`](Map:Map,K1:K),NList1:NeList{K}).
eq _`[undef/_`](__(Map:Map,_|->_(K1:K,K2:K)),K1:K)= Map:Map .
eq _in_(BagItem:BagItem,__(Bag:Bag,BagItem:BagItem))= true .
eq _in_(K:K,__(Bag:Bag,BagItem(K:K)))= true .
eq _in_(K:K,__(Set:Set,SetItem(K:K)))= true .
eq _in_(SetItem:SetItem,__(Set:Set,SetItem:SetItem))= true .
eq _|->_(.List`{K`},List:List{K})=(.).Map .
eq _|->_(_`,`,_(K1:K,NList1:NeList{K}),K2:K)= __(_|->_(K1:K,K2:K),_|->_(
    NList1:NeList{K},K2:K)).
eq _|->_(_`,`,_(K1:K,NList1:NeList{K}),_`,`,_(K2:K,NList2:NeList{K}))= __(
    _|->_(K1:K,K2:K),_|->_(NList1:NeList{K},NList2:NeList{K})).
eq if`(_`)_(E:Exp,S:Stmt)= if`(_`)_else_(E:Exp,S:Stmt,`{`}).
eq keys_(.)=(.).Set .
eq keys_(__(Map:Map,_|->_(K1:K,K2:K)))= __(SetItem(K1:K),keys_(Map:Map)).
eq mlcheck(K:KLabel)= `[|_`,_`,_|`](0,0,<_>_</_>(T,__(__(<_>_</_>(infeasible,0,
    infeasible),<_>_</_>(config,__(__(__(__(__(__(<_>_</_>(newSym,0,newSym),
    <_>_</_>(newImpl,0,newImpl)),<_>_</_>(subst,.Subst,subst)),<_>_</_>(form,
    TrueFormula,form)),<_>_</_>(heap,(.).Map,heap)),<_>_</_>(env,(.).Map,env)),
    <_>_</_>(k,_`(_`)(K:KLabel,.List`{K`}),k)),config)),<_>_</_>(feasible,0,
    feasible)),T)).
eq ~_(FalseFormula)= TrueFormula .
eq ~_(TrueFormula)= FalseFormula .
eq ~_(@_(_>=Int_(I:Int++,0)))= @_(_>=Int_(_+Int_(-Int_(I:Int++),-1),0)).
eq ~_(~_(Phi:Formula))= Phi:Formula .
ceq _/\_(@_(_>=Int_(I:Int++,0)),@_(_>=Int_(J:Int++,0)))= @_(_>=Int_(I:Int++,
    0))if _>=Int_(_+Int_(J:Int++,-Int_(I:Int++)),0).
ceq _/\_(@_(_>=Int_(I:Int++,0)),@_(_>=Int_(J:Int++,0)))= _===_(I:Int++,0)if
    _==Bool_(_+Int_(I:Int++,J:Int++),0).
ceq _===>_(_/\_(Phi1:Formula,@_(_>=Int_(I:Int++,0))),_/\_(Phi2:Formula,@_(
    _>=Int_(J:Int++,0))))= _===>_(_/\_(Phi1:Formula,@_(_>=Int_(I:Int++,0))),
    Phi2:Formula)if _>=Int_(_+Int_(J:Int++,-Int_(I:Int++)),0).
ceq _===>_(_/\_(Phi1:Formula,_===_(I1:Int++,J1:Int++)),_/\_(Phi2:Formula,_===_(
    I2:Int++,J2:Int++)))= _===>_(_/\_(Phi1:Formula,_===_(I1:Int++,J1:Int++)),
    Phi2:Formula)if _==Bool_(_+Int_(-Int_(I1:Int++),_+Int_(-Int_(I2:Int++),
    _+Int_(J1:Int++,J2:Int++))),0).
ceq _===>_(_/\_(Phi1:Formula,_/\_(@_(_>=Int_(I:Int++,0)),@_(_>=Int_(J:Int++,
    0)))),_/\_(Phi2:Formula,@_(_>=Int_(K:Int++,0))))= _===>_(_/\_(@_(_>=Int_(
    I:Int++,0)),_/\_(Phi1:Formula,@_(_>=Int_(J:Int++,0)))),Phi2:Formula)if
    _>=Int_(_+Int_(-Int_(I:Int++),_+Int_(K:Int++,-Int_(J:Int++))),0).
ceq _>=Int_(I:Int++,J:Int++)= _>=Int_(_+Int_(I:Int++,-Int_(J:Int++)),0)if
    _=/=Bool_(J:Int++,0).
eq $hasMapping(M:Map,D:K)= false[owise].
eq _===>_(_/\_(NtPhi:NtFormula,_\/_(NtPhi1:NtFormula,NtPhi2:NtFormula)),
    NtPhi':NtFormula)= _\/_(_===>_(_/\_(NtPhi:NtFormula,NtPhi1:NtFormula),
    NtPhi':NtFormula),_===>_(_/\_(NtPhi:NtFormula,NtPhi2:NtFormula),
    NtPhi':NtFormula))[owise].
eq _in_(BagItem:BagItem,Bag:Bag)= false[owise].
eq _in_(K:K,Bag:Bag)= false[owise].
eq _in_(K:K,Set:Set)= false[owise].
eq _in_(SetItem:SetItem,Set:Set)= false[owise].
endm
