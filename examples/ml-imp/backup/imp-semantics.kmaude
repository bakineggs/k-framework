load imp-syntax.kmaude

mod UTILS is including PL-INT .
  op isInt : Int -> Bool .
  var I : Int .
---  eq isInt(I) = I :: Int .
endm

kmod IMP-SEMANTICS is including IMP-DESUGARED-SYNTAX + UTILS
---  subsort List{Val} <  KResult . 
---  subsort Stmts List{Exp} < K .
  subsort Val <  KResult
  subsort Stmts Exp < K

  --- vars I I' I1 I2 : Int++
  var NzI : NzInt .
  vars I I' I1 I2 : Int .
  vars N N1 N2 L : Nat .
  vars T T1 T2 : Bool .
  vars F X : Id .
  ---var Xl : List{Id} .
  var V V1 V2 : Val .
  ---var Vl : List{Val} .
  var E E1 E2 : Exp .
  var S S1 S2 : Stmt .
  var Ss : Stmts .
  var K : K .
  --- var Phi : Formula .
  var CfgItems : Bag .


  ops feasible infeasible : -> CellLabel
  ops config k env heap form subst newSym newImpl : -> CellLabel

  configuration <T> 
                  < feasible > 0 </ feasible >
                  < infeasible > 0 </ infeasible >
                  <config>
                    <k> .K </k>
                    <env> .Map </env>
                    <heap> .Map </heap>
                    <form> .K </form>
                    <subst> .K </subst>
                    <newSym> 0 </newSym>
                    <newImpl> 0 </newImpl>
                  </config>
                </T>


  rule I1 + I2 => I1 +Int I2
  rule _-_(I1, I2) => _-Int_(I1, I2)
  rule _*_(I1, I2) => I1 *Int I2
  rule I1 / I2 => I1 /Int I2
  rule I1 % I2 => I1 %Int I2
  rule - I => -Int I
  rule I1 >= I2 => ?_(I1 >=Int I2)
  rule I1 > I2 => ?_(I1 >Int I2)
  rule I1 <= I2 => ?_(I1 <=Int I2)
  rule I1 < I2 => ?_(I1 <Int I2)
  rule I1 == I2 => ?_(I1 ==Int I2)

  rule I && E => (I ? 1 : 0) && E if notBool(isInt(I))
  rule NzI && E => E
  rule 0 && E => 0
---  rule I || E => (I ? 1 : 0) || E if notBool(I :: Int)
  rule NzI || E => NzI
  rule 0 || E => E
---  rule ! I => I ? 0 : 1 if notBool(I :: Int)
  rule ! NzI => 1
  rule ! 0 => 1

  rule
    <config>
      <k> (I ? E1 : E2) ~> K </k>
      CfgItems
    </config>
  =>
    <config>
      <k> E1 ~> K </k>
      CfgItems
    </config>
    <config>
      <k> E2 ~> K </k>
      CfgItems
    </config>
  rule NzI ? E1 : E2 => E1
  rule 0 ? E1 : E2 => E2

  rule V ; => .K
  rule {} => .K
  rule {Ss} => Ss
  rule S1 S2 => S1 ~> S2

  rule
    <k> X => V <_/k> 
    <env_> X |-> V <_/env>
  rule
    <k> X = V ; => .K <_/k>
    <env_> X |-> (_ => V) <_/env>

---
---  mb rule
---    < k > [* I => V] </ k >
---    < heap > </ heap >
---  : KSentence .
---  mb context * [HOLE] = ? ; : KSentence .
---  mb rule
---    < k > [* I = V ; => .K] </ k >
---    < heap > </ heap >
---  : KSentence .
---

---  rule if (I) S1 else S2 => if (I ? 1 : 0) S1 else S2 if notBool(I :: Int)
  rule if (NzI) S else _ => S
  rule if (0) _ else S => S
endkm

