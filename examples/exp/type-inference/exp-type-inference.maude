in ../../../k-prelude
in exp-type-inference-syntax
in ../exp-programs

mod TYPES is including PL-NAT .
  sorts BasicType TypeVar Type .
  subsort BasicType TypeVar < Builtins Type .

  ops int bool : -> BasicType .
  op tvar : Nat -> TypeVar .
  op _->_ : Type Type -> Type [prec 10 gather(e E)] .

  op _+Type_ : TypeVar Nat -> TypeVar .
  eq tvar(N) +Type M = tvar(N +Nat M) .

  op newVars : Type TypeVar -> List{TypeVar} .
  eq newVars(BT,Tv) = .List{TypeVar} .
  eq newVars(tvar(N),tvar(M)) = if N >=Nat M then tvar(N) else .List{TypeVar} fi .
  eq newVars((T1 -> T2), Tv) = mergeVars(newVars(T1,Tv),newVars(T2,Tv)) .

  op vars : Type -> List{TypeVar} .
  eq vars(BT) = .List{TypeVar} .
  eq vars(Tv) = Tv .
  eq vars(T1 -> T2) = mergeVars(vars(T1),vars(T2)) .

  op mergeVars : List{TypeVar} List{TypeVar} -> List{TypeVar} .
  eq mergeVars((Tvl1,Tv,Tvl2),(Tvl1',Tv,Tvl2')) = mergeVars((Tvl1,Tv,Tvl2),(Tvl1',Tvl2')) .
  eq mergeVars(Tvl,Tvl') = Tvl,Tvl' [owise] .

  op _\_ : List{TypeVar} List{TypeVar} -> List{TypeVar} .
  eq (Tvl1,Tv,Tvl2) \ (Tvl1',Tv,Tvl2') = (Tvl1,Tvl2) \ (Tvl1',Tvl2') .
  eq Tvl \ Tvl' = Tvl [owise] .

  op |_| : List{TypeVar} -> Nat .
  eq | Tv,Tvl | = 1 +Nat | Tvl | .
  eq | .List{TypeVar} | = 0 .

  op _from_ : Nat TypeVar -> List{TypeVar} .
  eq 0 from Tv = .List{TypeVar} .
  eq (sNat N) from tvar(M) = tvar(M),(N from tvar(sNat M)) .

--- type substitution: T[Tl / Tvl] substitutes list of type variables Tvl for list of types Tl in T
  op _[_/_] : Type List{Type} List{TypeVar} -> Type [prec 2] .
  eq T[.List{TypeVar} / .List{TypeVar}] = T .
  eq T[T1,T2,Tl / Tv1,Tv2,Tvl] = T[T1 / Tv1][T2,Tl / Tv2,Tvl] .
  eq BT[T / Tv] = BT .
  eq Tv'[T / Tv] = if Tv' ==Bool Tv then T else Tv' fi .
  eq (T1 -> T2)[T / Tv] = T1[T / Tv] -> T2[T / Tv] .

  op typeVar? : Type -> Bool .
  eq typeVar?(tvar(N)) = true .
  eq typeVar?(T) = false [owise] .

  var N M : Nat .  var BT : BasicType .  var Tv Tv' Tv1 Tv2 : TypeVar .
  var T T1 T2 : Type .  var Tvl Tvl' Tvl1 Tvl1' Tvl2 Tvl2' : List{TypeVar} .  var Tl : List{Type} .

----------------------------------------------------------------------------------------
--- Lists of any type should eventually be builtin; for now, we have to declare them ---
----------------------------------------------------------------------------------------
--- List{TypeVar}
  sort List{TypeVar} .
  subsort TypeVar < List{TypeVar} .
  op .List{TypeVar} : -> List{TypeVar} .
  op _,_ : List{TypeVar} List{TypeVar} -> List{TypeVar} [prec 70 assoc id: .List{TypeVar}] .
--- List{Type}
  sort List{Type} .
  subsort Type List{TypeVar} < List{Type} .
  op _,_ : List{Type} List{Type} -> List{Type} [ditto] .
endm

mod EXP-TYPE-INFERENCE-SEMANTICS is including EXP-DESUGARED-SYNTAX + TYPES + K .
--- We need type values/results when we define the type system
  subsort Type < Exp KResult .
  subsort Exp List{Type} < K .

  ops tenv eqns nextType : -> CellLabel .
  mb configuration < T >
                     < k > .K </ k >
                     < tenv > .Map </ tenv >
                     < eqns > .Set </ eqns >
                     < nextType > tvar(0) </ nextType >
                   </ T > : KSentence .

  mb rule < k > [?:Int => int] ...</ k > : KSentence .
  mb rule < k > [?:Bool => bool] ...</ k > : KSentence .
  mb rule < k > [X => T] ...</ k > < tenv >... X |-> T ...</ tenv > : KSentence .
  mb rule < k > [L(T1,,T2) => int] ...</ k > < eqns >... [.Set => T1 = int T2 = int] ...</ eqns > 
       if L ==Bool '_+_ orBool L ==Bool '_-_ orBool L ==Bool '_*_ orBool L ==Bool '_/_ orBool L ==Bool '_%_ : KSentence .
  mb rule < k > [- T => int] ...</ k > < eqns >... [.Set => T = int] ...</ eqns > : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > < eqns >... [.Set => T1 = int T2 = int] ...</ eqns > 
       if L ==Bool '_<_ orBool L ==Bool '_<=_ orBool L ==Bool '_>_ orBool L ==Bool '_>=_ orBool L ==Bool '_==_ orBool L ==Bool '_!=_ : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > < eqns >... [.Set => T1 = bool T2 = bool] ...</ eqns >
       if L ==Bool '_and_ orBool L ==Bool '_or_ : KSentence .
  mb rule < k > [not T => bool] ...</ k > < eqns >... [.Set => T = bool] ...</ eqns > : KSentence .

  op mkFunType : TypeVar -> K .
  mb rule < k > [lambda X . E => E ~> mkFunType(Tv) ~> tenv(TEnv)] ...</ k > < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule [T ~> mkFunType(Tv) => Tv -> T] : KSentence .
  mb rule < k > [T1 T2 => Tv] ...</ k > < eqns >... [.Set => T1 = (T2 -> Tv)] ...</ eqns > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .

  op addEqn : Type -> K .
  mb rule < k > [mu X . E => E ~> addEqn(Tv) ~> tenv(TEnv)] ...</ k > < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule < k > [T ~> addEqn(Tv) => Tv] ...</ k > < eqns >... [.Set => Tv = T] ...</ eqns > : KSentence .

  op let : Type -> K .
  mb rule < k > [let X = T in E => E ~> tenv(TEnv)] ...</ k > < tenv > [TEnv => TEnv[let(T) / X]] </ tenv > : KSentence .
  mb rule < k > [X => (Eqns[T])[|(vars(Eqns[T]) \ vars(Eqns))| from Tv / (vars(Eqns[T]) \ vars(Eqns))]] ...</ k > 
          < tenv >... X |-> let(T) ...</ tenv > < eqns > Eqns </ eqns > < nextType > [Tv => Tv +Type |(vars(Eqns[T]) \ vars(Eqns))|]</ nextType > : KSentence .

  mb rule < k > [if T then T1 else T2 => T1] ...</ k > < eqns >... [.Set => T = bool T1 = T2] ...</ eqns > : KSentence .

---
  var T T1 T2 T' T1' T2' : Type .  var Tv Tv' Tv1 Tv2 Tv1' Tv2' : TypeVar .  var L : KLabel .  var N M : Nat .  var X : Id .  var E E' : Exp .  var TEnv : Map .  var Eqns : Set .
  var BT BT' : BasicType .  var Tvl Tvl' Tvl1 Tvl2 Tvl1' Tvl2' : List{TypeVar} .  var Tl : List{Type} .
--- type environment recovery
  op tenv : Map -> K .
  mb rule < k > T ~> [tenv(TEnv) => .K] ...</ k > < tenv > [? => TEnv] </ tenv > : KSentence [metadata "structural"] .

--- equational constraint solving stuff
  op _=_ : Type Type -> SetItem [prec 30] .

  op fail : -> SetItem .
  eq fail SI:SetItem = fail .
 ceq (BT = BT') = fail if notBool(BT ==Bool BT') .
 ceq (BT = T) = fail if notBool(typeVar?(T)) .
 ceq (T = BT) = fail if notBool(typeVar?(T)) .
 ceq (Tv = T) = fail if Tv in T .

  eq (T = T) = .Set .
  eq ((T1 -> T2) = (T1' -> T2')) = (T1 = T1' T2 = T2') .
 ceq (T = Tv) = (Tv = T) if notBool typeVar?(T) .
  eq (Tv = T Tv = T') = (Tv = T  T = T') .
 ceq (Tv = T Tv' = T') = (Tv = T  Tv' = T'[T / Tv]) if Tv in T' .

  op _in_ : TypeVar Type -> Bool .
  eq Tv in BT = false .
  eq Tv in Tv' = Tv ==Bool Tv' .
  eq Tv in (T1 -> T2) = (Tv in T1) orBool (Tv in T2) .

  op vars : Set -> List{TypeVar} [strat(1 0)] .
  eq vars(.Set) = .List{TypeVar} .
  eq vars((Tv = T) Eqns) = mergeVars(vars(T),vars(Eqns)) .

  op _[_] : Set Type -> Type [strat(1 0)] .
  eq .Set[T] = T .
  eq (Tv = T' Eqns)[T] = Eqns[T[T' / Tv]] .
endm

mod EXP-TYPE-INFERENCE is including EXP-TYPE-INFERENCE-SEMANTICS + EXP-PROGRAMS .
  op solve : -> K .
  var T : Type .  var Eqns : Set .
  op run : KLabel -> Bag .
  eq run(L:KLabel) = run(L:KLabel,.List{K}) .
  op run : KLabel List{K} -> Bag .
  eq run(L:KLabel,L:List{K}) = < T > < k > L:KLabel(.List{K}) ~> solve </ k > < tenv > .Map </ tenv > < eqns > .Set </ eqns > < nextType > tvar(0) </ nextType > </ T > .
  mb rule < k > [T ~> solve => Eqns[T]] </ k > < eqns > Eqns </ eqns > : KSentence .
endm
