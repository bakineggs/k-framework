in ../../../k-prelude
in exp-type-inference-syntax
in ../exp-programs



--- types stuff
mod TYPES is including PL-NAT .
  sorts BasicType TypeVar Type TypeSchema .
  subsort BasicType TypeVar < Builtins Type .
  subsort Type < TypeSchema .

  ops int bool : -> BasicType .
  op tvar : Nat -> TypeVar .
  op _->_ : Type Type -> Type [prec 10 gather(e E)] .
  op forall_._ : List{TypeVar} Type -> TypeSchema .

  var N M : Nat .  var BT : BasicType .  var Tv Tv' Tv1 Tv2 : TypeVar .  var T T1 T2 : Type .
  var Tvl Tvl' Tvl1 Tvl1' Tvl2 Tvl2' : List{TypeVar} .  var Tl : List{Type} .

  op _+Type_ : TypeVar Nat -> TypeVar .
  eq tvar(N) +Type M = tvar(N +Nat M) .

--- free type variables
  op ftv : TypeSchema -> List{TypeVar} .
  eq ftv(BT) = .List{TypeVar} .
  eq ftv(Tv) = Tv .
  eq ftv(T1 -> T2) = mergeVars(ftv(T1),ftv(T2)) .
  eq ftv(forall Tvl . T) = ftv(T) \ Tvl .

  op ftv : List{Type} -> List{TypeVar} .
  eq ftv(.List{TypeVar}) = .List{TypeVar} .
  eq ftv(T1,T2,Tl) = mergeVars(ftv(T1),ftv(T2,Tl)) .

  op mergeVars : List{TypeVar} List{TypeVar} -> List{TypeVar} .
  eq mergeVars((Tvl1,Tv,Tvl2),(Tvl1',Tv,Tvl2')) = mergeVars((Tvl1,Tv,Tvl2),(Tvl1',Tvl2')) .
  eq mergeVars(Tvl,Tvl') = Tvl,Tvl' [owise] .

  op _\_ : List{TypeVar} List{TypeVar} -> List{TypeVar} .
  eq (Tvl1,Tv,Tvl2) \ (Tvl1',Tv,Tvl2') = (Tvl1,Tvl2) \ (Tvl1',Tvl2') .
  eq Tvl \ Tvl' = Tvl [owise] .

  op |_| : List{TypeVar} -> Nat .
  eq | Tv,Tvl | = 1 +Nat | Tvl | .
  eq | .List{TypeVar} | = 0 .

  op _from_ : Nat TypeVar -> List{TypeVar} .
  eq 0 from Tv = .List{TypeVar} .
  eq (sNat N) from tvar(M) = tvar(M),(N from tvar(sNat M)) .

--- type substitution: T[Tl / Tvl] substitutes list of type variables Tvl for list of types Tl in T
  op _[_/_] : Type List{Type} List{TypeVar} -> Type [prec 2] .
  eq T[.List{TypeVar} / .List{TypeVar}] = T .
  eq T[T1,T2,Tl / Tv1,Tv2,Tvl] = T[T1 / Tv1][T2,Tl / Tv2,Tvl] .
  eq BT[T / Tv] = BT .
  eq Tv'[T / Tv] = if Tv' ==Bool Tv then T else Tv' fi .
  eq (T1 -> T2)[T / Tv] = T1[T / Tv] -> T2[T / Tv] .

  op typeVar? : Type -> Bool .
  eq typeVar?(tvar(N)) = true .
  eq typeVar?(T) = false [owise] .  --- if needed, replace with: eq typeVar?(T1 -> T2) = false .  eq typeVar?(BT) = false .

  op _in_ : TypeVar Type -> Bool .
  eq Tv in BT = false .
  eq Tv in Tv' = Tv ==Bool Tv' .
  eq Tv in (T1 -> T2) = (Tv in T1) orBool (Tv in T2) .

----------------------------------------------------------------------------------------
--- Lists of any type should eventually be builtin; for now, we have to declare them ---
----------------------------------------------------------------------------------------
--- List{TypeVar}
  sort List{TypeVar} .
  subsort TypeVar < List{TypeVar} .
  op .List{TypeVar} : -> List{TypeVar} .
  op _,_ : List{TypeVar} List{TypeVar} -> List{TypeVar} [prec 70 assoc id: .List{TypeVar}] .
--- List{Type}
  sort List{Type} .
  subsort Type List{TypeVar} < List{Type} .
  op _,_ : List{Type} List{Type} -> List{Type} [ditto] .
--- List{TypeSchema}
---  sort List{TypeSchema} .
---  subsort TypeSchema List{Type} < List{TypeSchema} .
---  op _,_ : List{TypeSchema} List{TypeSchema} -> List{TypeSchema} [ditto] .
endm



--- equational constraint solving stuff
mod UNIFICATION is including TYPES + K .
  var T T1 T2 T' T1' T2' : Type .  var Tv Tv' : TypeVar .  var Tl : List{Type} .  var Eqns Solved : Set .  var BT BT' : BasicType .

  ops eqn eqns solved started : -> CellLabel .
  op _=_ : Type Type -> SetItem [strat(1 2 0) prec 30] .

  mb [add-constraint] : rule [< eqn > T = T' </ eqn > => .Bag] < started >... [.Set => (Solved[T]) = (Solved[T'])] ...</ started > 
          < solved > Solved </ solved > : KSentence .
  mb [reflexivity] : rule < started >... [(T = T) => .Set] ...</ started > : KSentence .
  mb [constructors] : rule < started >... [(T1 -> T2) = (T1' -> T2') => T1 = T1' T2 = T2'] ...</ started > : KSentence .
  mb [orient] : rule < started >... [T = Tv => Tv = T] ...</ started > if notBool typeVar?(T) : KSentence .
  mb [eqn] : rule < started > [Tv = T Eqns => Eqns[T / Tv]] </ started > < solved > [Solved => Tv = T (Solved[T /right Tv])] </ solved >
               if notBool(Tv in T) : KSentence .

  op _[_/_] : Set Type TypeVar -> Set .
  eq .Set[T / Tv] = .Set .
  eq (T1 = T2 Eqns)[T / Tv] = T1[T / Tv] = T2[T / Tv] (Eqns[T / Tv]) .

  op _[_/right_] : Set Type TypeVar -> Set .
  eq .Set[T /right Tv] = .Set .
  eq (Tv = T Eqns)[T' /right Tv'] = Tv = T[T' / Tv'] (Eqns[T' /right Tv']) .

  op _[_] : Set Type -> Type .
  op _[[_]] : Set List{Type} -> List{Type} .
--- I would like to use the following operation name instead, but K-Maude does not like it ...
---  op _[_] : Set List{Type} -> List{Type} .
  eq .Set[T] = T .
  eq (Tv = T' Eqns)[T] = Eqns[T[T' / Tv]] .
  eq Eqns[[.List{TypeVar}]] = .List{TypeVar} .
  eq Eqns[[T]] = Eqns[T] .
  eq Eqns[[T1,T2,Tl]] = Eqns[T1],Eqns[T2],Eqns[[Tl]] .
endm



--- the actual type inferencer
mod EXP-TYPE-INFERENCE-SEMANTICS is including EXP-DESUGARED-SYNTAX + UNIFICATION + K .
  subsort Type < Exp KResult .
  subsort Exp List{Type} TypeSchema < K .

  ops tenv nextType : -> CellLabel .
  mb configuration < T >
                     < k > .K </ k >
                     < tenv > .Map </ tenv >
                     < eqns > < eqn * > .Set </ eqn * >
                        < started > .Set </ started > 
                        < solved > .Set </ solved > 
                     </ eqns >
                     < nextType > tvar(0) </ nextType >
                   </ T > : KSentence .

  mb rule < k > [?:Int => int] ...</ k > : KSentence .
  mb rule < k > [?:Bool => bool] ...</ k > : KSentence .
  mb rule < k > [X => T] ...</ k > < tenv >... X |-> T ...</ tenv > : KSentence .
  mb rule < k > [L(T1,,T2) => int] ...</ k > [.Bag => < eqn > T1 = int </ eqn > < eqn > T2 = int </ eqn >]
       if L ==Bool '_+_ orBool L ==Bool '_-_ orBool L ==Bool '_*_ orBool L ==Bool '_/_ orBool L ==Bool '_%_ : KSentence .
  mb rule < k > [- T => int] ...</ k > [.Bag => < eqn > T = int </ eqn >] : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > [.Bag => < eqn > T1 = int </ eqn > < eqn > T2 = int </ eqn >]
       if L ==Bool '_<_ orBool L ==Bool '_<=_ orBool L ==Bool '_>_ orBool L ==Bool '_>=_ orBool L ==Bool '_==_ orBool L ==Bool '_!=_ : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > [.Bag => < eqn > T1 = bool </ eqn > < eqn > T2 = bool </ eqn >]
       if L ==Bool '_and_ orBool L ==Bool '_or_ : KSentence .
  mb rule < k > [not T => bool] ...</ k > [.Bag => < eqn > T = bool </ eqn >] : KSentence .

  op mkFunType : TypeVar -> K .
  mb rule < k > [lambda X . E => E ~> mkFunType(Tv) ~> tenv(TEnv)] ...</ k >
          < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule [T ~> mkFunType(Tv) => Tv -> T] : KSentence .
  mb rule < k > [T1 T2 => Tv] ...</ k > [.Bag => < eqn > T1 = (T2 -> Tv) </ eqn >] < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .

  op addEqn : Type -> K .
  mb rule < k > [mu X . E => E ~> addEqn(Tv) ~> tenv(TEnv)] ...</ k >
          < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule < k > [T ~> addEqn(Tv) => Tv] ...</ k > [.Bag => < eqn > Tv = T </ eqn >] : KSentence .

  mb rule < k > [let X = T in E => E ~> tenv(TEnv)] ...</ k > < eqns > < started > .Set </ started > < solved > Eqns </ solved > </ eqns >
          < tenv > [TEnv => TEnv[forall (ftv(Eqns[T]) \ ftv(Eqns[[types(TEnv)]])) . Eqns[T] / X]] </ tenv > : KSentence .

  mb rule < k > [X => T[| Tvl | from Tv / Tvl]] ...</ k > < tenv >... X |-> forall Tvl . T ...</ tenv >
          < nextType > [Tv => Tv +Type | Tvl |]</ nextType > : KSentence .

  mb rule < k > [if T then T1 else T2 => T1] ...</ k > [.Bag => < eqn > T = bool </ eqn > < eqn > T1 = T2 </ eqn >] : KSentence .

------------------------
--- Auxilliary stuff ---
------------------------
  var T T1 T2 T' T1' T2' : Type .  var Tv Tv' Tv1 Tv2 Tv1' Tv2' : TypeVar .  var L : KLabel .  var N M : Nat .  var X : Id .  var E E' : Exp .
  var TEnv : Map .  var Eqns : Set .  var BT BT' : BasicType .  var Tvl Tvl' Tvl1 Tvl2 Tvl1' Tvl2' : List{TypeVar} .  var Tl : List{Type} .

  op tenv : Map -> K .
  mb rule < k > T ~> [tenv(TEnv) => .K] ...</ k > < tenv > [? => TEnv] </ tenv > : KSentence [metadata "structural"] .

--- next should probably be generic in some way, for all maps ...
  op types_ : Map -> List{Type} .
  eq types(.Map) = .List{TypeVar} .
  eq types(X |-> T TEnv) = T,types(TEnv) .
endm

mod EXP-TYPE-INFERENCE is including EXP-TYPE-INFERENCE-SEMANTICS + EXP-PROGRAMS .
  op solve : -> K .
  var T : Type .  var Eqns : Set .
  op run : KLabel -> Bag .
  eq run(L:KLabel) = run(L:KLabel,.List{K}) .
  op run : KLabel List{K} -> Bag .
---- first step: accumulate the type constraints (also partially solving them when creating type schemas)
  eq run(L:KLabel,L:List{K}) = < T > < k > L:KLabel(.List{K}) ~> solve </ k > < tenv > .Map </ tenv >
                 < eqns > < started > .Set </ started > < solved > .Set </ solved > </ eqns > < nextType > tvar(0) </ nextType > </ T > .
--- second step: solve the remaining constraints and apply resulting substitution to the result type
  mb rule < k > [T ~> solve => Eqns[T]] </ k > < eqns > < started > .Set </ started > < solved > Eqns </ solved > </ eqns > : KSentence .
endm
