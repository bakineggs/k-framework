--- this file is not executable in Maude as is
--- it is an "encoding" in Maude syntax of a K semantics
--- it needs to be processed by the K-Maude tool

in ../../k-prelude.maude

mod IMP-SYNTAX is including PL-INT + PL-ID   --- built-in integers and variable identifiers
--- AExp
  sort AExp 
  subsort Id Int < AExp 
  op _+_ : AExp AExp -> AExp [prec 33 gather (E e) format(d b o d) strict] 
  op _/_ : AExp AExp -> AExp [prec 31 gather (E e) format(d b o d) strict] 
--- BExp
  sort BExp 
  subsort Bool < BExp 
  op _<=_ : AExp AExp -> BExp  [prec 37 format(d b o d) seqstrict] 
  op not_ : BExp -> BExp [prec 53 format(b o d) strict] 
  op _and_ : BExp BExp -> BExp [prec 55 format(d b o d) strict(1)] 
--- Stmt
  sort Stmt 
  op skip ; : -> Stmt [format (b d o)] 
  op _=_; : Id AExp -> Stmt [prec 40 format(d b o b o) strict(2)] 
  op __ : Stmt Stmt -> Stmt [prec 60 gather (e E) format (d noi d)] 
  op if_then_else_ : BExp Stmt Stmt -> Stmt [prec 59 format (b o bni n++i bn--i n++i --) strict(1)] 
  op while_do_ : BExp Stmt -> Stmt [prec 59 format (b o b n++i --)] 
--- Pgm
  sort Pgm   sort List{Id}   subsort Id < List{Id} 
  op .List{Id} : -> List{Id}   op _`,_ : List{Id} List{Id} -> List{Id} [assoc id: .List{Id}] 
  op var_;_ : List{Id} Stmt -> Pgm [prec 70 format (nb o d ni d)] 
endm

mod IMP-PROGRAMS is including IMP-SYNTAX 
  ops a b c d e f g h i j k l m n o p q r s t u v w x y z : -> Id 
  ops sumPgm collatzPgm countPrimesPgm : -> Pgm 
  ops collatzStmt multiplicationStmt primalityStmt : -> Stmt 
eq sumPgm = (
     var n, s ;
     n = 10 ;
     s = 0 ;
     while not(n <= 0) do (
       s = s + n ;
       n = n + -1 ;
     )
) 

eq collatzStmt = (
     while not (n <= 1) do (
       s = s + 1 ;
       q = n / 2 ;
       r = q + q + 1 ;
       if r <= n
         then n = n + n + n + 1 ; else n = q ;
     )
) 

eq collatzPgm = (
   var m, n, q, r, s ;
   m = 5 ;
   s = 0 ;
   while not (m <= 2) do (
     n = m ;
     m = m + -1 ;
     collatzStmt
   )
) 

--- fast multiplication (base 2) algorithm
eq multiplicationStmt = ( 
  z = 0 ;
  while not(x <= 0) do (
    q = x / 2 ;
    r = q + q + 1 ;
    if r <= x then z = z + y ;
    else skip ;
    x = q ;
    y = y + y ;
  )
) 

eq primalityStmt = (
  i = 2 ;
  q = n / i ;
  t = 1 ;
  while (i <= q and 1 <= t) do (
    x = i ;
    y = q ;
    multiplicationStmt 
    if n <= z then t = 0 ; else (
      i = i + 1 ;
      q = n / i ;
    )
  )
) 

eq countPrimesPgm = (
   var i, m, n, q, r, s, t, x, y, z ;
   m = 10 ;
   s = 0 ; n = 2 ;
   while n <= m do (
     primalityStmt 
     if 1 <= t then s = s + 1 ; else skip ;
     n = n + 1 ;
   )
) 
endm

mod IMP-SEMANTICS is
  including IMP-SYNTAX 
  including K                      --- defines K, List, Map, and Set

  subsort AExp BExp Stmt Pgm List{Id} < K 
  subsorts Int Bool < KResult 

  kvars I I1 I2 : Int   kvar T : Bool   kvar X : Id   kvar Sigma : Map 
  kvar B : BExp   kvar S S1 S2 : Stmt   kvar Xl : List{Id}   kvar K : K 

  configuration <T> <k> K </k> <state> (.).Map </state> </T> 

  rule <k>  X => I  <_/k> <state_> X |-> I <_/state> 
  rule I1 + I2 => I1 +Int I2  
  rule I1 / I2 => I1 /Int I2  if I2 =/=Bool 0 
  rule I1 <= I2 => I1 <=Int I2  
  rule not(T) => notBool T  
  rule true and B => B  
  rule false and  _  => false  
  rule skip ; => .
  rule <k>  X = I ; => .  <_/k> <state_> X |->  ( _  => I)  <_/state> 
  rule S1 S2 => S1 ~> S2  
  rule if true then S else  _  => S 
  rule if false then  _  else S => S  
  rule <k>  while B do S  => if B then (S while B do S) else skip ; <_/k> 
  rule <k>  var Xl ; S => S  </k> <state_>  . => getList{K}(Xl) |-> 0  <_/state> [structural] 
endm

mod IMP is including IMP-PROGRAMS + IMP-SEMANTICS 
  op `[`[_`]`] : KLabel -> Bag 
  eq [[K:KLabel]] = <T_> <k> K:KLabel(.List{K}) </k> <_/T> 
  op pgm : -> Bag   eq pgm = [['sumPgm]] 
endm
