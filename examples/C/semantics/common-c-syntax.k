kmod COMMON-C-SYNTAX is
	including PL-BOOL
	including PL-EXT-BOOL
	including PL-NAT
	including PL-INT
	including PL-RAT
	including PL-FLOAT
	including PL-STRING
	including PL-CONVERSION
	including PL-QID
	including PL-RANDOM
	including PL-ID
	
	--- op NULL : -> Id [ctor]
	--- op calloc : -> Id [ctor]
	--- op cos : -> Id [ctor]
	--- op sin : -> Id [ctor]
	--- op exit : -> Id [ctor]
	--- op free : -> Id [ctor]
	--- op main : -> Id [ctor]
	--- op malloc : -> Id [ctor]
	--- op printf : -> Id [ctor]
	--- op putchar : -> Id [ctor]
	--- op rand : -> Id [ctor]
	--- op sqrt : -> Id [ctor]
	--- op abort : -> Id [ctor]
	--- op debug : -> Id [ctor]
	--- op getchar : -> Id [ctor]
	--- op exp : -> Id [ctor]
	--- op log : -> Id [ctor]
	--- op atan : -> Id [ctor]
	--- op File-Scope : -> Id [ctor]
	
	--- op fslOpenFile : -> Id [ctor]
	--- op fslCloseFile : -> Id [ctor]
	--- op fslFGetC : -> Id [ctor]
	--- op fslPutc : -> Id [ctor]
	
	--- op longjmp : -> Id [ctor]
	--- op setjmp : -> Id [ctor]
	--- op floor : -> Id [ctor]
	--- op tan : -> Id [ctor]
	--- op fmod : -> Id [ctor]
	--- op atan2 : -> Id [ctor]
	--- op asin : -> Id [ctor]
	
	--- op spawn : -> Id [ctor]
	--- op sync : -> Id [ctor]
	--- op lock : -> Id [ctor]
	--- op unlock : -> Id [ctor]
	
	sort CabsLoc
	sort TypeSpecifier
	sort Storage
	sort FunSpecifier
	sort CVSpecifier
	sort SpecifierElem
	sort Specifier
	sort DeclType
	sort NameGroup
	sort FieldGroup
	sort InitNameGroup
	sort Name
	sort InitName
	sort SingleName
	sort EnumItem
	sort Definition
	sort Block
	sort AsmDetails
	sort Statement
	sort PureStatement
	sort ForClause
	sort BinaryOperator
	sort UnaryOperator
	sort Expression
	sort Constant
	sort InitExpression
	sort InitWhat
	sort Attribute
	sort Program
	sort IntConstant
	sort InitFragment
	sort FieldName
	
	sort C
	sort List{C} 
	
	--- subsort List{C} < Specifier
	
	subsort CabsLoc < C
	subsort TypeSpecifier < C
	subsort Storage < C
	subsort FunSpecifier < C
	subsort CVSpecifier < C
	subsort SpecifierElem < C
	subsort Specifier < C
	subsort DeclType < C
	subsort NameGroup < C
	subsort FieldGroup < C
	subsort InitNameGroup < C
	subsort Name < C
	subsort InitName < C
	subsort SingleName < C
	subsort EnumItem < C
	subsort Definition < C
	subsort Block < C
	subsort AsmDetails < C
	subsort Statement < C
	subsort PureStatement < C
	subsort ForClause < C
	subsort BinaryOperator < C
	subsort UnaryOperator < C
	subsort Expression < C
	subsort Constant < C
	subsort InitExpression < C
	subsort InitWhat < C
	subsort Attribute < C
	subsort Program < C
	subsort IntConstant < C
	subsort InitFragment < C
	subsort FieldName < C
	
	op Nil : -> List{C}
	subsort C < List{C}
	op _::_ : List{C} List{C} -> List{C} [assoc id: Nil] --- format(++nio d d o--)

--- -----------------------------------------------------------------------------
--- Below, I give the declaration as found in cabs.ml first, followed by the K version
	
***(
type cabsloc = {
		lineno : int;
		filename: string;
		byteno: int;
		ident : int;
	}
***)
	op CabsLoc : String Int Int Int -> CabsLoc
	
***(
type typeSpecifier = (* Merge all specifiers into one type *)
	Tvoid                             (* Type specifier ISO 6.7.2 *)
	| Tchar
	| Tbool
	| Tshort
	| Tint
	| Tlong
	| Tint64
	| Tfloat
	| Tdouble
	| Tsigned
	| Tunsigned
	| Tnamed of string
***)
	ops Void Char Bool Short Int Long Float Double Signed Unsigned : -> TypeSpecifier [ctor]
	op Named : Id -> TypeSpecifier [ctor]
***(
	(* each of the following three kinds of specifiers contains a field 
	* or item list iff it corresponds to a definition (as opposed to
	* a forward declaration or simple reference to the type); they
	* also have a list of __attribute__s that appeared between the
	* keyword and the type name (definitions only) *)
	| Tstruct of string * field_group list option * attribute list
	| Tunion of string * field_group list option * attribute list
	| Tenum of string * enum_item list option * attribute list
	| TtypeofE of expression                      (* GCC __typeof__ *)
	| TtypeofT of specifier * decl_type       (* GCC __typeof__ *)
***)	
	op StructRef : Id List{C} -> TypeSpecifier [ctor]
	op StructDef : Id List{C} List{C} -> TypeSpecifier [ctor]
	op UnionRef : Id List{C} -> TypeSpecifier [ctor]
	op UnionDef : Id List{C} List{C} -> TypeSpecifier [ctor]
	op EnumRef : Id List{C} -> TypeSpecifier [ctor]
	op EnumDef : Id List{C} List{C} -> TypeSpecifier [ctor]
	op TypeOfE : Expression -> TypeSpecifier [ctor]
	op TypeOfT : Specifier DeclType -> TypeSpecifier [ctor]

***(
and storage =
	NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER
***)
	ops NoStorage Auto Static Extern Register : -> Storage [ctor]
	
***(
and funspec = 
	INLINE | VIRTUAL | EXPLICIT
***)
	--- Not sure what this is from, maybe C++?  It's not used elsewhere in cabs.
	
***(
and cvspec =
	CV_CONST | CV_VOLATILE | CV_RESTRICT
***)
	ops Const Volatile Restrict : -> CVSpecifier
	
***(
and spec_elem =
	SpecTypedef          
	| SpecCV of cvspec            (* const/volatile *)
	| SpecAttr of attribute       (* __attribute__ *)
	| SpecStorage of storage
	| SpecInline
	| SpecType of typeSpecifier
	| SpecPattern of string       (* specifier pattern variable *)
***)
	op SpecTypedef : -> SpecifierElem
	--- the following are because I flattened SpecifierElem
	subsort CVSpecifier < SpecifierElem
	subsort Attribute < SpecifierElem
	subsort Storage < SpecifierElem
	op Inline : -> SpecifierElem
	subsort TypeSpecifier < SpecifierElem
	--- TODO not representing SpecPattern
	
***(
	and specifier = spec_elem list
***)
	op Specifier : List{C} -> Specifier
	
***(
and decl_type =
	| JUSTBASE		(* Prints the declared name *)
	| PARENTYPE of attribute list * decl_type * attribute list
			(* Prints "(attrs1 decl attrs2)".
			 * attrs2 are attributes of the
			 * declared identifier and it is as
			 * if they appeared at the very end
			 * of the declarator. attrs1 can
			 * contain attributes for the
			 * identifier or attributes for the
			 * enclosing type.  *)
	| ARRAY of decl_type * attribute list * expression
			(* Prints "decl [ attrs exp ]".
			 * decl is never a PTR. *)
	| PTR of attribute list * decl_type      (* Prints "* attrs decl" *)
	| PROTO of decl_type * single_name list * bool 
			(* Prints "decl (args[, ...])".
			 * decl is never a PTR.*)
***)
	op JustBase : -> DeclType
	op ParenType : List{C} DeclType List{C} -> DeclType
	op Array : DeclType List{C} Expression -> DeclType
	op PointerType : List{C} DeclType -> DeclType
	op Prototype : DeclType List{C} Bool -> DeclType
	
***(
and name_group = specifier * name list
***)
	op NameGroup : Specifier List{C} -> NameGroup
	
***(
	(* The optional expression is the bitfield *)
and field_group = specifier * (name * expression option) list
***)
	op FieldName : Name -> FieldName
	op BitFieldName : Name Expression -> FieldName
	op FieldGroup : Specifier List{C} -> FieldGroup
	
***(
	(* like name_group, except the declared variables are allowed to have initializers *)
	(* e.g.: int x=1, y=2; *)
and init_name_group = specifier * init_name list
***)
	op InitNameGroup : Specifier List{C} -> InitNameGroup
	
***(
	(* The decl_type is in the order in which they are printed. Only the name of
	 * the declared identifier is pulled out. The attributes are those that are
	 * printed after the declarator *)
	(* e.g: in "int *x", "*x" is the declarator; "x" will be pulled out as *)
	(* the string, and decl_type will be PTR([], JUSTBASE) *)
and name = string * decl_type * attribute list * cabsloc
***)
	op Name : Id DeclType List{C} CabsLoc -> Name
	op #NoName : -> Id
	op Identifier : String -> Id	

***(
	(* A variable declarator ("name") with an initializer *)
and init_name = name * init_expression
***)
	op InitName : Name InitExpression -> InitName
	
***(
	(* Single names are for declarations that cannot come in groups, like
	 * function parameters and functions *)
and single_name = specifier * name
***)
	op SingleName : Specifier Name -> SingleName
	
***(
and enum_item = string * expression * cabsloc
***)
	op EnumItem : Id Expression CabsLoc -> EnumItem
		
***(
	(*
	** Declaration definition (at toplevel)
	*)
	and definition =
	   FUNDEF of single_name * block * cabsloc * cabsloc
	 | DECDEF of init_name_group * cabsloc        (* global variable(s), or function prototype *)
	 | TYPEDEF of name_group * cabsloc
	 | ONLYTYPEDEF of specifier * cabsloc
	 | GLOBASM of string * cabsloc
	 | PRAGMA of expression * cabsloc
	 | LINKAGE of string * cabsloc * definition list (* extern "C" { ... } *)
	 (* toplevel form transformer, from the first definition to the *)
	 (* second group of definitions *)
	 | TRANSFORMER of definition * definition list * cabsloc
	 (* expression transformer: source and destination *)
	 | EXPRTRANSFORMER of expression * expression * cabsloc
***)
	op FunDef : SingleName Block CabsLoc CabsLoc -> Definition
	op DecDef : InitNameGroup CabsLoc -> Definition
	op TypeDef : NameGroup CabsLoc -> Definition
	op OnlyTypeDef : Specifier CabsLoc -> Definition
	op GlobAsm : String CabsLoc -> Definition
	op Pragma : Expression CabsLoc -> Definition
	op Linkage : String CabsLoc List{C} -> Definition
	op Transformer : Definition List{C} CabsLoc -> Definition
	op ExpressionTransformer : Expression Expression CabsLoc -> Definition

***(
(* the string is a file name, and then the list of toplevel forms *)
and file = string * definition list
***)
	op Program : List{C} -> Program

***(
	(* A block contains a list of local label declarations ( GCC's ({ __label__ 
	 * l1, l2; ... }) ) , a list of definitions and a list of statements  *)
and block = 
	{ blabels: string list;
	  battrs: attribute list;
	  bstmts: statement list
	} 
***)
	op Block : List{C} List{C} List{C} -> Block
	
***(
	(* GCC asm directives have lots of extra information to guide the optimizer *)
and asm_details =
	{ aoutputs: (string option * string * expression) list; 
	(* optional name, constraints and expressions for outputs *)
	ainputs: (string option * string * expression) list; 
	(* optional name, constraints and expressions for inputs *)
	aclobbers: string list 
	(* clobbered registers *)
	}
***)
	--- TODO

***(
and statement =
	NOP of cabsloc
	| COMPUTATION of expression * cabsloc
	| BLOCK of block * cabsloc
	| SEQUENCE of statement * statement * cabsloc
***)
	op Nop : -> PureStatement
	op Computation : Expression -> PureStatement
	op BlockStatement : Block -> PureStatement
	op Sequence : Statement Statement -> PureStatement
***(
	| IF of expression * statement * statement * cabsloc
	| WHILE of expression * statement * cabsloc
	| DOWHILE of expression * statement * cabsloc
	| FOR of for_clause * expression * expression * statement * cabsloc
***)
	op IfThenElse : Expression Statement Statement -> PureStatement
	op While : Expression Statement -> PureStatement
	op DoWhile : Expression Statement -> PureStatement
	op For : ForClause Expression Expression Statement -> PureStatement
***(
	| BREAK of cabsloc
	| CONTINUE of cabsloc
	| RETURN of expression * cabsloc
***)
	op Break : -> PureStatement
	op Continue : -> PureStatement
	op Return : Expression -> PureStatement
***(
	| SWITCH of expression * statement * cabsloc
	| CASE of expression * statement * cabsloc
	| CASERANGE of expression * expression * statement * cabsloc
	| DEFAULT of statement * cabsloc
***)
	op Switch : Expression Statement -> PureStatement
	op Case : Expression Statement -> PureStatement
	op CaseRange : Expression Expression Statement -> PureStatement
	op Default : Statement -> PureStatement
***(
	| LABEL of string * statement * cabsloc
	| GOTO of string * cabsloc
	| COMPGOTO of expression * cabsloc (* GCC's "goto *exp" *)
	| DEFINITION of definition (*definition or declaration of a variable or type*)
***)
	op Label : Id Statement -> PureStatement
	op Goto : Id -> PureStatement
	op CompGoto : Expression -> PureStatement
	op Definition : Definition -> PureStatement
***(
	| ASM of attribute list * (* typically only volatile and const *)
		  string list * (* template *)
		  asm_details option * (* extra details to guide GCC's optimizer *)
		  cabsloc
	| TRY_EXCEPT of block * expression * block * cabsloc
	| TRY_FINALLY of block * block * cabsloc
***)
	--- TODO not handling Asm
	op TryExcept : Block Expression Block -> PureStatement
	op TryFinally : Block Block -> PureStatement
	
	--- this wraps all statements with their location in the original file
	op StatementLoc : PureStatement CabsLoc -> Statement
	
***(
and for_clause = 
	FC_EXP of expression
	| FC_DECL of definition
***)
	op ForClauseExpression : Expression -> ForClause
	op ForClauseDeclaration : Definition -> ForClause
	
***(
and binary_operator =
	ADD | SUB | MUL | DIV | MOD
	| AND | OR
	| BAND | BOR | XOR | SHL | SHR
	| EQ | NE | LT | GT | LE | GE
	| ASSIGN
	| ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN
	| BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN
  
and expression =
	NOTHING
***)
	op NothingExpression : -> Expression
***(
	| UNARY of unary_operator * expression

and unary_operator =
	MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF
	| PREINCR | PREDECR | POSINCR | POSDECR
***)
	op -_ : Expression -> Expression [prec 22]
	op +_ : Expression -> Expression [prec 22]
	op !_ : Expression -> Expression [prec 22]
	op ~_ : Expression -> Expression [prec 22]
	op *_ : Expression -> Expression [prec 22]
	op &_ : Expression -> Expression [prec 22]
	op ++_ : Expression -> Expression [prec 22]
	op --_ : Expression -> Expression [prec 22]
	op _++ : Expression -> Expression
	op _-- : Expression -> Expression

***(
	| LABELADDR of string  (* GCC's && Label *)
***)
	--- TODO not handling && Label
***(
	| BINARY of binary_operator * expression * expression
***)
	ops _*_ _/_ _%_ : Expression Expression -> Expression [prec 31 gather(E e) strict]
	ops _+_ _-_ : Expression Expression -> Expression [prec 33 gather(E e) strict]
	ops _<<_ : Expression Expression -> Expression [prec 35 gather(E e) strict]
	ops _>>_ : Expression Expression -> Expression [prec 35 gather(E e) strict]
	ops _<_ _<=_ : Expression Expression -> Expression [prec 37 gather(E e) strict]
	ops _>_ _>=_ : Expression Expression -> Expression [prec 37 gather(E e) strict]
	ops _==_ _!=_ : Expression Expression -> Expression [prec 39 gather(E e) strict]
	op _&_ : Expression Expression -> Expression [prec 41 gather(E e) strict]
	op _^_ : Expression Expression -> Expression [prec 43 gather(E e) strict]
	op _|_ : Expression Expression -> Expression [prec 45 gather(E e) strict]
	op _&&_ : Expression Expression -> Expression [prec 47 gather(E e) strict(1)]
	op _||_ : Expression Expression -> Expression [prec 49 gather(E e) strict(1)]
	
	ops _*=_ _/=_ _%=_ _+=_ _-=_ _<<=_ _&=_ _^=_ _|=_ : Expression Expression -> Expression [prec 53]
	ops _>>=_ : Expression Expression -> Expression [prec 53]
	op _:=_ : Expression Expression -> Expression [prec 53 strict(2)]
***(
	| QUESTION of expression * expression * expression
***)
	op _?_:_ : Expression Expression Expression -> Expression [prec 51 gather(e & E)]
***(
	(* A CAST can actually be a constructor expression *)
	| CAST of (specifier * decl_type) * init_expression
***)
	op Cast : Specifier DeclType InitExpression -> Expression [strict]
***(
	(* There is a special form of CALL in which the function called is
	   __builtin_va_arg and the second argument is sizeof(T). This 
	   should be printed as just T *)
	| CALL of expression * expression list
***)
	op Call : Expression List{C} -> Expression
***(
	| COMMA of expression list
***)
	op Comma : List{C} -> Expression
***(
	| CONSTANT of constant
	| PAREN of expression
	| VARIABLE of string
***)
	op Constant : Constant -> Expression
	--- for paren, just putting parentheses
	op Variable : Id -> Expression
***(
	| EXPR_SIZEOF of expression
	| TYPE_SIZEOF of specifier * decl_type
	| EXPR_ALIGNOF of expression
	| TYPE_ALIGNOF of specifier * decl_type
***)
	op SizeofExpression : Expression -> Expression
	op SizeofType : Specifier DeclType -> Expression
	op AlignofExpression : Expression -> Expression
	op AlignofType : Specifier DeclType -> Expression
***(
	| INDEX of expression * expression
***)
	op ArrayIndex : Expression Expression -> Expression
***(
	| MEMBEROF of expression * string
	| MEMBEROFPTR of expression * string
***)
	op Dot : Expression Id -> Expression
	op Arrow : Expression Id -> Expression
***(
	| GNU_BODY of block
	| EXPR_PATTERN of string     (* pattern variable, and name *)
***)
	op GnuBody : Block -> Expression
	op ExpressionPattern : String -> Expression
	
***(
and constant =
	| CONST_INT of string   (* the textual representation *)
	| CONST_FLOAT of string (* the textual representaton *)
	| CONST_CHAR of int64 list
	| CONST_WCHAR of int64 list
	| CONST_STRING of string
	| CONST_WSTRING of int64 list 
***)
	op DecimalConstant : Int -> IntConstant
	op OctalConstant : Int -> IntConstant
	op HexConstant : String -> IntConstant
	
	op IntLiteral : IntConstant -> Constant
	op FloatLiteral : Float -> Constant
	op CharLiteral : Int -> Constant
	op WCharLiteral : Int -> Constant
	op StringLiteral : String -> Constant
	op WStringLiteral : List{C} -> Constant
	

***(
and init_expression =
  | NO_INIT
  | SINGLE_INIT of expression
  | COMPOUND_INIT of (initwhat * init_expression) list
***)
	op NoInit : -> InitExpression
	op SingleInit : Expression -> InitExpression
	op CompoundInit : List{C} -> InitExpression
	op InitFragment : InitWhat InitExpression -> InitFragment
	
***(
and initwhat =
	NEXT_INIT
	| INFIELD_INIT of string * initwhat
	| ATINDEX_INIT of expression * initwhat
	| ATINDEXRANGE_INIT of expression * expression
***)
	op NextInit : -> InitWhat
	op InFieldInit : Id InitWhat -> InitWhat
	op AtIndexInit : Expression InitWhat -> InitWhat
	op AtIndexRangeInit : Expression Expression -> InitWhat
	
***(
and attribute = string * expression list
***)
	op Attribute : String List{C} -> Attribute
	


endkm
