in ../../../../k-prelude
in simple-typed-static-syntax.kmaude
in ../simple-typed-programs

kmod SIMPLE-TYPED-STATIC-SEMANTICS is including SIMPLE-TYPED-STATIC-DESUGARED-SYNTAX + K 
  subsort List{Type} < List{Exp} KResult 
  subsort Type < Exp Stmt 
  op stmt : -> Type 

  subsorts Stmts List{Exp} List{IdType} < K 

  configuration <T> 
                     <k> .K </k>
                     <tenv> .Map </tenv>
                     <return> stmt </return>
                     <gtenv> .Map </gtenv>
                   </T> 

--- first pass: collect function prototypes in gtenv 
  rule <T> <k> S:Stmt ~> (.K => doneGlobals ~> S) </k> 
           (.Bag => <gtenv> .Map </gtenv>) </T> 
  op doneGlobals : -> K   --- to mark when the collection of globals completed
  rule <k> var X:Id : T:Type ; => stmt <_/k> <gtenv> TEnv => TEnv[T / X] </gtenv> 
  rule <k> function F:Id(XTl:List`{IdType`}) : T S => stmt <_/k> <gtenv> TEnv => TEnv[typeList(XTl) -> T / F] </gtenv> [structural] 

--- when we are done with the first pass (doneGlobals mark), replace gtenv by tenv and start typing the bodies of functions
  rule <T> <k> stmt ~> doneGlobals => .K <_/k> 
            ( <gtenv> TEnv </gtenv> 
           => <tenv> TEnv </tenv> <return> void </return>) 
          </T> 

  rule I:Int => int 
  rule B:Bool => bool 
  rule <k> X => T <_/k> <tenv_> X |-> T <_/tenv> 
  rule <k> ++ X => int <_/k> <tenv_> X |-> int <_/tenv> 
  rule int + int => int 
  rule _-_(int,int) => int 
  rule int * int => int 
  rule int / int => int 
  rule int % int => int 
  rule - int => int 
  rule int < int => bool 
  rule int <= int => bool 
  rule int > int => bool 
  rule int >= int => bool 
  rule T == T => bool 
  rule T != T => bool 
  rule bool and bool => bool 
  rule bool or bool => bool 
  rule not(bool) => bool 
  rule _`[`](T)[int] => T 
  rule sizeOf(T []) => int 
  rule <k> var X : T ; => stmt <_/k> <tenv> TEnv:Map => TEnv[T / X] </tenv> 
  context var X[[HOLE]] : T ; 
  rule <k> var X[int] : _`[`](T) ; => stmt <_/k> <tenv> TEnv => TEnv[_`[`](T) / X] </tenv> 
  rule {} => stmt 
  op tenv : Map -> K 
  rule <k> {S} => S ~> tenv(TEnv) <_/k> 
          <tenv> TEnv </tenv> 
  rule <k> stmt ~> (tenv(TEnv) => .K) <_/k> 
          <tenv> _ => TEnv </tenv> 
  rule stmt stmt => stmt 
  rule <k> X = T ; => stmt <_/k> <tenv_> X |-> T <_/tenv>  
  context _[[HOLE]] = _ ; 
  context [HOLE][_] = _ ; 
  rule _`[`](T)[int] = T ; => stmt 
  rule T ; => stmt 
  rule if bool then stmt else stmt => stmt 
  rule while bool do stmt  => stmt 

  rule <k> function F(XTl) : T S => S ~> tenv(TEnv)<_/k> 
          <tenv> TEnv => TEnv[getList{K}(typeList(XTl)) / getList{K}(idList(XTl))] </tenv> 
          <return> _ => T </return> 
  op tenv : Map -> K 
  rule <k> stmt ~> (tenv(TEnv) => .K)<_/k> 
          <tenv> _ => TEnv </tenv> . 
  rule _`(_`)(Tl:List`{Type`} -> T,Tl) => T 
  rule <k> return(T); => stmt <_/k> <return> T </return> 
  rule read() => int 
  rule write(int) ; => stmt   

--- auxilliary
--- List{Id}
  sort List{Id} 
  subsort Id List{Bottom} < List{Id} < List{Exp} 
  op _`,_ : List{Id} List{Id} -> List{Id} [ditto] 

  op idList : List{IdType} -> List{Id} 
  eq idList(.List{Bottom}) = .List{Bottom} 
  eq idList(X : T,XTl) = X,idList(XTl) 

  op typeList : List{IdType} -> List{Type} 
  eq typeList(.List{Bottom}) = .List{Bottom} 
  eq typeList(X : T,XTl) = T,typeList(XTl) 
endkm

kmod SIMPLE-TYPED-STATIC is including SIMPLE-TYPED-STATIC-SEMANTICS + SIMPLE-TYPED-PROGRAMS 
  op run : KLabel -> Bag 
  eq run(K:KLabel) = <T>
             <k> K(.List{K}) </k>
           </T> 
endkm

