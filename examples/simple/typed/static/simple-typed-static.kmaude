in ../../../../k-prelude
in simple-typed-static-syntax
in ../simple-typed-programs

mod SIMPLE-TYPED-STATIC-SEMANTICS is including SIMPLE-TYPED-STATIC-DESUGARED-SYNTAX + K .
  subsort List{Type} < List{Exp} KResult .
  subsort Type < Exp Stmt .
  op stmt : -> Type .

  subsorts Stmts List{Exp} List{IdType} < K .

  ops tenv gtenv return : -> CellLabel .

  configuration <T> 
                     <k> .K </k>
                     <tenv> .Map </tenv>
                     <return> stmt </return>
                     <gtenv> .Map </gtenv>
                   </T> .

--- first pass: collect function prototypes in gtenv 
  rule <T> <k> S ~> (.K => doneGlobals ~> S) </k> 
           (.Bag => <gtenv> .Map </gtenv>) </T> .
  op doneGlobals : -> K .  --- to mark when the collection of globals completed
  rule <k> var X : T ; => stmt ...</k> <gtenv> TEnv => TEnv[T / X] </gtenv> .
  rule <k> function F(XTl) : T S => stmt ...</k> <gtenv> TEnv => TEnv[typeList(XTl) -> T / F] </gtenv> [metadata "structural"] .

--- when we are done with the first pass (doneGlobals mark), replace gtenv by tenv and start typing the bodies of functions
  rule <T> <k> stmt ~> doneGlobals => .K ...</k> 
            ( <gtenv> TEnv </gtenv> 
           => <tenv> TEnv </tenv> <return> void </return>) 
          </T> .

  rule I:Int => int .
  rule B:Bool => bool .
  rule <k> X => T ...</k> <tenv>... X |-> T ...</tenv> .
  rule <k> ++ X => int ...</k> <tenv>... X |-> int ...</tenv> .
  rule int + int => int .
  rule _-_(int,int) => int .
  rule int * int => int .
  rule int / int => int .
  rule int % int => int .
  rule - int => int .
  rule int < int => bool .
  rule int <= int => bool .
  rule int > int => bool .
  rule int >= int => bool .
  rule T == T => bool .
  rule T != T => bool .
  rule bool and bool => bool .
  rule bool or bool => bool .
  rule not(bool) => bool .
  rule _`[`](T)[int] => T .
  rule sizeOf(T []) => int .
  rule <k> var X : T ; => stmt ...</k> <tenv> TEnv => TEnv[T / X] </tenv> .
  context var X[[HOLE]] : T ; .
  rule <k> var X[int] : _`[`](T) ; => stmt ...</k> <tenv> TEnv => TEnv[_`[`](T) / X] </tenv> .
  rule {} => stmt .
  op tenv : Map -> K .
  rule <k> {S} => S ~> tenv(TEnv) ...</k> 
          <tenv> TEnv </tenv> .
  rule <k> stmt ~> (tenv(TEnv) => .K) ...</k> 
          <tenv> ? => TEnv </tenv> .
  rule stmt stmt => stmt .
  rule <k> X = T ; => stmt ...</k> <tenv>... X |-> T ...</tenv>  .
  context ?[[HOLE]] = ? ; .
  context [HOLE][?] = ? ; .
  rule _`[`](T)[int] = T ; => stmt .
  rule T ; => stmt .
  rule if bool then stmt else stmt => stmt .
  rule while bool do stmt  => stmt .

  rule <k> function F(XTl) : T S => S ~> tenv(TEnv)...</k> 
          <tenv> TEnv => TEnv[getList{K}(typeList(XTl)) / getList{K}(idList(XTl))] </tenv> 
          <return> ? => T </return> .
  op tenv : Map -> K .
  rule <k> stmt ~> (tenv(TEnv) => .K)...</k> 
          <tenv> ? => TEnv </tenv> . 
  rule _`(_`)(Tl -> T,Tl) => T .
  rule <k> return(T); => stmt ...</k> <return> T </return> .
  rule read() => int .
  rule write(int) ; => stmt   .

--- auxilliary
--- List{Id}
  sort List{Id} .
  subsort Id List{Bottom} < List{Id} < List{Exp} .
  op _,_ : List{Id} List{Id} -> List{Id} [ditto] .

  op idList : List{IdType} -> List{Id} .
  eq idList(.List{Bottom}) = .List{Bottom} .
  eq idList(X : T,XTl) = X,idList(XTl) .

  op typeList : List{IdType} -> List{Type} .
  eq typeList(.List{Bottom}) = .List{Bottom} .
  eq typeList(X : T,XTl) = T,typeList(XTl) .

  var T T' : Type . var Tl : List{Type} . var TEnv TEnv' : Map .
  var F X : Id . var Xl : List{Id} .  var S : Stmt .
  var XTl : List{IdType} .
endm

mod SIMPLE-TYPED-STATIC is including SIMPLE-TYPED-STATIC-SEMANTICS + SIMPLE-TYPED-PROGRAMS .
  op run : KLabel -> Bag .
  eq run(K:KLabel) = <T>
             <k> K:KLabel(.List{K}) </k>
           </T> .
endm

