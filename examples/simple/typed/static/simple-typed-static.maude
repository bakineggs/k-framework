in ../../../../k-prelude
in simple-typed-static-syntax
in ../simple-typed-programs

mod SIMPLE-TYPED-STATIC-SEMANTICS is including SIMPLE-TYPED-STATIC-DESUGARED-SYNTAX + K .
  subsort List{Type} < List{Exp} KResult .
  subsort Type < Exp Stmt .
  op stmt : -> Type .

  subsorts Stmts List{Exp} List{IdType} < K .

  ops tenv gtenv return : -> CellLabel .

  mb configuration < T > 
                     < k > .K </ k >
                     < tenv > .Map </ tenv >
                     < return > stmt </ return >
                     < gtenv > .Map </ gtenv >
                   </ T > : KSentence .


--- first pass: collect function prototypes in gtenv 
  mb rule < T > < k > S ~> [.K => doneGlobals ~> S] </ k > 
           [.Bag => < gtenv > .Map </ gtenv >] </ T > : KSentence .
  op doneGlobals : -> K .  --- to mark when the collection of globals completed
  mb rule < k > [var X : T ; => stmt]...</ k > < gtenv > [TEnv => TEnv[T / X]] </ gtenv > : KSentence .
  mb rule < k > [function F(XTl) : T S => stmt] ...</ k > < gtenv > [TEnv => TEnv[typeList(XTl) -> T / F]] </ gtenv > : KSentence [metadata "structural"] .

--- when we are done with the first pass (doneGlobals mark), replace gtenv by tenv and start typing the bodies of functions
  mb rule < T > < k > [stmt ~> doneGlobals => .K] ...</ k > 
            [ < gtenv > TEnv </ gtenv > 
           => < tenv > TEnv </ tenv > < return > void </ return >] 
          </ T > : KSentence .

  mb rule [I:Int => int] : KSentence .
  mb rule [B:Bool => bool] : KSentence .
  mb rule < k > [X => T] ...</ k > < tenv >... X |-> T ...</ tenv > : KSentence .
  mb rule < k > [++ X => int] ...</ k > < tenv >... X |-> int ...</ tenv > : KSentence .
  mb rule [int + int => int] : KSentence .
  mb rule [_-_(int,int) => int] : KSentence .
  mb rule [int * int => int] : KSentence .
  mb rule [int / int => int] : KSentence .
  mb rule [int % int => int] : KSentence .
  mb rule [- int => int] : KSentence .
  mb rule [int < int => bool] : KSentence .
  mb rule [int <= int => bool] : KSentence .
  mb rule [int > int => bool] : KSentence .
  mb rule [int >= int => bool] : KSentence .
  mb rule [T == T => bool] : KSentence .
  mb rule [T != T => bool] : KSentence .
  mb rule [bool and bool => bool] : KSentence .
  mb rule [bool or bool => bool] : KSentence .
  mb rule [not(bool) => bool] : KSentence .
  mb rule [_`[`](T)[int] => T] : KSentence .
  mb rule [sizeOf(T []) => int] : KSentence .
  mb rule < k > [var X : T ; => stmt] ...</ k > < tenv > [TEnv => TEnv[T / X]] </ tenv > : KSentence .
  mb context var X[[]] : T ; : KSentence .
  mb rule < k > [var X[int] : _`[`](T) ; => stmt] ...</ k > < tenv > [TEnv => TEnv[_`[`](T) / X]] </ tenv > : KSentence .
  mb rule [{} => stmt] : KSentence .
  mb rule [{stmt} => stmt] : KSentence .
  mb rule [stmt stmt => stmt] : KSentence .
  mb rule < k > [X = T ; => stmt] ...</ k > < tenv >... X |-> T ...</ tenv >  : KSentence .
  mb context ?[[]] = ? ; : KSentence .
  mb context [][?] = ? ; : KSentence .
  mb rule [_`[`](T)[int] = T ; => stmt] : KSentence .
  mb rule [T ; => stmt] : KSentence .
  mb rule [if bool then stmt else stmt => stmt] : KSentence .
  mb rule [if bool then stmt else stmt => stmt] : KSentence .
  mb rule [while bool do stmt  => stmt] : KSentence .

  mb rule < k > [function F(XTl) : T S => S ~> tenv(TEnv)]...</ k > 
          < tenv > [TEnv => TEnv[getList{K}(typeList(XTl)) / getList{K}(idList(XTl))]] </ tenv > 
          < return > [? => T] </ return > : KSentence .
  op tenv : Map -> K .
  mb rule < k > stmt ~> [tenv(TEnv) => .K]...</ k > 
          < tenv > [? => TEnv] </ tenv > : KSentence . 
  mb rule [_`(_`)(Tl -> T,Tl) => T] : KSentence .
  mb rule < k > [return(T); => stmt] ...</ k > < return > T </ return > : KSentence .
  mb rule [read() => int] : KSentence .
  mb rule [write(int) ; => stmt]   : KSentence .

--- auxilliary
--- List{Id}
  sort List{Id} .
  subsort Id List{Bottom} < List{Id} < List{Exp} .
  op _,_ : List{Id} List{Id} -> List{Id} [ditto] .

  op idList : List{IdType} -> List{Id} .
  eq idList(.List{Bottom}) = .List{Bottom} .
  eq idList(X : T,XTl) = X,idList(XTl) .

  op typeList : List{IdType} -> List{Type} .
  eq typeList(.List{Bottom}) = .List{Bottom} .
  eq typeList(X : T,XTl) = T,typeList(XTl) .

  var T T' : Type . var Tl : List{Type} . var TEnv TEnv' : Map .
  var F X : Id . var Xl : List{Id} .  var S : Stmt .
  var XTl : List{IdType} .
endm

mod SIMPLE-TYPED-STATIC is including SIMPLE-TYPED-STATIC-SEMANTICS + SIMPLE-TYPED-PROGRAMS .
  op run : -> Bag .
  eq run = < T >
             < k > pSorting </ k >
           </ T > .
endm

