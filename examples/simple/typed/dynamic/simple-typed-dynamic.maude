in ../../../../k-prelude
in simple-typed-dynamic-syntax
in ../simple-typed-programs

mod SIMPLE-TYPED-DYNAMIC-SEMANTICS is including SIMPLE-TYPED-DYNAMIC-DESUGARED-SYNTAX + K .
--- We need values when we define the semantics
  sort Val .
  subsort Int Bool < Val < Exp .

  subsorts Stmts Exp IdType Type List{Exp} List{IdType} List{Type} < K .
  subsort Val List{Val} < KResult .

  ops env genv store fstack in out nextLoc return : -> CellLabel .

  mb configuration < T > 
                     < k > K </ k >
                     < fstack > .List </ fstack >
                     < env > .Map </ env >
                     < genv > .Map </ genv >
                     < store > .Map </ store >
                     < in > .List </ in >
                     < out > .List </ out >
                     < return > none </ return >
                     < nextLoc > 0 </ nextLoc >
                   </ T > : KSentence .

  mb rule < k > [X => V] ...</ k > < env >... X |-> L ...</ env > < store >... L |-> V ...</ store > : KSentence .
  mb rule < k > [++ X => (I +Int 1)] ...</ k > < env >... X |-> L ...</ env > < store >... L |-> [I => I +Int 1] ...</ store > : KSentence .
  mb rule [I1 + I2 => I1 +Int I2] : KSentence .
  mb rule [_-_(I1,I2) => _-Int_(I1,I2)] : KSentence .
  mb rule [I1 * I2 => I1 *Int I2] : KSentence .
  mb rule [I1 / I2 => I1 /Int I2] if I2 =/=Bool 0 : KSentence .
  mb rule [I1 % I2 => I1 %Int I2] if I2 =/=Bool 0 : KSentence .
  mb rule [- I => -Int I] : KSentence .
  mb rule [I1 < I2 => I1 <Int I2] : KSentence .
  mb rule [I1 <= I2 => I1 <=Int I2] : KSentence .
  mb rule [I1 > I2 => I1 >Int I2] : KSentence .
  mb rule [I1 >= I2 => I1 >=Int I2] : KSentence .
  mb rule [V1 == V2 => V1 ==Bool V2] : KSentence .
  mb rule [V1 != V2 => V1 =/=Bool V2] : KSentence .
  mb rule [T1 and T2 => T1 andBool T2] : KSentence .
  mb rule [T1 or T2 => T1 orBool T2] : KSentence .
  mb rule [not(T) => notBool(T)] : KSentence .
  op array : Type Nat Nat -> Val .  --- array value: 1st arg. is the type of the array, 2nd arg. is the location of the first element in the array, and the 3rd arg. is the array size
  mb rule < k > [array(?,L,M)[N] => Sigma(L +Int N)] ...</ k > < store > Sigma </ store > 
       if N >=Nat 0 andBool N <=Nat M : KSentence .
  mb rule [sizeOf(array(?,?,N)) => N] : KSentence .
  mb rule < k > [var X : Tp ; => .K] ...</ k > < env > [Env => Env[L / X]] </ env > < store >... [.Map => L |-> initVal(Tp)] ...</ store >
          < nextLoc > [L => sNat(L)] </ nextLoc > : KSentence .
  mb context var X[[HOLE]] : Tp[] ; : KSentence .
  mb rule < k > [var X[N] : _`[`](Tp) ; => .K] ...</ k > < env > [Env => Env[L / X]] </ env >
          < store >...[.Map => L |-> array(_`[`](Tp), sNat L, N)]...</ store > < nextLoc > [L => sNat L +Nat N] </ nextLoc > : KSentence .
  mb rule [{} => .K] : KSentence .
  mb rule < k > [{Ss} => Ss ~> env(Env)] ...</ k > < env > Env </ env > : KSentence .
  mb rule [S1 S2 => S1 ~> S2] : KSentence .
  mb rule < k > [X = V2 ; => .K] ...</ k > < env >... X |-> L ...</ env > < store >... L |-> [V1 => V2] ...</ store >
       if typeOf(V1) ==Bool typeOf(V2) : KSentence .
  mb context ?[[HOLE]] = ? ; : KSentence .
  mb context [HOLE][?] = ? ; : KSentence .
  mb rule < k > [array(_`[`](Tp),L,M)[N] = V ; => .K] ...</ k > < store > [Sigma => Sigma[V / (L +Int N)]] </ store > 
       if N >=Nat 0 andBool N <=Nat M andBool typeOf(V) ==Bool Tp : KSentence .
  mb rule [V ; => .K] : KSentence .
  mb rule [if true then S else ? => S] : KSentence .
  mb rule [if false then ? else S => S] : KSentence .
  mb rule < k > [while B do S  => if B then {S while B do S} else {}] ...</ k > : KSentence .
  op function : Type Nat -> Val .
  mb rule < k > [function F(XTl) : Tp S => .K] ...</ k > < env > [Env => Env[L / F]] </ env > < nextLoc > [L => sNat sNat L] </ nextLoc > 
          < store >...[.Map => L |-> function(typeList(XTl) -> Tp,sNat L) sNat(L) |-> lambda(idList(XTl),S)]...</ store > : KSentence .
  op lambda : List{Id} Stmt -> Val .
  op (_,_,_) : Map K Type -> ListItem .
 mb rule < k > [_`(_`)(function(Tpl -> Tp,L),Vl)  ~> K => S ~> return(initVal(Tp));] </ k > < fstack > [.List => (Env,K,Tp')] ...</ fstack >
          < env > [Env =>  GEnv[| Xl | from N / getList{K}(Xl)]] </ env > < genv > GEnv </ genv >
          < return > [Tp' => Tp] </ return >
          < store >... L |-> lambda(Xl,S) [.Map => | Xl | from N |-> getList{K}(Vl)] ...</ store >
          < nextLoc > [N => N +Nat | Xl |] </ nextLoc > 
     if typeOf(Vl) ==Bool Tpl : KSentence .

  mb rule < k > [return(V); ~> ? => V ~> K] </ k > < fstack > [(Env,K,Tp') => .List] ...</ fstack > < env > [? => Env] </ env > < return > [Tp => Tp'] </ return >
       if typeOf(V) ==Bool Tp : KSentence .
  mb rule < k > [read() => I] ...</ k > < in > [ListItem(I) => .List] ...</ in > : KSentence .
  mb rule < k > [write(I) ; => .K] ...</ k > < out >... [.List => ListItem(I)] </ out >  : KSentence .

--- when we are done with the first pass (computation and genv are empty), call main and initialize the global environment
  mb rule < k > [.K => main();] </ k > < env > Env </ env > < genv > [.Map => Env] </ genv > : KSentence .

--- auxilliary declarations and operations
  op initVal : Type -> Val .
  eq initVal(int) = 0 .
  eq initVal(bool) = false .
  eq initVal(void) = none .
  eq initVal(_`[`](Tp)) = array(_`[`](Tp),0,0) .
  op none : -> Val .

  op typeOf : List{Val} -> List{Type} .
  eq typeOf(function(Tp, ?)) = Tp .
  eq typeOf(array(Tp,?,?)) = Tp .
  eq typeOf(I) = int .
  eq typeOf(T) = bool .
  eq typeOf(none) = void .
  eq typeOf(V1,V2,Vl) = typeOf(V1),typeOf(V2,Vl) .
  eq typeOf(.List{Bottom}) = .List{Bottom} .

--- List{Id}
  sort List{Id} .
  subsort Id List{Bottom} < List{Id} < List{Exp} .
  op _,_ : List{Id} List{Id} -> List{Id} [ditto] .
--- List{Val}
  sort List{Val} .
  subsort Val List{Bottom} < List{Val} < List{Exp} .
  op _,_ : List{Val} List{Val} -> List{Val} [ditto] .

  op idList : List{IdType} -> List{Id} .
  eq idList(.List{Bottom}) = .List{Bottom} .
  eq idList(X : Tp,XTl) = X,idList(XTl) .

  op typeList : List{IdType} -> List{Type} .
  eq typeList(.List{Bottom}) = .List{Bottom} .
  eq typeList(X : Tp,XTl) = Tp,typeList(XTl) .

  op |_| : List{Id} -> Nat .  eq | .List{Bottom} | = 0 .  eq | X,Xl | = sNat(| Xl |) .
  op _from_ : Nat Nat -> List{K} .  eq 0 from N1 = .List{K} .  eq sNat N2 from N1 = N1,,(N2 from sNat N1) .

  op env : Map -> K .
  mb rule [env(?) ~> env(Env) => env(Env)] : KSentence [metadata "structural"] .
  mb rule < k > [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .
  mb rule < k > V ~> [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .

  vars I I1 I2 : Int .  var N N1 N2 M L : Nat .  var T T1 T2 : Bool .  var F X : Id .  var Env GEnv Sigma : Map .  var B : Exp .
  var S S1 S2 : Stmt .  var Xl : List{Id} .  var K : K .  var Ss : Stmts .  var Vl : List{Val} .  var V V1 V2 : Val .
  var XTl : List{IdType} . var Tp Tp' : Type .  var Tpl : List{Type} .
endm

mod SIMPLE-TYPED-DYNAMIC is 
  including SIMPLE-TYPED-DYNAMIC-SEMANTICS .
  including SIMPLE-TYPED-PROGRAMS .
  op run : KLabel -> Bag .
  var PgmName : KLabel .  var Input : List{K} .
  eq run(PgmName) = < T > 
             < k > PgmName(.List{K}) </ k >
             < fstack > .List </ fstack >
             < env > .Map </ env >
             < genv > .Map </ genv >
             < store > .Map </ store >
             < in > List(7,,23,,654,,656,,54,,456,,436345647643567,,354654364356,,4357643576) </ in >
             < out > .List </ out >
             < return > none </ return >
             < nextLoc > 0 </ nextLoc >
           </ T > .
endm

