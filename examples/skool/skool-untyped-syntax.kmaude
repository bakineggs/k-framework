in ../../k-prelude

kmod SKOOL-UNTYPED-SYNTAX is including PL-INT + PL-ID 

  syntax Var ::= Id | Exp [ Exp ] [prec 1 strict]
 
  syntax Exp  ::= Var | Int | Bool
                | ++ Id [prec 0]
                | Exp + Exp [gather(E e) prec 33 strict]
                | Exp - Exp [gather(E e) prec 33 strict]
                | Exp * Exp [gather(E e) prec 31 strict]
                | Exp / Exp [gather(E e) prec 31 strict]
                | Exp % Exp [gather(E e) prec 31 strict]
                |  - Exp [strict]
                | Exp < Exp [prec 37 metadata "latex(renameTo _\\ensuremath<_)" strict] 
                | Exp <= Exp [prec 37 metadata "latex(renameTo _\\ensuremath\\leq_)" strict] 
                | Exp > Exp [prec 37 metadata "latex(renameTo _\\ensuremath>_)" strict] 
                | Exp >= Exp [prec 37 metadata "latex(renameTo _\\ensuremath\\geq_)" strict] 
                | Exp == Exp [prec 37 strict] 
                | Exp != Exp [prec 37 strict] 
                | Exp and Exp [gather(E e) prec 55 strict] 
                | Exp or Exp  [gather(E e) prec 59 strict] 
                | not Exp [prec 53 strict]
                | sizeOf ( Exp ) [strict]
                | Exp ( )
                | Exp ( List{Exp} ) [prec 2 strict]
                | read ( )
                | Id [ Exp ] [prec 1 strict(2)]
                --- OO specific
                | new Id ( ) [prec 1]
                | new Id ( List{Exp} ) [prec 1 strict(2)]
                | self
                | Exp . Id ( ) [prec 1 strict(1)]
                | Exp . Id ( List{Exp} ) [prec 1 strict(1 3)] 
                | super Id ( ) [prec 1]
                | super Id ( List{Exp} ) [prec 1 strict(2)]
                | Exp instanceOf Id [prec 0 strict(1)]


  syntax VarDecl ::= var Var ; [prec 2] 
                   | var List{Id} ; [prec 2]
                   | var Id [ Int ] ; [prec 0]
                   | VarDecl VarDecl [prec 100 gather(e E)] 


  syntax MethodDecl ::= method Id ( ) Stmt 
                      | method Id ( List{Id} ) Stmt
                      | MethodDecl MethodDecl [prec 100 gather(e E)]

  syntax ClassDecl ::= class Id { MethodDecl }
                     | class Id { VarDecl  MethodDecl }
                     | class Id extends Id { MethodDecl }
                     | class Id extends Id { VarDecl  MethodDecl }
                     | ClassDecl ClassDecl [prec 100 gather(e E)]

  syntax Stmt ::= { } [metadata "latex(renameTo \\{\\})"]
                | { Stmts } [gather(&) metadata "latex(renameTo \\{\_\\})"]
                | Exp = Exp ; [prec 2 strict(2)]
                | Id [ Exp ] = Exp [prec 0 gather(e & &) strict(2 3)]
                | Exp ; [prec 50 strict]
                | if Exp then Stmt else Stmt [strict(1)]
                | if Exp then Stmt
                | while Exp do Stmt
                | for Id = Exp to Exp do Stmt
                | return Exp ; [strict]
                | write ( Exp ) ; [strict]

  syntax Stmts ::= VarDecl | Stmt
                | Stmts Stmts [prec 100 gather(e E)]

  syntax Id ::= main | object



-----------------------------------------------------------------------------
--- Lists should be eventually builtin; for now, they need to be declared ---
-----------------------------------------------------------------------------
--- List{Id}
  syntax List{Id}  ::= Id | .List{Id}
                     | List{Id} , List{Id} [prec 70 assoc id: .List{Id}]
--- List{Exp}
  syntax List{Exp} ::= Exp | List{Id} | List{Exp} , List{Exp} [ditto]
-----------------------------------------------------------------------------

endkm


kmod SKOOL-UNTYPED-DESUGARED-SYNTAX is including SKOOL-UNTYPED-SYNTAX 
--------------------------------------------------------------------------------
--- This module desugars some of SIMPLE's language constructs into core ones ---
--- The idea is that we only want to give semantics to core constructs,      ---
--- so we get rid of the derived ones before we start the semantics          ---
--------------------------------------------------------------------------------
  macro if E:Exp then S:Stmt = if E then S else {}
  macro (for X:Id = E1:Exp to E2:Exp do S) = {var X; X=E1; while X <= E2 do {S X=X+1;}}
  macro method F:Id() S = method F(.List{Id}) S
  macro E() = E(.List{Id})

  macro O:Exp . F() = O . F(.List{Id})
  macro new C:Id() = new C(.List{Id})
  macro O . F() = O . F(.List{Id})
  macro super F() = super F(.List{Id})

  macro class C {Ms:MethodDecl} = class C extends object {Ms}
  macro class C {Fs:VarDecl Ms} = class C extends object {Fs  Ms}

endkm

