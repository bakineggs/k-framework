mod MATHEMATICAL-INT-BUILTIN-MODULE is
  inc MATHEMATICAL-OBJECT-BUILTIN-MODULE + PL-INT .

--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?Int !Int FreeInt Int++ .   --- sort Int already defined
  subsort ?Int !Int FreeInt Int < Int++ .
  subsort ?Int < ?MathObj .
  subsort !Int < !MathObj .
  subsort FreeInt < FreeMathObj .
  subsort Int < MathObj .
  subsort Int++ < MathObj++ .

  op ?Int : Nat -> ?Int .
  op !Int : Nat -> !Int .
  op FreeInt : Nat -> FreeInt .
  op skolem : Nat ?Int -> FreeInt [ditto] .
  op co-skolem : Nat FreeInt -> !Int [ditto] .

--- define operations to be used symbolically, as well as desired properties
  ops _+Int_ _-Int_ _*Int_ _/Int_ _%Int_ : Int++ Int++ -> Int++ [ditto] .
  ops _<=Int_ _<Int_ _>=Int_ _>Int_ : Int++ Int++ -> Bool [ditto] .
  ops _<<Int_ _>>Int_ : Int++ Int++ -> Int++ [ditto] .
  ops -Int_ ~Int_ : Int++ -> Int++ [ditto] .
  op _==Int_ : Int++ Int++ -> Bool [ditto] .

  op bool2int : Bool -> Int++ .
  eq bool2int(true) = 1 .
  eq bool2int(false) = 0 .

  var B : Bool .
  var I J K I1 I2 J1 J2 N : Int++ .
  var NzI : NzInt . 
  var Phi Phi1 Phi2 : Formula .

  eq @ (I ==Int J) = I === J .

  eq I +Int (-Int I) = 0 .
  eq 0 +Int I = I .
  eq I *Int (I1 +Int I2) = (I *Int I1) +Int (I *Int I2) .
  eq (-Int I) *Int J = -Int (I *Int J) .
  eq -Int (-Int I) = I .
  eq 1 *Int I = I .
  eq I -Int J = I +Int (-Int J) .
  eq -Int (I +Int J) = (-Int I) +Int (-Int J) .
---  stack overflow
---  eq I +Int (J /Int 2) = (I +Int I +Int J) /Int 2 .

  eq -Int I === 0 = I === 0 .
  eq I +Int K === J +Int K = I === J .
 ceq I1 === J1 /\ Phi1 ===> I2 === J2 /\ Phi2 = I1 === J1 /\ Phi1 ===> Phi2
  if (-Int I1) +Int (-Int I2) +Int J1 +Int J2 ==Bool 0 .

  eq I <=Int J = J >=Int I .
  eq I <Int J = J >Int I .
  eq I >Int J = I +Int (-Int 1) >=Int J . 
 ceq I >=Int J = I +Int (-Int J) >=Int 0 if J =/=Bool 0 .
  eq ~(@(I >=Int 0)) = @((-Int I) +Int (-Int 1) >=Int 0) .

 ceq @(I >=Int 0) /\ @(J >=Int 0) = (I === 0) if I +Int J ==Bool 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) = @(I >=Int 0) if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ Phi1 ===> @(J >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> @(K >=Int 0) /\ Phi2
   = @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> Phi2
  if (-Int I) +Int (-Int J) +Int K >=Int 0 .

  eq (bool2int(B) === 0) = ~(@ B) .
  eq (bool2int(B) === NzI) = @ B .
  eq (0 === bool2int(B)) = ~(@ B) .
  eq (NzI === bool2int(B)) = @ B .

  eq (I:Int === J:Int) = @(I:Int ==Bool J:Int) .
endm

