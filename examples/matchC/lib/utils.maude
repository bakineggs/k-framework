mod PL-META-TERM is including PL-BOOL + PL-QID .
*** types
  sorts Sort Kind Type .
  subsorts Sort Kind < Type < Qid .
  op <Qids> : -> Sort [special (id-hook QuotedIdentifierSymbol (sortQid))] .
  op <Qids> : -> Kind [special (id-hook QuotedIdentifierSymbol (kindQid))] .


*** terms
  sorts Constant Variable GroundTerm Term NeGroundTermList GroundTermList NeTermList TermList .
  subsorts Constant Variable < Qid Term .
  subsorts Constant < GroundTerm < Term NeGroundTermList < NeTermList .
  subsorts NeGroundTermList < NeTermList GroundTermList < TermList .
  op <Qids> : -> Constant [special (id-hook QuotedIdentifierSymbol (constantQid))] .
  op <Qids> : -> Variable [special (id-hook QuotedIdentifierSymbol (variableQid))] .
  op .emptyTermList : -> GroundTermList [ctor] .
  op _:_ : NeGroundTermList GroundTermList -> NeGroundTermList [ctor assoc id: .emptyTermList gather (e E) prec 121] .
  op _:_ : GroundTermList NeGroundTermList -> NeGroundTermList [ctor ditto] .
  op _:_ : GroundTermList GroundTermList -> GroundTermList [ctor ditto] .
  op _:_ : NeTermList TermList -> NeTermList [ctor ditto] .
  op _:_ : TermList NeTermList -> NeTermList [ctor ditto] .
  op _:_ : TermList TermList -> TermList [ctor ditto] .
  op _[_] : Qid NeGroundTermList -> GroundTerm [ctor] .
  op _[_] : Qid NeTermList -> Term [ctor] .

*** utils for constant/variables
  op getName : Constant -> Qid .
  op getType : Constant -> Type .
  var C : Constant .
  op getName : Variable -> Qid .
  op getType : Variable -> Type .
  var V : Variable .
  eq getName (C) = qid (substrString (string (C), 0, rfindString (string (C), ".", lengthString (string (C))))) .
  eq getType (C) = qid (substrString (string (C), rfindString (string (C), ".", lengthString (string (C))) +Nat 1, lengthString (string (C)))) .
  eq getName (V) = qid (substrString (string (V), 0, rfindString (string (V), ":", lengthString (string (V))))) .
  eq getType (V) = qid (substrString (string (V), rfindString (string (V), ":", lengthString (string (V))) +Nat 1, lengthString (string (V)))) .


  sort Module .
  sort ResultPair .
  op metaReduce : Module Term ~> ResultPair
     [special (
        id-hook MetaLevelOpSymbol	(metaReduce)

        op-hook qidSymbol		(<Qids> : ~> Qid)
        op-hook metaTermSymbol		(_[_] : Qid NeTermList ~> Term)
        op-hook metaArgSymbol		(_:_ : NeTermList NeTermList ~> NeTermList)

        term-hook trueTerm		(true)
        term-hook falseTerm		(false))] .


  op downTerm : Term Universal -> Universal
        [poly (2 0)
         special (
           id-hook MetaLevelOpSymbol	(metaDownTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .


  op upTerm : Universal -> Term
        [poly (1) strat(0)
         special (
           id-hook MetaLevelOpSymbol	(metaUpTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair)
) ] .
endm


mod CONST-UTILS is inc MATCHC .
  op errorPattern : -> [Pattern] .
  op errorBag : -> [Bag] .
  op errorFormula : -> [Formula] .
  op errorSubst : -> [Subst] .
endm


***(
mod VAR-UTILS is inc MATCHC + PL-META-TERM + MAUDE-IF-THEN-ELSE + CONST-UTILS .
  op get?VarSet : Formula -> Set{MathObj++} .
  op get?VarSet : Bag -> Set{MathObj++} .
  op get?VarSet : TermList -> Set{MathObj++} .
  op get!VarSet : Formula -> Set{MathObj++} .
  op get!VarSet : Bag -> Set{MathObj++} .
  op get!VarSet : TermList -> Set{MathObj++} .
  op getFreeVarSet : Formula -> Set{MathObj++} .
  op getFreeVarSet : Bag -> Set{MathObj++} .
  op getFreeVarSet : TermList -> Set{MathObj++} .

  op getFreeMap : Bag -> Map .
  op getFreeMap : TermList -> Map .
  op getFreeBag : Bag -> Bag .
  op getFreeBag : TermList -> Bag .

  var Obj : MathObj++ .
  var Phi : Formula .
  var Cfgs : Bag .

  eq get?VarSet(Cfgs) = get?VarSet(upTerm(Cfgs)) .
  eq get?VarSet(Phi) = get?VarSet(upTerm(Phi)) .
  eq get!VarSet(Cfgs) = get!VarSet(upTerm(Cfgs)) .
  eq get!VarSet(Phi) = get!VarSet(upTerm(Phi)) .
  eq getFreeVarSet(Cfgs) = getFreeVarSet(upTerm(Cfgs)) .
  eq getFreeVarSet(Phi) = getFreeVarSet(upTerm(Phi)) .

  eq getFreeMap(Cfgs) = getFreeMap(upTerm(Cfgs)) .
  eq getFreeBag(Cfgs) = getFreeBag(upTerm(Cfgs)) .

  var Q : Qid .
  var QC : Constant .
  vars QT NT NT' : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .

  eq get?VarSet((QT : QTNeList)) = get?VarSet(QT) & get?VarSet(QTNeList) .
  eq get?VarSet(.emptyTermList) = .Set{MathObj++} .
  eq get?VarSet(QC) = if downTerm(QC, errorObj) :: ?MathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
 ceq get?VarSet(Q[QT]) = downTerm(Q[QT], .Set{MathObj++})
  if substrString(string(Q), 0, 1) ==Bool "?" .
  eq get?VarSet(Q[QTList]) = get?VarSet(QTList) [owise] .

  eq getFreeVarSet((QT : QTNeList))
   = getFreeVarSet(QT) & getFreeVarSet(QTNeList) .
  eq getFreeVarSet(.emptyTermList) = .Set{MathObj++} .
  eq getFreeVarSet(QC) = if downTerm(QC, errorObj) :: FreeMathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
  eq getFreeVarSet('skolem[NT : QT])
   = downTerm('skolem[NT : QT], .Set{MathObj++}) .
  eq getFreeVarSet(Q[QTList]) = getFreeVarSet(QTList) [owise] .

  eq getFreeMap((QT : QTNeList))
   = getFreeMap(QT) getFreeMap(QTNeList) .
  eq getFreeMap(.emptyTermList) = (.).Map .
  eq getFreeMap(QC) = if downTerm(QC, (.).Map) :: FreeMapItem then
     downTerm(QC, (.).Map) else (.).Map fi [print QC] .
  eq getFreeMap(Q[QTList]) = getFreeMap(QTList) [owise] .
endm
***)


mod PATTERN-SKOLEM is
inc MATCHC
  + PL-META-TERM
  + CONST-UTILS
  + MAUDE-IF-THEN-ELSE .

  op skolemTerm : Term TermList -> TermList .
  op co-skolemTerm : Term TermList -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT NT : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .


  eq skolemTerm(NT, (QT : QTNeList))
   = skolemTerm(NT, QT) : skolemTerm(NT, QTNeList) .
  eq skolemTerm(NT, .emptyTermList) = .emptyTermList .
  eq skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 2) ==Bool "PE" then
       'skolem[NT : QC]
     else
       QC
     fi .
  eq skolemTerm(NT, Q[QTList])
   = if substrString(string(Q), 0, 2) ==Bool "?" then
       'skolem[NT : Q[QTList]]
     else
       if Q =/=Bool 'skolem then
         Q[skolemTerm(NT, QTList)]
       else
         Q[QTList]
       fi
     fi .

 
  eq co-skolemTerm(NT, (QT : QTNeList))
   = co-skolemTerm(NT, QT) : co-skolemTerm(NT, QTNeList) .
  eq co-skolemTerm(NT, .emptyTermList) = .emptyTermList .
  eq co-skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 4) ==Bool "Free" then
       'co-skolem[NT : QC]
     else
       QC
     fi .
  eq co-skolemTerm(NT, Q[QTList])
   = if substrString(string(Q), 0, 4) ==Bool "Free" orBool Q ==Bool 'skolem then
       'co-skolem[NT : Q[QTList]]
     else
       if Q ==Bool 'co-skolem then
         Q[co-skolemTerm(NT, QTList)]
       else
         Q[QTList]
       fi
     fi .
 

  var N : Nat .
  var Pattern : Pattern .

  eq skolemize(N, Pattern)
   = downTerm(skolemTerm(upTerm(N), upTerm(Pattern)), errorPattern) .
  eq co-skolemize(N, Pattern)
   = downTerm(co-skolemTerm(upTerm(N), upTerm(Pattern)), errorPattern) .
endm


mod APPLY-SUBST is
inc MATCHC
  + PL-META-TERM
  + CONST-UTILS
  + MAUDE-IF-THEN-ELSE .

  sort MetaSubst .
  op .MetaSubst : -> MetaSubst .
  op _;_ : MetaSubst MetaSubst -> MetaSubst [assoc comm id: .MetaSubst] .
  op _<-_ : Term Term -> MetaSubst .
  op upSubst : Subst -> MetaSubst .

  var K1 K2 : K .
  var List1 List2 : List .
  var Bag1 Bag2 : Bag .
  var Set1 Set2 : Set .
  var Map1 Map2 : Map .
  var Subst : Subst .

  eq upSubst((K1 <- K2) ;; Subst)
   = (upTerm(K1) <- upTerm(K2)) ; upSubst(Subst) .
  eq upSubst((List1 <- List2) ;; Subst)
   = (upTerm(List1) <- upTerm(List2)) ; upSubst(Subst) .
  eq upSubst((Bag1 <- Bag2) ;; Subst)
   = (upTerm(Bag1) <- upTerm(Bag2)) ; upSubst(Subst) .
  eq upSubst((Set1 <- Set2) ;; Subst)
  = (upTerm(Set1) <- upTerm(Set2)) ; upSubst(Subst) .
  eq upSubst((Map1 <- Map2) ;; Subst)
   = (upTerm(Map1) <- upTerm(Map2)) ; upSubst(Subst) . 
  eq upSubst(.Subst) = .MetaSubst .

  op substTerm : TermList MetaSubst -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT QT1 QT2 : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .
  var MetaSubst : MetaSubst .

  eq substTerm((QT : QTNeList), MetaSubst)
   = substTerm(QT, MetaSubst) : substTerm(QTNeList, MetaSubst) .
  eq substTerm(.emptyTermList, MetaSubst) = .emptyTermList .
  eq substTerm(QT1, ((QT1 <- QT2) ; MetaSubst)) = QT2 .
 ceq substTerm(Q[QTList], MetaSubst) = Q[QTList]
  if Q ==Bool 'skolem orBool Q ==Bool 'co-skolem .
 ceq substTerm('_`(_`)[QC : QTList], MetaSubst) = '_`(_`)[QC : QTList]
  if getName(QC) ==Bool ''@`assume_ orBool
     getName(QC) ==Bool ''@`assert_ orBool
     getName(QC) ==Bool ''@`invariant_ orBool
     getName(QC) ==Bool ''@`pre_ orBool
     getName(QC) ==Bool ''@`post_ .
  eq substTerm(QC, MetaSubst) = QC [owise] .
  eq substTerm(Q[QTList], MetaSubst)
   = Q[substTerm(QTList, MetaSubst)] [owise] .

  var Pattern : Pattern .
  var Bag : Bag .
  var Phi : Formula .
  var Subst1 Subst2 : Subst .

  --- apply substitution on a pattern
  eq applySubst(Pattern, Subst)
   = downTerm(substTerm(upTerm(Pattern), upSubst(Subst)), errorPattern) .
  --- apply substitution on a configuration
  eq applySubst(Bag, Subst)
   = downTerm(substTerm(upTerm(Bag), upSubst(Subst)), errorBag) .
  --- apply substitution on a substitution
  eq applySubst(Phi, Subst)
   = downTerm(substTerm(upTerm(Phi), upSubst(Subst)), errorFormula) .
  --- apply substitution on a substitution
  eq applySubst(Subst1, Subst2)
   = downTerm(substTerm(upTerm(Subst1), upSubst(Subst2)), errorSubst) .
endm


mod UTILS is inc PATTERN-SKOLEM + APPLY-SUBST .
  var I : Int++ .
  eq isInt(I) = I :: Int .

  var Obj : MathObj++ .
  var PEObj : PEMathObj .
  var FEObj : FEMathObj .
  var FreeObj : FreeMathObj .
  var Phi : Formula .

  eq getPESubstItem(PEObj === Obj /\ Phi) = (PEObj <- Obj) .
  eq getPESubstItem(Obj === PEObj /\ Phi) = (PEObj <- Obj) .
  eq getPESubstItem(Phi) = .Subst [owise] .

  eq getFESubstItem(FEObj === Obj /\ Phi) = (FEObj <- Obj) .
  eq getFESubstItem(Obj === FEObj /\ Phi) = (FEObj <- Obj) .
  eq getFESubstItem(Phi) = .Subst [owise] .

  eq getFreeSubstItem(FreeObj === Obj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Obj === FreeObj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Phi) = .Subst [owise] .

  var Obj1 Obj2 Obj1' Obj2' : MathObj++ .
  var ObjList ObjList' : List{MathObj++} .
  eq (Obj1, Obj2, ObjList) <- (Obj1', Obj2', ObjList')
   = (Obj1 <- Obj1') ;; (Obj2 <- Obj2') ;; (ObjList <- ObjList') .
endm
