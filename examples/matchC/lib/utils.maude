mod PL-META-TERM is including PL-BOOL + PL-QID .
*** types
  sorts Sort Kind Type .
  subsorts Sort Kind < Type < Qid .
  op <Qids> : -> Sort [special (id-hook QuotedIdentifierSymbol (sortQid))] .
  op <Qids> : -> Kind [special (id-hook QuotedIdentifierSymbol (kindQid))] .


*** terms
  sorts Constant Variable ExtendedConstant .
  sorts GroundTerm Term NeGroundTermList GroundTermList NeTermList TermList .
  subsorts Constant Variable < ExtendedConstant < Qid Term .
  subsorts Constant < GroundTerm < Term NeGroundTermList < NeTermList .
  subsorts NeGroundTermList < NeTermList GroundTermList < TermList .
  op <Qids> : -> Constant [special (id-hook QuotedIdentifierSymbol (constantQid))] .
  op <Qids> : -> Variable [special (id-hook QuotedIdentifierSymbol (variableQid))] .
  op .emptyTermList : -> GroundTermList [ctor] .
  op _:_ : NeGroundTermList GroundTermList -> NeGroundTermList [ctor assoc id: .emptyTermList gather (e E) prec 121] .
  op _:_ : GroundTermList NeGroundTermList -> NeGroundTermList [ctor ditto] .
  op _:_ : GroundTermList GroundTermList -> GroundTermList [ctor ditto] .
  op _:_ : NeTermList TermList -> NeTermList [ctor ditto] .
  op _:_ : TermList NeTermList -> NeTermList [ctor ditto] .
  op _:_ : TermList TermList -> TermList [ctor ditto] .
  op _[_] : Qid NeGroundTermList -> GroundTerm [ctor] .
  op _[_] : Qid NeTermList -> Term [ctor] .

*** utils for constant/variables
  op getName : Constant -> Qid .
  op getType : Constant -> Type .
  var C : Constant .
  op getName : Variable -> Qid .
  op getType : Variable -> Type .
  var V : Variable .
  eq getName (C) = qid (substrString (string (C), 0, rfindString (string (C), ".", lengthString (string (C))))) .
  eq getType (C) = qid (substrString (string (C), rfindString (string (C), ".", lengthString (string (C))) +Nat 1, lengthString (string (C)))) .
  eq getName (V) = qid (substrString (string (V), 0, rfindString (string (V), ":", lengthString (string (V))))) .
  eq getType (V) = qid (substrString (string (V), rfindString (string (V), ":", lengthString (string (V))) +Nat 1, lengthString (string (V)))) .


  sort Module .
  sort ResultPair .
  op metaReduce : Module Term ~> ResultPair
     [special (
        id-hook MetaLevelOpSymbol	(metaReduce)

        op-hook qidSymbol		(<Qids> : ~> Qid)
        op-hook metaTermSymbol		(_[_] : Qid NeTermList ~> Term)
        op-hook metaArgSymbol		(_:_ : NeTermList NeTermList ~> NeTermList)

        term-hook trueTerm		(true)
        term-hook falseTerm		(false))] .


  op downTerm : Term Universal -> Universal
        [poly (2 0)
         special (
           id-hook MetaLevelOpSymbol	(metaDownTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair))] .


  op upTerm : Universal -> Term
        [poly (1) strat(0)
         special (
           id-hook MetaLevelOpSymbol	(metaUpTerm)
           op-hook shareWith		(metaReduce : Module Term ~> ResultPair)
) ] .
endm


mod CONST-UTILS is inc MATCHC .
  op errorPattern : -> [Pattern] .
  op errorBag : -> [Bag] .
  op errorFormula : -> [Formula] .
  op errorSubst : -> [Subst] .
endm


***(
mod VAR-UTILS is inc MATCHC + PL-META-TERM + MAUDE-IF-THEN-ELSE + CONST-UTILS .
  op get?VarSet : Formula -> Set{MathObj++} .
  op get?VarSet : Bag -> Set{MathObj++} .
  op get?VarSet : TermList -> Set{MathObj++} .
  op get!VarSet : Formula -> Set{MathObj++} .
  op get!VarSet : Bag -> Set{MathObj++} .
  op get!VarSet : TermList -> Set{MathObj++} .
  op getFreeVarSet : Formula -> Set{MathObj++} .
  op getFreeVarSet : Bag -> Set{MathObj++} .
  op getFreeVarSet : TermList -> Set{MathObj++} .

  op getFreeMap : Bag -> Map .
  op getFreeMap : TermList -> Map .
  op getFreeBag : Bag -> Bag .
  op getFreeBag : TermList -> Bag .

  var Obj : MathObj++ .
  var Phi : Formula .
  var Cfgs : Bag .

  eq get?VarSet(Cfgs) = get?VarSet(upTerm(Cfgs)) .
  eq get?VarSet(Phi) = get?VarSet(upTerm(Phi)) .
  eq get!VarSet(Cfgs) = get!VarSet(upTerm(Cfgs)) .
  eq get!VarSet(Phi) = get!VarSet(upTerm(Phi)) .
  eq getFreeVarSet(Cfgs) = getFreeVarSet(upTerm(Cfgs)) .
  eq getFreeVarSet(Phi) = getFreeVarSet(upTerm(Phi)) .

  eq getFreeMap(Cfgs) = getFreeMap(upTerm(Cfgs)) .
  eq getFreeBag(Cfgs) = getFreeBag(upTerm(Cfgs)) .

  var Q : Qid .
  var QC : Constant .
  vars QT NT NT' : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .

  eq get?VarSet((QT : QTNeList)) = get?VarSet(QT) & get?VarSet(QTNeList) .
  eq get?VarSet(.emptyTermList) = .Set{MathObj++} .
  eq get?VarSet(QC) = if downTerm(QC, errorObj) :: ?MathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
 ceq get?VarSet(Q[QT]) = downTerm(Q[QT], .Set{MathObj++})
  if substrString(string(Q), 0, 1) ==Bool "?" .
  eq get?VarSet(Q[QTList]) = get?VarSet(QTList) [owise] .

  eq getFreeVarSet((QT : QTNeList))
   = getFreeVarSet(QT) & getFreeVarSet(QTNeList) .
  eq getFreeVarSet(.emptyTermList) = .Set{MathObj++} .
  eq getFreeVarSet(QC) = if downTerm(QC, errorObj) :: FreeMathObj then
     downTerm(QC, errorObj) else .Set{MathObj++} fi .
  eq getFreeVarSet('skolem[NT : QT])
   = downTerm('skolem[NT : QT], .Set{MathObj++}) .
  eq getFreeVarSet(Q[QTList]) = getFreeVarSet(QTList) [owise] .

  eq getFreeMap((QT : QTNeList))
   = getFreeMap(QT) getFreeMap(QTNeList) .
  eq getFreeMap(.emptyTermList) = (.).Map .
  eq getFreeMap(QC) = if downTerm(QC, (.).Map) :: FreeMapItem then
     downTerm(QC, (.).Map) else (.).Map fi [print QC] .
  eq getFreeMap(Q[QTList]) = getFreeMap(QTList) [owise] .
endm
***)


mod PATTERN-SKOLEM is
inc MATCHC
  + PL-META-TERM
  + CONST-UTILS
  + MAUDE-IF-THEN-ELSE .

  op skolemTerm : Term TermList -> TermList .
  op co-skolemTerm : Term TermList -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT NT : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .


  eq skolemTerm(NT, (QT : QTNeList))
   = skolemTerm(NT, QT) : skolemTerm(NT, QTNeList) .
  eq skolemTerm(NT, .emptyTermList) = .emptyTermList .
  eq skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 2) ==Bool "PE" then
       'skolem[NT : QC]
     else
       QC
     fi .
 ceq skolemTerm(NT, Q[QTList]) = 'skolem[NT : Q[QTList]]
  if substrString(string(Q), 0, 1) ==Bool "?" .
 ceq skolemTerm(NT, Q[QTList]) = Q[QTList]
  if Q ==Bool 'skolem .
 ceq skolemTerm(NT, '_`(_`)[QC : QTList]) = '_`(_`)[QC : QTList]
  if getName(QC) ==Bool ''@`assume_ orBool
     getName(QC) ==Bool ''@`assert_ orBool
     getName(QC) ==Bool ''@`invariant_ orBool
     getName(QC) ==Bool ''@`pre_ orBool
     getName(QC) ==Bool ''@`post_ .
 ceq skolemTerm(NT, '<_>_</_>[QC : QT : QC]) = '<_>_</_>[QC : QT : QC]
  if getName(QC) ==Bool 'struct orBool
     getName(QC) ==Bool 'fun orBool
     getName(QC) ==Bool 'tenv .
  eq skolemTerm(NT, Q[QTList]) = Q[skolemTerm(NT, QTList)] [owise] .

 
  eq co-skolemTerm(NT, (QT : QTNeList))
   = co-skolemTerm(NT, QT) : co-skolemTerm(NT, QTNeList) .
  eq co-skolemTerm(NT, .emptyTermList) = .emptyTermList .
  eq co-skolemTerm(NT, QC)
   = if substrString(string(getType(QC)), 0, 4) ==Bool "Free" then
       'co-skolem[NT : QC]
     else
       QC
     fi .
  eq co-skolemTerm(NT, Q[QTList])
   = if substrString(string(Q), 0, 4) ==Bool "Free" orBool Q ==Bool 'skolem then
       'co-skolem[NT : Q[QTList]]
     else
       if Q =/=Bool 'co-skolem then
         Q[co-skolemTerm(NT, QTList)]
       else
         Q[QTList]
       fi
     fi .
 

  var N : Nat .
  var Pattern : Pattern .

  eq skolemize(N, Pattern)
   = downTerm(skolemTerm(upTerm(N), upTerm(Pattern)), errorPattern) .
  eq co-skolemize(N, Pattern)
   = downTerm(co-skolemTerm(upTerm(N), upTerm(Pattern)), errorPattern) .
endm


mod APPLY-SUBST is
inc MATCHC
  + PL-META-TERM
  + CONST-UTILS
  + MAUDE-IF-THEN-ELSE .

  sort MetaSubst .
  op .MetaSubst : -> MetaSubst .
  op _;_ : MetaSubst MetaSubst -> MetaSubst [assoc comm id: .MetaSubst] .
  op _<-_ : Term Term -> MetaSubst .
  op upSubst : Subst -> MetaSubst .
  op upSubstItem : SubstItem -> MetaSubst .

  var K1 K2 : K .
  var List1 List2 : List .
  var Bag1 Bag2 : Bag .
  var Set1 Set2 : Set .
  var Map1 Map2 : Map .
  var Subst : Subst .
  var SubstItem : SubstItem .

  eq upSubst(SubstItem ;; Subst) = upSubstItem(SubstItem) ; upSubst(Subst) .
  eq upSubst(.Subst) = .MetaSubst .
  eq upSubstItem(K1 <- K2) = upTerm(K1) <- upTerm(K2) .
  eq upSubstItem(List1 <- List2) = upTerm(List1) <- upTerm(List2) .
  eq upSubstItem(Bag1 <- Bag2) = upTerm(Bag1) <- upTerm(Bag2) .
  eq upSubstItem(Set1 <- Set2) = upTerm(Set1) <- upTerm(Set2) .
  eq upSubstItem(Map1 <- Map2) = upTerm(Map1) <- upTerm(Map2) .


  op substTerm : TermList MetaSubst -> TermList .

  var Q : Qid .
  var QC : Constant .
  var QT QT1 QT2 : Term .
  var QTList : TermList .
  var QTNeList : NeTermList .
  var MetaSubst : MetaSubst .

  eq substTerm((QT : QTNeList), MetaSubst)
   = substTerm(QT, MetaSubst) : substTerm(QTNeList, MetaSubst) .
  eq substTerm(.emptyTermList, MetaSubst) = .emptyTermList .
  eq substTerm(QT1, ((QT1 <- QT2) ; MetaSubst)) = QT2 .
 ceq substTerm('_`(_`)[QC : QTList], MetaSubst) = '_`(_`)[QC : QTList]
  if getName(QC) ==Bool ''@`assume_ orBool
     getName(QC) ==Bool ''@`assert_ orBool
     getName(QC) ==Bool ''@`invariant_ orBool
     getName(QC) ==Bool ''@`pre_ orBool
     getName(QC) ==Bool ''@`post_ .
 ceq substTerm(Q[QTList], MetaSubst) = Q[QTList]
  if Q ==Bool 'skolem orBool Q ==Bool 'co-skolem [owise] .
  eq substTerm(QC, MetaSubst) = QC [owise] .
  eq substTerm(Q[QTList], MetaSubst)
   = Q[substTerm(QTList, MetaSubst)] [owise] .


  var Pattern Pattern1 Pattern2 : Pattern .
  var CellLabel : CellLabel .
  var K : K .
  var List : List .
  var Bag : Bag .
  var Map : Map .
  var Phi : Formula .
  var Subst1 Subst2 : Subst .


  --- apply default substitution on a pattern
  eq applyDefaultSubst(Pattern1 \/ Pattern2, Subst)
   = applyDefaultSubst(Pattern1, Subst) \/ applyDefaultSubst(Pattern2, Subst) .
  eq applyDefaultSubst(Bag /\ Phi, Subst)
   = applyDefaultSubst(Bag, Subst) /\ Phi .

  --- apply default substitution on a configuration
  eq applyDefaultSubst(< CellLabel > Map1 </ CellLabel > Bag, (Map1 <- Map2) ;; Subst)
   = < CellLabel > Map2 </ CellLabel > applyDefaultSubst(Bag, Subst) .
  eq applyDefaultSubst(< CellLabel > K1 </ CellLabel > Bag, (K1 <- K2) ;; Subst)
   = < CellLabel > K2 </ CellLabel > applyDefaultSubst(Bag, Subst) .
  eq applyDefaultSubst(< CellLabel > Bag1 </ CellLabel > Bag2, Subst)
   = < CellLabel > applyDefaultSubst(Bag1, Subst) </ CellLabel >
     applyDefaultSubst(Bag2, Subst) [owise] .
  eq applyDefaultSubst(Bag, Subst) = Bag [owise] .


  --- apply substitution on a pattern
  eq applySubst(Pattern1 \/ Pattern2, Subst)
   = applySubst(Pattern1, Subst) \/ applySubst(Pattern2, Subst) .
  eq applySubst(Bag /\ Phi, Subst)
   = applySubst(Bag, Subst) /\ applySubst(Phi, Subst) .

  --- apply substitution on a configuration
 ceq applySubst(< CellLabel > Map </ CellLabel > Bag, Subst)
   = < CellLabel > Map </ CellLabel > applySubst(Bag, Subst)
  if CellLabel ==Bool struct orBool
     CellLabel ==Bool fun orBool
     CellLabel ==Bool tenv .
 ceq applySubst(< CellLabel > K </ CellLabel > Bag, Subst)
   = < CellLabel > K </ CellLabel > applySubst(Bag, Subst)
  if CellLabel ==Bool taskType orBool
     CellLabel ==Bool program orBool
     CellLabel ==Bool counter .
  eq applySubst(< CellLabel > Bag1 </ CellLabel > Bag2, Subst)
   = < CellLabel > applySubst(Bag1, Subst) </ CellLabel >
     applySubst(Bag2, Subst) [owise] .
  eq applySubst(Bag, Subst)
   = downTerm(substTerm(upTerm(Bag), upSubst(Subst)), errorBag) [owise] .

  --- apply substitution on a substitution
  eq applySubst(Phi, Subst)
   = downTerm(substTerm(upTerm(Phi), upSubst(Subst)), errorFormula) .

  --- apply substitution on a substitution
  eq applySubst(Subst1, Subst2)
   = downTerm(substTerm(upTerm(Subst1), upSubst(Subst2)), errorSubst) .
endm


mod UTILS is inc PATTERN-SKOLEM + APPLY-SUBST .
  var I : Int++ .
  eq isInt(I) = I :: Int .

  var Obj : MathObj++ .
  var PEObj : PEMathObj .
  var FEObj : FEMathObj .
  var FreeObj : FreeMathObj .
  var Phi : Formula .

  eq getPESubstItem(PEObj === Obj /\ Phi) = (PEObj <- Obj) .
  eq getPESubstItem(Obj === PEObj /\ Phi) = (PEObj <- Obj) .
  eq getPESubstItem(Phi) = .Subst [owise] .

  eq getFESubstItem(FEObj === Obj /\ Phi) = (FEObj <- Obj) .
  eq getFESubstItem(Obj === FEObj /\ Phi) = (FEObj <- Obj) .
  eq getFESubstItem(Phi) = .Subst [owise] .

  eq getFreeSubstItem(FreeObj === Obj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Obj === FreeObj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Phi) = .Subst [owise] .

  var Obj1 Obj2 Obj1' Obj2' : MathObj++ .
  var ObjList ObjList' : List{MathObj++} .
  eq (Obj1, Obj2, ObjList) <- (Obj1', Obj2', ObjList')
   = (Obj1 <- Obj1') ;; (Obj2 <- Obj2') ;; (ObjList <- ObjList') .

  var N : Nat .
  var Subst : Subst .
  var SubstItem : SubstItem .
  eq filterAnonymousFreeSubst(FreeInt(N) <- Obj) = .Subst .
  eq filterAnonymousFreeSubst(FreeSeq(N) <- Obj) = .Subst .
  eq filterAnonymousFreeSubst(FreeMSet(N) <- Obj) = .Subst .
  eq filterAnonymousFreeSubst(FreeTree(N) <- Obj) = .Subst .
  eq filterAnonymousFreeSubst(skolem(N, PEObj) <- Obj) = .Subst .
  eq filterAnonymousFreeSubst(SubstItem) = SubstItem [owise] .

  var List : List .
  var Bag : Bag .
  var Map : Map .
  var Var VarRoot : String .
 ceq filterFrame!Subst((!ListItem(Var) <- List) ;; Subst, VarRoot)
   = filterFrame!Subst(Subst, VarRoot)
  if substrString(Var,
                  lengthString(Var) -Int lengthString(VarRoot),
                  lengthString(VarRoot))
     ==Bool VarRoot .
 ceq filterFrame!Subst((!BagItem(Var) <- Bag) ;; Subst, VarRoot)
   = filterFrame!Subst(Subst, VarRoot)
  if substrString(Var,
                  lengthString(Var) -Int lengthString(VarRoot),
                  lengthString(VarRoot))
     ==Bool VarRoot .
 ceq filterFrame!Subst((!MapItem(Var) <- Map) ;; Subst, VarRoot)
   = filterFrame!Subst(Subst, VarRoot)
  if substrString(Var,
                  lengthString(Var) -Int lengthString(VarRoot),
                  lengthString(VarRoot))
     ==Bool VarRoot .
  eq filterFrame!Subst(SubstItem ;; Subst, VarRoot)
   = SubstItem ;; filterFrame!Subst(Subst, VarRoot) [owise] .
  eq filterFrame!Subst(.Subst, VarRoot) = .Subst .

  var FreeListItem : FreeListItem .
  var FreeBagItem : FreeBagItem .
  var FreeMapItem : FreeMapItem .
  eq filterCallCoSkolemSubst((co-skolem(N, FreeObj) <- Obj) ;; Subst)
   = filterCallCoSkolemSubst(Subst) .
  eq filterCallCoSkolemSubst((co-skolem(N, FreeListItem) <- List) ;; Subst)
   = filterCallCoSkolemSubst(Subst) .
  eq filterCallCoSkolemSubst((co-skolem(N, FreeBagItem) <- Bag) ;; Subst)
   = filterCallCoSkolemSubst(Subst) .
  eq filterCallCoSkolemSubst((co-skolem(N, FreeMapItem) <- Map) ;; Subst)
   = filterCallCoSkolemSubst(Subst) .
  eq filterCallCoSkolemSubst(SubstItem ;; Subst)
   = SubstItem ;; filterCallCoSkolemSubst(Subst) [owise] .
  eq filterCallCoSkolemSubst(.Subst) = .Subst . 
endm
