in ../../k-prelude
in challenge-syntax
in challenge-programs

mod CHALLENGE-SEMANTICS is including CHALLENGE-DESUGARED-SYNTAX + K .
  including PL-CONVERSION .
  subsort List{Exp} Stmt < K .
  sort Val .
  subsort Bool Int Float < Val < Exp .
  subsort List{Val} < KResult .

  ops env store nextLoc ptr fstack input output  aspect thread holds busy agents agent message from to body threads me parent nextAgent : -> CellLabel .
  configuration <T> 
   <agents>
    <agent*> 
     <threads>
      <thread*>
       <k> .K </k> <env> .Map </env> 
       <fstack> .List </fstack>
       <aspect> .K </aspect>
       <holds> .Map </holds>
      </thread*>
     </threads>
      <busy> .Bag </busy>
      <store> .Map </store> <nextLoc> 0 </nextLoc> 
      <ptr> .Map </ptr>
      <me> 0 </me>
      <parent> .K </parent> 
    </agent*>
   </agents>
   <nextAgent> 1 </nextAgent>
   <message*> 
      <from> .K </from> <to> .K </to> <body> .K </body>
   </message*>
   <input> .List </input>
   <output> .List </output>
  </T> .

  rule [I1 + I2 => I1 +Int I2] .
  rule [I1 + F2 => rat2floatConversion(I1) +Float F2] .
  rule [F1 + I2 => F1 +Float rat2floatConversion(I2)] .
  rule [F1 + F2 => F1 +Float F2] .
--- following rules for _*_ need to be written like that because of parsing ambiguities: a*b can also be seen as __(a,*b) ...
  rule [_*_(I1,I2) => I1 *Int I2] .
  rule [_*_(I1,F2) => rat2floatConversion(I1) *Float F2] .
  rule [_*_(F1,I2) => F1 *Float rat2floatConversion(I2)] .
  rule [_*_(F1,F2) => F1 *Float F2] .
  rule [I1 / I2 => I1 /Int I2] if I2 =/=Bool 0 .
  rule [I1 / F2 => rat2floatConversion(I1) /Float F2] if F2 =/=Bool 0.0 .
  rule [F1 / I2 => F1 /Float rat2floatConversion(I2)] if I2 =/=Bool 0 .
  rule [F1 / F2 => F1 /Float F2] if F2 =/=Bool 0.0 .
  rule [I1 <= I2 => I1 <=Int I2] .
  rule [I1 <= F2 => rat2floatConversion(I1) <=Float F2] .
  rule [F1 <= I2 => F1 <=Float rat2floatConversion(I2)] .
  rule [F1 <= F2 => F1 <=Float F2] .
  rule [V1 == V2 => V1 ==Bool V2] .
  rule [not T => notBool T] .
  rule [true and E => E] .
  rule [false and E => false] .

  rule [randomBool => true] .
  rule [randomBool => false] .
  
  rule <k> [var Xl ; => .K] ...</k>
       <env> [Env => Env[| Xl | from N / getList{K}(Xl)]] </env>
       <store>... [.Map => | Xl | from N |-> 0] ...</store>
       <nextLoc> [N => N +Nat | Xl |] </nextLoc>
   .
  rule <k> [X => K] ...</k>
        <env>... X |-> N ...</env>
        <store>... N |-> K ...</store> 
   .
  rule <k> [X = V ; => .K] ...</k>
        <env>... X |-> N ...</env>
        <store>... N |-> [? => V] ...</store> 
   .
  rule <k> [++ X => I +Int 1] ...</k>
        <env>... X |-> N ...</env>
        <store>... N |-> [I => I +Int 1] ...</store> 
   .

  rule [V ; => .K] .
  rule [S1 S2 => S1 ~> S2] [metadata "structural"] .

  rule [{} => .K] [metadata "structural"] .
  rule <k> [{S} => S ~> env(Env)] ...</k>
          <env> Env </env> .
  rule [if true then S1 else S2 => S1] .
  rule [if false then S1 else S2 => S2] .
  rule <k> [while E do S 
              => if E then S while E do S else {}] ...</k>
   [metadata "structural"] .

--- Pointers
  rule <k> [& X => N] ...</k> 
          <env>... X |-> N ...</env> .
  rule <k> [* N => V] ...</k>
          <store>... N |-> V ...</store> .
  rule <k> [malloc(N1) => N2] ...</k>
          <ptr>... [.Map => N2 |-> N1] ...</ptr>
          <store>... [.Map => N1 from N2 |-> 0] ...</store>
          <nextLoc> [N2 => N2 + N1] </nextLoc> .
  rule <k> [free(N2); => .K] ...</k>
          <ptr>... [N2 |-> N1 => .Map] ...</ptr>
          <store> [Store => Store[undef/ N1 from N2]] </store>
   .
       
  context * [HOLE] = ? ; .
  rule <k> [* N = V ; => .K] ...</k>
          <store>... N |-> [? => V] ...</store> .
  
--- Lists
  rule [head [V,Vl] => V] .
  rule [tail [V,Vl] => [Vl]] .
  rule [V : [Vl] => [V,Vl]] .
 
--- Functions
  rule <k> [aspect S => .K] ...</k> 
          <aspect> [? => S] </aspect> .
  op closure-lambda : List{Id} Stmt Map -> Val .
  rule <k> [lambda Xl . S1 => closure-lambda(Xl, (S2 S1), Env)] ...</k>
          <env> Env </env> <aspect> S2 </aspect> .
  op `(_`,_`) : K Map -> ListItem .
  rule <k> [_`(_`)(closure-lambda(Xl, S, Env),Vl) ~> K => S return 0 ;] </k>
    <env> [Env' => Env[| Xl | from N / getList{K}(Xl)]] </env>
    <fstack> [.List => (K,Env')] ...</fstack>
    <store>... [.Map => | Xl | from N |-> getList{K}(Vl)] </store>
    <nextLoc> [N => N +Nat | Xl |] </nextLoc> 
    .
  rule <k> [return V ; ~> ? => V ~> K] </k>
          <env> [? => Env] </env>
          <fstack> [(K,Env) => .List] ...</fstack> .

---(
---mu as in call-by-name
  op closure-mu : Exp Map -> K .
  rule <k> [mu X . E => closure-mu(E, Env[N / X])]...</k> <env> Env </env>
        <store>...[.Map => N |-> closure-mu(E, Env[N / X])]...</store> 
        <nextLoc> [N => sNat N] </nextLoc> .
  rule <k> [closure-mu(E, Env) => E ~> env(Env')] ...</k> 
       <env> [Env' => Env] </env> .
---)

---(
---mu through assigment (if X does not appear at top of E)
  rule <k>[mu X . E => var X ; ~> X = E ; ~> X ~> env(Env)]...</k>
       <env> Env </env> .
---)

---(
---mu just for functions
   context mu ? . [HOLE] .
   rule <k>[mu X . closure-lambda(Y,S,Env) => closure-lambda(Y,S,Env[N / X])]...</k> <store>...[.Map => N |-> closure-lambda(Y,S,Env[N / X])]...</store> <nextLoc>[N => sNat N]</nextLoc> .
---)

   op cc : K Map List -> Val .
   rule <k> [callcc(V) => _`(_`)(V, cc(K, Env, FStack))] ~> K </k> 
           <env> Env </env> 
           <fstack> FStack </fstack> .
   rule <k> [_`(_`)(cc(K, Env, FStack), V) ~> ?:K => V ~> K] </k>
           <env> [?:Map => Env] </env> 
           <fstack> [?:List => FStack] </fstack> .

   rule <k> [read => I] ...</k>
           <input> [ListItem(I) => .List] ...</input> .
   rule <k> [print V ; => .K] ...</k>
           <output>... [.List => ListItem(V)] </output> .

--- Threads
   rule <thread>... <k> [spawn S => .K] ...</k> <env> Env </env> ...</thread>
          [.Bag => <thread> <k> S </k> <env> Env </env> <fstack> .List </fstack> <aspect> .K </aspect> <holds> .Map </holds> </thread>] .
   rule [<thread>... <k> .K </k> <fstack> .List </fstack> <holds> Holds </holds> ...</thread> => .Bag]
           <busy> [Busy => Busy - keys(Holds)] </busy> .

   rule <k> [acquire V ; => .K] ...</k> <holds>... [.Map => V |-> 0] ...</holds> 
        <busy> Busy [.Bag => BagItem(V)] </busy> if notBool(V in Busy) .
   rule <k> [acquire V ; => .K] ...</k> <holds>... V |-> [N => sNat N] ...</holds> .
   rule <k> [release V ; => .K] ...</k> <holds>... V |-> [sNat N => N] ...</holds> .
   rule <k> [release V ; => .K] ...</k> <holds>... [V |-> 0 => .Map] ...</holds> 
        <busy>... [BagItem(V) => .Bag] ...</busy> .

   rule <k> [rv V ; => .K] ...</k> <k> [rv V ; => .K] ...</k> .

--- Agents
  rule <agent>... <k> [newAgent S => N2] ...</k> 
             <me> N1 </me>
          ...</agent>
     [.Bag => <agent> 
    <me> N2 </me>
    <parent> N1 </parent>
    <threads>
     <thread>
      <k> S </k> 
      <env> .Map </env>
      <fstack> .List </fstack>
      <aspect> .K </aspect>
      <holds> .Map </holds>
     </thread>
    </threads>
    <busy> .Bag </busy>
    <store> .Map </store>
    <nextLoc> 0 </nextLoc>
    <ptr> .Map </ptr>
   </agent>]
   <nextAgent> [N2 => sNat N2] </nextAgent> .
  rule [<agent>... <threads> .Bag </threads> ...</agent> 
        => .Bag] .

  rule <k> [me => N] ...</k> <me> N </me> .
  rule <k> [parent => N] ...</k> <parent> N </parent> .
  rule <me> N1 </me> <k> [send V to N2 ; => .K] ...</k> 
          [.Bag => <message> <from> N1 </from> <to> N2 </to> 
                     <body> V </body> </message>]
   . 
  rule <me> N </me> <k> [receive => V] ...</k> 
          [<message>... <to> N </to> <body> V </body> ...</message>
        => .Bag] . 
  rule <me> N1 </me> <k> [receiveFrom N2 => V] ...</k> 
          [<message> <from> N2 </from> <to> N1 </to> <body> V </body> 
          </message> => .Bag] . 
  rule <agent>... <me> N1 </me> <k> [sendSynch V to N2 ; => .K] ...</k>
          ...</agent>
          <agent>... <me> N2 </me> <k> [receiveFrom N1 => V] ...</k>
          ...</agent> .
  rule <k> [sendSynch V to N2 ; => .K] ...</k>
          <agent>... <me> N2 </me> <k> [receive => V] ...</k>
          ...</agent> .
 
--- Halt (thread, agent, system)
  rule <k> [haltThread ; ~> ? => .K] </k> <fstack> [? => .List] </fstack> .
  rule [<threads>... <k> haltAgent ; ...</k> ...</threads> => <threads> .Bag </threads>] .
  rule [<agents>... <k> haltSystem ; ...</k> ...</agents> => <agents> .Bag </agents>] .

--- Reflection
  op quoteit[_] : Nat -> KLabel .
  op code : List{K} -> Val .
  op _box(~>)_ : K K -> K [metadata "strict"] .
  op _box(,,)_ : K K -> K [metadata "strict"] .
  op box : KLabel -> KLabel .
  context box(Label)(?,,`[HOLE`]:K,,?) .
  
  rule <k> [quote E => quoteit[0](E)] ...</k> .
  rule [quoteit[N](quote(E)) => box('quote_)(quoteit[sNat(N)](E))] .
  rule [quoteit[0](unquote(E)) => E] .
  rule [quoteit[sNat(N)](unquote(E)) => box('unquote_)(quoteit[N](E))] .
  rule [quoteit[N](.K) => code(.K)] [metadata "structural"] .
  rule [quoteit[N]((K1 ~> K2)) => quoteit[N](K1) box(~>) quoteit[N](K2)] if K1 =/=Bool .K andBool K2 =/=Bool .K .
  rule [code(K1) box(~>) code(K2) => code((K1 ~> K2))] .
  rule [quoteit[N](Label(Kl)) => box(Label)(quoteit[N](Kl))] if Label =/=Bool 'quote_ andBool Label =/=Bool 'unquote_ .
  rule [box(Label)(code(Kl)) => code(Label(Kl))] .
  rule [quoteit[N](.List{K}) => code(.List{K})] .
  rule [quoteit[N]((Kl1,, Kl2)) => quoteit[N](Kl1) box(,,) quoteit[N](Kl2)] if Kl1 =/=Bool .List{K} andBool Kl2 =/=Bool .List{K} .
  rule [code(Kl1) box(,,) code(Kl2) => code((Kl1,, Kl2))] .
  rule [lift V => code(V)] .
  rule [eval code(K) => K]  .

----------------------------------------------
--- Auxilliary declarations and operations ---
----------------------------------------------
--- environment recovery
  op env : Map -> K .
  rule [env(?) ~> env(Env) => env(Env)] [metadata "structural"] .
  rule <k> [env(Env) => .K] ...</k> <env> [? => Env] </env> [metadata "structural"] .
  rule [V ~> env(Env) => env(Env) ~> V] [metadata "structural"] .

  op _[undef/_] : Map List{K} -> Map .
  eq Map[undef/ K,,K',,Kl] = Map[undef/ K][undef/ K'][undef/ Kl] .
  eq Map[undef/ .List{K}] = Map .
  eq (Map K |-> K')[undef/ K] = Map .
  eq Map[undef/ K] = Map [owise] .

--- List{Val}
  sort List{Val} .
  subsort Val < List{Val} < List{Exp} .
  op _,_ : List{Val} List{Val} -> List{Val} [ditto] .
--- length
  op |_| : List{Id} -> Nat .  eq | () | = 0 .  eq | X,Xl | = sNat(| Xl |) .
--- generate sequence of locations
  op _from_ : Nat Nat -> List{K} .  eq 0 from N1 = .List{K} .  eq (sNat N2 from N1) = (N1,,(N2 from sNat N1)) .

  vars I I1 I2 : Int .  vars F1 F2 : Float .  var T : Bool .  var X Y : Id . var Xl : List{Id} .  var E : Exp .  var El : List{Exp} .
  vars S S1 S2 : Stmt .  vars N N1 N2 : Nat .  var Env Env' Store Map : Map .  var Holds : Map .  var Busy : Bag .
  var FStack : List .  var V V1 V2 : Val .  var Vl : List{Val} .  var K K' K1 K2 : K . var Kl Kl1 Kl2 : List{K} .  var Label : KLabel .
endm

mod CHALLENGE is including CHALLENGE-SEMANTICS + CHALLENGE-PROGRAMS .
  op run : KLabel -> Bag .
  eq run(L:KLabel) = run(L:KLabel,.List{K}) .
  op run : KLabel List{K} -> Bag .
  eq run(L:KLabel,L:List{K}) = <T> 
   <agents>
    <agent>
     <threads>
      <thread>
       <k> L:KLabel(.List{K}) </k> 
       <env> .Map </env>
       <fstack> .List </fstack>
       <aspect> .K </aspect>
       <holds> .Map </holds>
      </thread>
     </threads>
     <busy> .Bag </busy>
     <store> .Map </store>
     <nextLoc> 0 </nextLoc>
     <ptr> .Map </ptr>
     <me> 0 </me>
    </agent>
   </agents>
   <nextAgent> 1 </nextAgent>
   <input> List(L:List{K}) </input>
   <output> .List </output>
  </T> .
endm
