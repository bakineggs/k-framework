mod CHALLENGE-PROGRAMS is 
  including CHALLENGE-SYNTAX .

  ops a b c f i j k m n s t x y z 
      odd even odd-calls even-calls goto exit : -> Id .
  op p1 : -> Exp .
  eq p1 = 3 + 5 .

  op p2 : -> Exp .
  eq p2 = (3 <= 5) and not (5.8 <= 1.0) .

  op p3 : -> Exp .
  eq p3 = randomBool and true .

  op p4 : -> Exp .
  eq p4 = (3 <= 5.2) and not (5.8 <= 1) .

  op p5 : -> Exp .
  eq p5 = 3 / 2 + 3 / 2.0 .

  op p6 : -> Stmt .
  eq p6 = var x,y ; y = 1.5 + ++ y ; print(y) ; .

  op p7 : -> Stmt .
  eq p7 = 
        var n, s, i ; 
         n = 100 ;
         s = 0 ;
         i = n ;
         while 1 <= i do (
           s = s + i ;
           i = i + -1 ;
          )
          print( s / (n + 0.0)) ; .

  op p8 : -> Stmt .
  eq p8 = var a,n,i,j,t ;
          n = 10 ;
          a = malloc(n) ;
          n = n + -1 ;
          i = -1 ;
          while (++ i <= n) do {
            *(a + i) = i ;
          }
          i = -1 ; 
          while (++ i <= n) do {
            j = i ;
            while (++ j <= n) do
              if *(a + i) <= * (a + j) then { 
                 t = * (a + i) ; 
                 * (a + i) = * (a + j) ;
                 * (a + j) = t ;
              } else {}
            print(*(a + i));
          }
  .
 
  op p9 : -> Stmt .
  eq p9 = var odd,even,odd-calls,even-calls ;
          aspect (odd-calls = odd-calls + 1 ;)
          odd = lambda x . (if not(0 <= x) then return even(x + 1); else if not(x <= 0) then return even(x + -1) ; else return false ;) ;
          aspect (even-calls = even-calls + 1 ;)
          even = lambda x . (if not(0 <= x) then return odd(x + 1); else if not(x <= 0) then return odd(x + -1) ; else return true ;) ;
          print(odd(read)) ; 
          print(even(read)) ;
          print(odd-calls) ;
          print(even-calls) ; .

  op p10 : -> Stmt .
  eq p10 = print((mu f . lambda x . if 2 <= x then return(f(x + -1) * x ); else return(x);)(10)) ; .

--- should evaluate to 0 not to 1 (mu is wrong the way it is)
  op p11 : -> Stmt .
  eq p11 = var y ; y = 0 ; var f ; f = lambda x . if (x <= 0) then return y ; else {var y ; y = 1 ; return f(x + -1) ;} ; print(f(1)) ; .

  op p12 : -> Stmt .
  eq p12 = var goto,n ; print(callcc (lambda exit . ((callcc (lambda k . (goto = k ;))) ; if n <= 10 then (n = n + 1 ;) else (exit (n) ;) return goto(0);))) ; .

  op p13 : -> Stmt .
  eq p13 = var x,y ;
           x = 1 ; y = 0 ;
           spawn (x = 0 ;)
           while (1 <= x) do (y = y + 1 ;)
           print(y);
        . 

  op p14 : -> Stmt .
  eq p14 =  var x ; 
                x = 1 ; 
                spawn (rv 1 ; print(x) ; rv 2 ;)
                spawn (rv 3 ; print(x) ; rv 4 ;)
                print(x) ;
                x = x + 1 ;
                rv 1 ;  rv 2 ;
                x = x + 1 ;
                rv 3 ; rv 4 ;
    .

  op p15 : -> Stmt .
  eq p15 = var x ; 
                x = 1 ; 
                spawn (x = x + 1 ; rv 1 ;)
                x = x + 1 ;
                rv 1 ;
                print(x) ;
     .
  op p16 : -> Stmt .
  eq p16 = var x ; 
                x = 1 ; 
                spawn (acquire 1 ; x = x + 1 ; release 1 ; rv 1 ;)
                acquire 1 ;
                x = x + 1 ;
                release 1 ;
                rv 1 ;
                print(x) ;
     .

  op p17 : -> Stmt .
  eq p17 = var x ; 
                x = 1 ; 
                spawn (acquire 1 ; rv 1 ; x = x + 1 ; haltThread ;)
                rv 1 ;
                acquire 1 ;
                x = x + 1 ;
                release 1 ;
                print(x) ;
     .

  op p18 : -> Stmt .
  eq p18 = var x,y,z ;
                x = 1 ; 
                y = newAgent(var y ; y = receiveFrom parent ; 
                     sendSynch me to y ; spawn haltAgent ; print(receive) ;) ; 
                z = newAgent(var z ; z = receive ; 
                     send 17 to z ; print(z);) ;
                send z to y ;
  .

  op p19 : -> Stmt .
  eq p19 = 
   var n,c,i,x ;
   n = 5 ;
   c = quote(1) ;
   i = 1 ;
   x = 10 ;
   while (i <= n) do (
     c = quote(unquote(c) + x) ;
     i = i + 1 ;
   )
   print(eval(c)); .

  op p20 : -> Stmt .
  eq p20 =
   var a,b,c ;
   c = 10 ;
   a = quoteEval c ;
   b = quote(quote(unquote(unquote(quoteEval c))));
   print(eval(b));
  .

  op p21 : -> Stmt .
  eq p21 = 
   var n,c,i,x ;
   n = 5 ;
   c = quote(1) ;
   i = 1 ;
   x = 10 ;
   while (i <= n) do (
     c = quote(quote(unquote(unquote(c))));
     i = i + 1 ;
   )
   print(eval(c)); .

  op p22 : -> Stmt .
  eq p22 = 
   var x ; 
   x = quote(2); 
   print(eval(quote(1 + 2 + unquote(x) + 4 + 5))); .

  op p23 : -> Stmt .
  ops genpow cube : -> Id .
  eq p23 = {
   var genpow ;
   genpow = lambda n . {
              if n <= 0
              then return quote 1 ;
              else return quote (x * unquote (genpow (n + -1))) ;
            } ;
   var cube ;
   cube = lambda x . { return eval genpow(3) ;} ;
   print cube(5) ;
   print cube(10) ;
 }
.

  op p24 : -> Stmt .
  ops f1 f2 fib loc code sender : -> Id .
  eq p24 = 
   var fib,loc ;
   fib = newAgent
   {
     var m, c, code ;
     m = receive ;
     send & c to head m ;
     code = eval receiveFrom head m ;
     aspect code() ;
     var f ;
     f = mu f . lambda x .
             if x <= 1 then { return x ; } else {
               var f1,f2 ;
               spawn {f1 = f(x + -1) ; rv & f1 ;}
               spawn {f2 = f(x + -2) ; rv & f2 ;}
               rv & f1 ; rv & f2 ;
               return f1 + f2 ;
             } ;
     send [f(head tail m),c] to head m ;
   } ;
   send [me,5] to fib ;
   loc = quoteEval receiveFrom fib ;
   send quote (lambda () . {acquire unquote loc ; * unquote loc = * unquote loc + 1 ; release unquote loc ;}) to fib ;
   print receiveFrom fib ;
.

  op p25 : -> Stmt .
  ops split splitl merge msort csort  ltoa atol length sort l left right msortAgent : -> Id .
  eq p25 = 
    var l,csort,ltoa,length,atol,sort,msortAgent ; 
    l = [1,7,3,5];
    msortAgent = newAgent {
      var split,merge,msort ;
      split = lambda l . {
        var t ;
        if l == [] then return [[],[]];
        else if tail l == [] then return [[head l],[]];
        else {
          t = split(tail tail l);
          return [head l : head t,head tail l : head tail t];
        }
      };
      merge = lambda (left,right) . {
        if left == [] then return right ;
        else if right == [] then return left ;
        else if (head left <= head right) 
        then return head left : merge(tail left,right) ;
        else return head right : merge(left, tail right);
      };
      var m , c, code ;
      m = receive ;
      send & c to m ;
      code = eval receiveFrom m ;
      aspect code() ;
      msort = lambda l . {
       if l == [] then return []; else if tail l == [] then return l ;
       else {
         var t,left,right ; t = split(l) ; 
         spawn {left = msort(head t) ; rv & left ;}
         right = msort(head tail t);
         rv & left ;
         return merge(left, right);
       }
      };
      while true do {
        m = receive ;
        spawn send [msort(head tail m),c] to head m ;
      }
    } ;
     csort = lambda (a,n) . {
      var i,j,t ;
      i = 0 ;
      while i + 2 <= n do {
        j = i + 1 ;
        while j + 1 <= n do  {
          if not(*(a + i) <= *(a + j)) 
          then {t = *(a + i); *(a + i) = *(a + j); *(a + j) = t ;}
          else {}
          ++ j ;
        }
        ++ i ;
     }
    } ;
    length = lambda l . {
      if l == [] then return 0 ; else return 1 + length(tail l);
    };
    ltoa = lambda l . {
      var a,i ; a = malloc length(l) ; i = 0 ;
      while not(l == []) do {
        *(a + i) = head l ; l = tail l ; ++ i ;
      }
      return [a,i] ; 
    };
    atol = lambda (a,n) . {
      if n == 0 then return []; else return * a : atol(a + 1, n + -1);
    };
   send me to msortAgent ;
   var loc ;
   loc = quoteEval receiveFrom msortAgent ;
   send quote (lambda () . {acquire unquote loc ; * unquote loc = * unquote loc + 1 ; release unquote loc ;}) to msortAgent ;
   send [me,l] to msortAgent ;
   sort = lambda l . {
      var t ; t = ltoa(l) ; 
      csort(head t,head tail t); 
      l = atol(head t,head tail t);
      free head t ;
      return l ;
    };
    spawn {send [sort(l),-1] to me ;}
    print receive ;

    haltSystem ;
  .
  
endm
