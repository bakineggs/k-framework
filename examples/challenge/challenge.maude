in ../../k-prelude
in challenge-syntax
in challenge-programs

mod CHALLENGE-SEMANTICS is including CHALLENGE-SYNTAX + K .
  including PL-CONVERSION .
  subsort List{Exp} Stmt < K .
  sort Val .
  subsort Bool Int Float < Val < Exp .
  subsort List{Val} < KResult .

  ops env store nextLoc ptr fstack input output  aspect thread holds busy agent message from to body threads me parent nextAgent : -> CellLabel .
  mb configuration < T > 
   < agent * > 
    < threads >
     < thread * >
      < k > .K </ k > < env > .Map </ env > 
      < fstack > .List </ fstack >
      < aspect > .K </ aspect >
      < holds > .Map </ holds >
     </ thread * >
    </ threads >
     < busy > .Bag </ busy >
     < store > .Map </ store > < nextLoc > 0 </ nextLoc > 
     < ptr > .Map </ ptr >
     < me > 0 </ me >
     < parent > .K </ parent > 
   </ agent * >
   < nextAgent > 1 </ nextAgent >
   < message * > 
      < from > .K </ from > < to > .K </ to > < body > .K </ body >
   </ message * >
   < input > .List </ input >
   < output > .List </ output >
  </ T > : KSentence .

  mb rule [I1 + I2 => I1 +Int I2] : KSentence .
  mb rule [I1 + F2 => floatConversion(I1) +Float F2] : KSentence .
  mb rule [F1 + I2 => F1 +Float floatConversion(I2)] : KSentence .
  mb rule [F1 + F2 => F1 +Float F2] : KSentence .
--- following needs to be written like that because of parsing ambiguities: a*b can also be seen as __(a,*b) ...
  mb rule [_*_(I1,I2) => I1 *Int I2] : KSentence .
  mb rule [_*_(I1,F2) => floatConversion(I1) *Float F2] : KSentence .
  mb rule [_*_(F1,I2) => F1 *Float floatConversion(I2)] : KSentence .
  mb rule [_*_(F1,F2) => F1 *Float F2] : KSentence .
  mb rule [I1 / I2 => I1 /Int I2] if I2 =/=Bool 0 : KSentence .
  mb rule [I1 / F2 => floatConversion(I1) /Float F2] if F2 =/=Bool 0.0 : KSentence .
  mb rule [F1 / I2 => F1 /Float floatConversion(I2)] if I2 =/=Bool 0 : KSentence .
  mb rule [F1 / F2 => F1 /Float F2] if F2 =/=Bool 0.0 : KSentence .
  mb rule [I1 <= I2 => I1 <=Int I2] : KSentence .
  mb rule [I1 <= F2 => floatConversion(I1) <=Float F2] : KSentence .
  mb rule [F1 <= I2 => F1 <=Float floatConversion(I2)] : KSentence .
  mb rule [F1 <= F2 => F1 <=Float F2] : KSentence .
  mb rule [not T => notBool T] : KSentence .
  mb rule [true and E => E] : KSentence .
  mb rule [false and E => false] : KSentence .

  mb rule [randomBool => true] : KSentence .
  mb rule [randomBool => false] : KSentence .
  
  mb rule < k > [var Xl ; => .K] ...</ k >
       < env > [Env => Env[| Xl | from N / getList{K}(Xl)]] </ env >
       < store >... [.Map => | Xl | from N |-> 0] ...</ store >
       < nextLoc > [N => N +Nat | Xl |] </ nextLoc >
   : KSentence .
  mb rule < k > [X => V] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> V ...</ store > 
   : KSentence .
  mb rule < k > [X = V => V] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> [? => V] ...</ store > 
   : KSentence .
  mb rule < k > [++ X => I +Int 1] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> [I => I +Int 1] ...</ store > 
   : KSentence .

  mb rule [V ; => .K] : KSentence .
  mb rule [S1 S2 => S1 ~> S2] : KSentence [metadata "structural"] .

  mb rule [{} => .K] : KSentence [metadata "structural"] .
  mb rule < k > [{S} => S ~> env(Env)] ...</ k >
          < env > Env </ env > : KSentence .
  mb rule [if true then S1 else S2 => S1] : KSentence .
  mb rule [if false then S1 else S2 => S2] : KSentence .
  mb rule < k > [while E do S 
              => if E then S while E do S else {}] ...</ k >
   : KSentence [metadata "structural"] .

--- Pointers
  mb rule < k > [& X => N] ...</ k > 
          < env >... X |-> N ...</ env > : KSentence .
  mb rule < k > [* N => V] ...</ k >
          < store >... N |-> V ...</ store > : KSentence .
  mb rule < k > [malloc(N1) => N2] ...</ k >
          < ptr >... [.Map => N2 |-> N1] ...</ ptr >
          < store >... [.Map => N1 from N2 |-> 0] ...</ store >
          < nextLoc > [N2 => N2 + N1] </ nextLoc > : KSentence .
  mb rule < k > [free(N2); => .K] ...</ k >
          < ptr >... [N2 |-> N1 => .Map] ...</ ptr >
          < store > [Store => Store[undef/ N1 from N2]] </ store >
   : KSentence .
       
  mb context * [HOLE] = ? : KSentence .
  mb rule < k > [* N = V => V] ...</ k >
          < store >... N |-> [? => V] ...</ store > : KSentence .
  
--- Functions
  mb rule < k > [aspect S => .K] ...</ k > 
          < aspect > [? => S] </ aspect > : KSentence .
  op closure : List{Id} Stmt Map -> Val .
  mb rule < k > [lambda Xl . S1 => closure(Xl, (S2 S1), Env)] ...</ k >
          < env > Env </ env > < aspect > S2 </ aspect > : KSentence .
  op `(_`,_`) : K Map -> ListItem .
  mb rule < k > [_`(_`)(closure(Xl, S, Env),Vl) ~> K => S] </ k >
    < env > [Env' => Env[| Xl | from N / getList{K}(Xl)]] </ env >
    < fstack > [.List => (K,Env)] ...</ fstack >
    < store >... [.Map => | Xl | from N |-> getList{K}(Vl)] </ store >
    < nextLoc > [N => N +Nat | Xl |] </ nextLoc > 
    : KSentence .
  mb rule < k > [return V ; ~> ? => V ~> K] </ k >
          < env > [? => Env] </ env >
          < fstack > [(K,Env) => .List] ...</ fstack > : KSentence .

   op cc : K Map List -> Val .
   mb rule < k > [callcc(V) => _`(_`)(V, cc(K, Env, FStack))] ~> K </ k > 
           < env > Env </ env > 
           < fstack > FStack </ fstack > : KSentence .
   mb rule < k > [_`(_`)(cc(K, Env, FStack), V) ~> ?:K => V ~> K] </ k >
           < env > [?:Map => Env] </ env > 
           < fstack > [?:List => FStack] </ fstack > : KSentence .
--- the following is nice, but wrong (in an interesting way - see p11)
   mb rule < k > [mu X . E => var X ; ~> X = E] ...</ k > : KSentence .

   mb rule < k > [read() => I] ...</ k >
           < input > [ListItem(I) => .List] ...</ input > : KSentence .
   mb rule < k > [print(V); => .K] ...</ k >
           < output >... [.List => ListItem(V)] </ output > : KSentence .

--- Threads
   mb rule < thread >... < k > [spawn S => .K] ...</ k > < env > Env </ env > ...</ thread >
          [.Bag => < thread > < k > S </ k > < env > Env </ env > < aspect > .K </ aspect > < holds > .Map </ holds > </ thread >] : KSentence .
   mb rule [< thread >... < k > .K </ k > < holds > Holds </ holds > ...</ thread > => .Bag]
           < busy > [Busy => Busy - keys(Holds)] </ busy > : KSentence .
   mb rule [< thread >... < k > halt-thread; ...</ k > < holds > Holds </ holds > ...</ thread > => .Bag]
           < busy > [Busy => Busy - keys(Holds)] </ busy > : KSentence .

   mb rule < k > [acquire V ; => .K] ...</ k > < holds >... V |-> [N => sNat N] ...</ holds > : KSentence .
   mb rule < k > [acquire V ; => .K] ...</ k > < holds >... [.Map => V |-> 0] ...</ holds > 
        < busy > Busy [.Bag => BagItem(V)] </ busy > if notBool(V in Busy) : KSentence .
   mb rule < k > [release V ; => .K] ...</ k > < holds >... V |-> [sNat N => N] ...</ holds > : KSentence .
   mb rule < k > [release V ; => .K] ...</ k > < holds >... [V |-> 0 => .Map] ...</ holds > 
        < busy >... [BagItem(V) => .Bag] ...</ busy > : KSentence .

   mb rule < k > [rv V ; => .K] ...</ k > < k > [rv V ; => .K] ...</ k > : KSentence .

--- Agents
  mb rule < agent >... < k > [new-agent S => N2] ...</ k > 
             < me > N1 </ me >
          ...</ agent >
     [.Bag => < agent > 
    < threads >
     < thread >
      < k > S </ k > 
      < env > .Map </ env >
      < fstack > .List </ fstack >
      < aspect > .K </ aspect >
      < holds > .Map </ holds >
     </ thread >
    </ threads >
    < busy > .Bag </ busy >
    < store > .Map </ store >
    < nextLoc > 0 </ nextLoc >
    < ptr > .Map </ ptr >
    < me > N2 </ me >
    < parent > N1 </ parent >
   </ agent >]
   < nextAgent > [N2 => sNat N2] </ nextAgent > : KSentence .
  mb rule [< agent >... < threads > .Bag </ threads > ...</ agent > 
        => .Bag] : KSentence .
  mb rule [< agent >... < k > halt-agent; ...</ k > ...</ agent > 
        => .Bag] : KSentence .

  mb rule < k > [me => N] ...</ k > < me > N </ me > : KSentence .
  mb rule < k > [parent => N] ...</ k > < parent > N </ parent > : KSentence .
  mb rule < me > N1 </ me > < k > [send-asynch(N2,V); => .K] ...</ k > 
          [.Bag => < message > < from > N1 </ from > < to > N2 </ to > 
                     < body > V </ body > </ message >]
   : KSentence . 
  mb rule < me > N </ me > < k > [receive => V] ...</ k > 
          [< message >... < to > N </ to > < body > V </ body > ...</ message >
        => .Bag] : KSentence . 
  mb rule < me > N1 </ me > < k > [receive-from(N2) => V] ...</ k > 
          [< message > < from > N2 </ from > < to > N1 </ to > < body > V </ body > 
          </ message > => .Bag] : KSentence . 
  mb rule < agent >... < me > N1 </ me > < k > [send-synch(N2,V); => .K] ...</ k >
          ...</ agent >
          < agent >... < me > N2 </ me > < k > [receive-from(N1) => V] ...</ k >
          ...</ agent > : KSentence .
  mb rule < agent >... < k > [send-synch(N2,V); => .K] ...</ k > ...</ agent >
          < agent >... < me > N2 </ me > < k > [receive => V] ...</ k >
          ...</ agent > : KSentence .
 
--- Reflection
  op quote[_] : Nat -> KLabel .
  op code : List{K} -> Val .
  op _box(~>)_ : K K -> K [metadata "strict"] .
  op _box(,,)_ : K K -> K [metadata "strict"] .
  op box : KLabel -> KLabel .
  mb context box(Label)(?,,`[HOLE`]:K,,?) : KSentence .
  
  mb rule < k > [quote E => quote[0](E)] ...</ k > : KSentence .
  mb rule [quote[N]((K1 ~> K2)) 
        => quote[N](K1) box(~>) quote[N](K2)] 
        if K1 =/=Bool .K andBool K2 =/=Bool .K : KSentence .
  mb rule [code(K1) box(~>) code(K2) => code((K1 ~> K2))] : KSentence .
  mb rule [quote[N](Label(Kl)) => box(Label)(quote[N](Kl))]
   if Label =/=Bool 'quote_ andBool Label =/=Bool 'unquote_ : KSentence .
  mb rule [box(Label)(code(Kl)) => code(Label(Kl))] : KSentence .
  mb rule [quote[N](quote(E)) 
        => box('quote_)(quote[sNat(N)](E))] : KSentence .
  mb rule [quote[0](unquote(E)) => E] : KSentence .
  mb rule [quote[sNat(N)](unquote(E)) 
        => box('unquote_)(quote[N](E))] : KSentence .

  mb rule [quote[N]((K,, Kl)) => quote[N](K) box(,,) quote[N](Kl)] 
        if Kl =/=Bool .List{K} : KSentence .
  mb rule [quote[N](.List{K}) => code(.List{K})] : KSentence .
  mb rule [code(K) box(,,) code(Kl) => code((K,, Kl))] : KSentence .

  mb rule [eval code(K) => K]  : KSentence .

----------------------------------------------
--- Auxilliary declarations and operations ---
----------------------------------------------
--- environment recovery
  op env : Map -> K .
  mb rule [env(?) ~> env(Env) => env(Env)] : KSentence [metadata "structural"] .
  mb rule < k > [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .
  mb rule < k > V ~> [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .

  op _[undef/_] : Map List{K} -> Map .
  eq Map[undef/ K,,K',,Kl] = Map[undef/ K][undef/ K'][undef/ Kl] .
  eq Map[undef/ .List{K}] = Map .
  eq (Map K |-> K')[undef/ K] = Map .
  eq Map[undef/ K] = Map [owise] .

--- List{Val}
  sort List{Val} .
  subsort Val < List{Val} < List{Exp} .
  op _,_ : List{Val} List{Val} -> List{Val} [ditto] .
--- length
  op |_| : List{Id} -> Nat .  eq | () | = 0 .  eq | X,Xl | = sNat(| Xl |) .
--- generate sequence of locations
  op _from_ : Nat Nat -> List{K} .  eq 0 from N1 = .List{K} .  eq (sNat N2 from N1) = (N1,,(N2 from sNat N1)) .

  vars I I1 I2 : Int .  vars F1 F2 : Float .  var T : Bool .  var X : Id . var Xl : List{Id} .  var E : Exp .  var El : List{Exp} .
  vars S S1 S2 : Stmt .  vars N N1 N2 : Nat .  var Env Env' Store Map : Map .  var Holds : Map .  var Busy : Bag .
  var FStack : List .  var V : Val .  var Vl : List{Val} .  var K K' K1 K2 : K . var Kl : List{K} .  var Label : KLabel .
endm

mod CHALLENGE is including CHALLENGE-SEMANTICS + CHALLENGE-PROGRAMS .
  op run : KLabel -> Bag .
  eq run(L:KLabel) = run(L:KLabel,.List{K}) .
  op run : KLabel List{K} -> Bag .
  eq run(L:KLabel,L:List{K}) = < T > 
   < agent >
    < threads >
     < thread >
      < k > L:KLabel(.List{K}) </ k > 
      < env > .Map </ env >
      < fstack > .List </ fstack >
      < aspect > .K </ aspect >
      < holds > .Map </ holds >
     </ thread >
    </ threads >
    < busy > .Bag </ busy >
    < store > .Map </ store >
    < nextLoc > 0 </ nextLoc >
    < ptr > .Map </ ptr >
    < me > 0 </ me >
   </ agent >
   < nextAgent > 1 </ nextAgent >
   < input > List(L:List{K}) </ input >
   < output > .List </ output >
  </ T > .
endm
