
kmod CHALLENGE-SYNTAX is including PL-INT + PL-FLOAT + PL-ID

--- Two syntactic categories, Exp and Stmt
  sorts Exp Stmt

--- Basic constructs for expressions
  subsorts Bool Int Float Id < Exp

--- Basic arithmetic operations; they will work with both integers and floats
--- NOTE: add more here
  op _+_ : Exp Exp -> Exp [gather(E e) prec 33 strict]
  op _*_ : Exp Exp -> Exp [gather(E e) prec 31 strict]
  op _/_ : Exp Exp -> Exp [gather(E e) prec 31 strict]
  op _<=_ : Exp Exp -> Exp [prec 37 metadata "latex(renameTo _\\ensuremath\\leq_)" seqstrict]
  op _==_ : Exp Exp -> Exp [prec 37 strict]
  op not_ : Exp -> Exp [prec 53 strict]
  op _and_ : Exp Exp -> Exp [gather(E e) prec 55 strict(1)]

--- Variable declarations
  op var_; : List{Id} -> Stmt [prec 2]

--- Variable assignment
  op _=_; : Exp Exp -> Stmt [prec 80 gather (e E) strict(2)]

--- Variable increment
  op ++_ : Id -> Exp [prec 0]

--- Basic statement constructs
  op {} : -> Stmt [metadata "latex(renameTo \\{\\})"] 
  op `{_`} : Stmt -> Stmt [gather(&) metadata "latex(renameTo \\{_\\})"]
  op __ : Stmt Stmt -> Stmt [prec 100 gather(e E)]
  op _; : Exp -> Stmt [prec 90 strict]
  op if_then_else_ : Exp Stmt Stmt -> Stmt [strict(1)]
  op while_do_ : Exp Stmt -> Stmt

--- I/O
  op read : -> Exp
  op print_; : Exp -> Stmt [strict]

--- Memory allocation and pointers
  op &_ : Id -> Exp [metadata "latex(renameTo \\&_)"]
  op *_ : Exp -> Exp [strict]
  op malloc_ : Exp -> Exp [strict]
  op free_; : Exp -> Stmt [strict]

--- Lists
  op [] : -> Exp
  op `[_`] : List{Exp} -> Exp [prec 0 seqstrict hybrid]
  op _:_ : Exp Exp -> Exp [strict]
  ops (head_) (tail_) : Exp -> Exp [prec 0 strict]

--- Aspects
  op aspect_ : Stmt -> Stmt [prec 90]

--- Functions
  op lambda_._ : List{Id} Stmt -> Exp [metadata "latex(renameTo \\ensuremath\\lambda_._)"]
  op _`(`) : Exp -> Exp
  op _`(_`) : Exp List{Exp} -> Exp [prec 2 strict]
  op return_; : Exp -> Stmt [strict]

--- Fixed point
  op mu_._ : Id Exp -> Exp [metadata "latex(renameTo \\ensuremath\\mu_._)"]

--- Callcc
  op callcc_ : Exp -> Exp [prec 50 strict]

--- Sequential non-determinism
  op randomBool : -> Exp

--- Threads
  op spawn_ : Stmt -> Stmt [prec 90]
  op acquire_; : Exp -> Stmt [strict]
  op release_; : Exp -> Stmt [strict]
  op rendezvous_; : Exp -> Stmt [strict]

--- Agents
  op newAgent_ : Stmt -> Exp
  op me : -> Exp
  op parent : -> Exp
  op receive : -> Exp
  op receiveFrom_ : Exp -> Exp [strict]
  op send_to_; : Exp Exp -> Stmt [strict]
  op sendSynch_to_; : Exp Exp -> Stmt [strict]
  op barrier ; : -> Stmt
  op broadcast_; : Exp -> Stmt [strict]

--- Abrupt termination (of thread, of agent, of system)
  op haltThread ; : -> Stmt
  op haltAgent ; : -> Stmt
  op haltSystem ; : -> Stmt

--- Code generation / reflection
  op quote_ : Exp -> Exp
  op unquote_ : Exp -> Exp
  op lift_ : Exp -> Exp [strict]
  op eval_ : Exp -> Exp [strict]
 
-----------------------------------------------------------------------------
--- Lists should be eventually builtin; for now, they need to be declared ---
-----------------------------------------------------------------------------
--- List{Id}
  sort List{Id}  subsort Id < List{Id}
  op `(`) : -> List{Id}
  op _`,_ : List{Id} List{Id} -> List{Id} [prec 70 assoc id: `(`)]
--- List{Exp}
  sort List{Exp}  subsort Exp List{Id} < List{Exp}
  op _`,_ : List{Exp} List{Exp} -> List{Exp} [ditto]
-----------------------------------------------------------------------------
endkm


kmod CHALLENGE-DESUGARED-SYNTAX is including CHALLENGE-SYNTAX 
------------------------------------------------------------------------------------
--- This module desugars some of SIMPLE's language constructs into the core ones ---
--- The idea is that we only want to give semantics to the core constructs,      ---
--- so we get rid of the derived ones asap (before we start the semantics        ---
------------------------------------------------------------------------------------
  kvars F X : Id  kvars Xl : List{Id}  kvars E E1 E2 : Exp  kvars S S' : Stmt 
  eq E() = E(`(`))
--- mu as syntactic sugar
  eq mu X . E = (lambda(). {var X ; X = E ; return X ;})()
  eq [] = [()]
endkm
