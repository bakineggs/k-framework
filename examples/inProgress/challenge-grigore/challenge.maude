in ../../../k-prelude
in challenge-syntax
in challenge-programs

mod CHALLENGE-SEMANTICS is including CHALLENGE-SYNTAX + K .
  including PL-CONVERSION .
  subsort List{Exp} Stmt < K .
  sort Val .
  subsort Bool Int Float < Val < Exp .
  subsort List{Val} < KResult .

  ops env store nextLoc ptr fstack : -> CellLabel .
  mb configuration < T > < k > .K </ k > < env > .Map </ env > 
     < fstack > .List </ fstack >
     < store > .Map </ store > < nextLoc > 0 </ nextLoc > 
     < ptr > .Map </ ptr >
   </ T > : KSentence .
  mb rule [I1 + I2 => I1 +Int I2] : KSentence .
  mb rule [I1 + F2 => floatConversion(I1) +Float F2] : KSentence .
  mb rule [F1 + I2 => F1 +Float floatConversion(I2)] : KSentence .
  mb rule [F1 + F2 => F1 +Float F2] : KSentence .
---(
  mb rule [I1 * I2 => I1 *Int I2] : KSentence .
  mb rule [F1 * I2 => floatConversion(F1) *Float I2] : KSentence .
  mb rule [I1 * F2 => I1 *Float floatConversion(F2)] : KSentence .
  mb rule [F1 * F2 => F1 *Float F2] : KSentence .
---)
  mb rule [I1 / I2 => I1 /Int I2] if I2 =/=Bool 0 : KSentence .
  mb rule [I1 / F2 => floatConversion(I1) /Float F2] 
     if F2 =/=Bool 0.0 : KSentence .
  mb rule [F1 / I2 => F1 /Float floatConversion(I2)] 
     if I2 =/=Bool 0 : KSentence .
  mb rule [F1 / F2 => F1 /Float F2] if F2 =/=Bool 0.0 : KSentence .
  mb rule [I1 <= I2 => I1 <=Int I2] : KSentence .
  mb rule [I1 <= F2 => floatConversion(I1) <=Float F2] : KSentence .
  mb rule [F1 <= I2 => F1 <=Float floatConversion(I2)] : KSentence .
  mb rule [F1 <= F2 => F1 <=Float F2] : KSentence .
  mb rule [not T => notBool T] : KSentence .
  mb rule [true and E => E] : KSentence .
  mb rule [false and E => false] : KSentence .

  mb rule [randomBool => true] : KSentence .
  mb rule [randomBool => false] : KSentence .
  
  mb rule < k > [vars Xl ; => .K] ...</ k > 
       < env > [Env => Env[| Xl | from N / getList{K}(Xl)]] </ env >
       < store >... [.Map => | Xl | from N |-> 0] ...</ store > 
       < nextLoc > [N => N +Nat | Xl |] </ nextLoc >
       : KSentence .
  mb rule < k > [X => V] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> V ...</ store > 
   : KSentence .
  mb rule < k > [X := V => V] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> [? => V] ...</ store > 
   : KSentence .
  mb rule < k > [++ X => I +Int 1] ...</ k >
        < env >... X |-> N ...</ env >
        < store >... N |-> [I => I +Int 1] ...</ store > 
   : KSentence .

  mb rule [V ; => .K] : KSentence .
  mb rule [S1 S2 => S1 ~> S2] : KSentence [metadata "structural"] .

  mb rule [{} => .K] : KSentence [metadata "structural"] .
  mb rule < k > [{S} => S ~> env(Env)] ...</ k >
          < env > Env </ env > : KSentence .
  mb rule [if true then S1 else S2 => S1] : KSentence .
  mb rule [if false then S1 else S2 => S2] : KSentence .
  mb rule < k > [while E do S 
              => if E then S while E do S else {}] ...</ k >
     : KSentence [metadata "structural"] .

--- Pointers
  mb rule < k > [& X => N] ...</ k > 
          < env >... X |-> N ...</ env > : KSentence .
  mb rule < k > [* N => V] ...</ k >
          < store >... N |-> V ...</ store > : KSentence .
  mb rule < k > [malloc(N1) => N2] ...</ k >
          < ptr >... [.Map => N2 |-> N1] ...</ ptr >
          < store >... [.Map => N1 from N2 |-> 0] ...</ store >
          < nextLoc > [N2 => N2 + N1] </ nextLoc > : KSentence .
  mb rule < k > [free(N2); => .K] ...</ k >
          < ptr >... [N2 |-> N1 => .Map] ...</ ptr >
          < store > [Store => Store[undef/ N1 from N2]] </ store >
       : KSentence .
       
  mb context * [HOLE] := ? : KSentence .
  mb rule < k > [* N := V => V] ...</ k >
          < store >... N |-> [? => V] ...</ store > : KSentence .
  
--- Functions

  op closure : List{Id} Exp Map -> Val .
  op `(_`,_`) : K Map -> ListItem .
  mb rule < k > [lambda Xl . E => closure(Xl, E, Env)] ...</ k >
          < env > Env </ env > : KSentence .
  mb rule < k > [_`(_`)(closure(Xl, E, Env),Vl) ~> K => E] </ k >
    < env > [Env' => Env[| Xl | from N / getList{K}(Xl)]] </ env >
    < fstack > [.List => (K,Env)] ...</ fstack >
    < store >... [.Map => | Xl | from N |-> getList{K}(Vl)] </ store >
    < nextLoc > [N => N +Nat | Xl |] </ nextLoc > 
    : KSentence .
  mb rule < k > V ~> [.K => K] </ k >
          < env > [? => Env] </ env >
          < fstack > [(K,Env) => .List] ...</ fstack > : KSentence . 


----------------------------------------------
--- Auxilliary declarations and operations ---
----------------------------------------------
--- environment recovery
  op env : Map -> K .
  mb rule [env(?) ~> env(Env) => env(Env)] : KSentence [metadata "structural"] .
  mb rule < k > [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .
  mb rule < k > V ~> [env(Env) => .K] ...</ k > < env > [? => Env] </ env > : KSentence [metadata "structural"] .

  op _[undef/_] : Map List{K} -> Map .
  eq Map[undef/ K,,K',,Kl] = Map[undef/ K][undef/ K'][undef/ Kl] .
  eq Map[undef/ .List{K}] = Map .
  eq (Map K |-> K')[undef/ K] = Map .
  eq Map[undef/ K] = Map [owise] .

--- List{Val}
  sort List{Val} .
  subsort Val < List{Val} < List{Exp} .
  op _,_ : List{Val} List{Val} -> List{Val} [ditto] .
--- length
  op |_| : List{Id} -> Nat .  eq | () | = 0 .  eq | X,Xl | = sNat(| Xl |) .
--- generate sequence of locations
  op _from_ : Nat Nat -> List{K} .  eq 0 from N1 = .List{K} .  eq sNat N2 from N1 = N1,,(N2 from sNat N1) .

  vars I I1 I2 : Int .  vars F1 F2 : Float .  var T : Bool .
  var X : Id . var Xl : List{Id} .  var E : Exp . var El : List{Exp} .
  vars S S1 S2 : Stmt .
  
  vars N N1 N2 : Nat .
  var Env Env' Store : Map . 
  var V : Val .  var Vl : List{Val} .

  var Map : Map . var K K' : K . var Kl : List{K} .
endm



mod CHALLENGE is including CHALLENGE-SEMANTICS + CHALLENGE-PROGRAMS .
  op run : KLabel -> Bag .
  eq run(L:KLabel) = < T > < k > L:KLabel(.List{K}) </ k > 
     < env > .Map </ env >
     < fstack > .List </ fstack >
     < store > .Map </ store >
     < nextLoc > 0 </ nextLoc >
     < ptr > .Map </ ptr >
   </ T > .
endm

