
%% This grammar is a transformed version from the ANSI-C grammar.
%% It has far less sorts, because more priorities have been used,
%% and optionals and lists have been inlined.
%%
%% It accepts more than ANSI-C because:
%%   * more combinations of Expressions are allowed, while still remaining 
%%     unambiguous, and priorities are according to the ANSI-C standard.
%%   * All type specifiers have been put into one non-terminal, so this
%%     grammar accepts more type incorrect C code than the ANSI-C grammar.
%%     For example: int main(static int a) is accepted, but illegal in ANSI-C.
%%
%% DONT: do not try to fully disambiguate this grammar because that would ruin
%%       its declarative nature. C is ambiguous. However, the expression
%%       grammar should be fully unambiguous (Expression).

definition

module Identifiers

exports

sorts Identifier AnonymousIdentifier Keyword

lexical syntax

"auto"			|
"break"			|
"case"			|
"char"			|
"const"			|
"continue"		|
"default"		|
"do"			|
"double"		|
"else"			|
"enum"			|
"extern"		|
"float"			|
"for"			|
"goto"			|
"if"			|
"int"			|
"long"		  	|
"register"		|
"return"		|
"short"			|
"signed"		|
"sizeof"		|
"static"		|
"struct"		|
"switch"		|
"typedef"		|
"union"			|
"unsigned"		|
"void"			|
"volatile"		|
"while"			-> Keyword

Keyword -> Identifier {reject}

lexical syntax

[a-zA-Z\_][a-zA-Z\_0-9]* -> Identifier
	                -> AnonymousIdentifier

lexical restrictions

Identifier -/- [0-9a-zA-Z\_] 

module Constants

exports

sorts HexadecimalConstant  IntegerConstant CharacterConstant FloatingPointConstant StringConstant Exponent

lexical syntax
[0] [xX] [a-fA-F0-9]+ [uUlL]*		-> HexadecimalConstant
[0-9]+ [uUlL]*		        	-> IntegerConstant
[L]? [\'] (([\\]~[])|~[\\\'])+ [\']	-> CharacterConstant

[Ee] [\+\-]? [0-9]+ -> Exponent

[0-9]+ 		   Exponent  [uUlL]?	-> FloatingPointConstant
[0-9]* [\.] [0-9]+ Exponent? [fFlL]?	-> FloatingPointConstant
[0-9]+ [\.]	   Exponent? [fFlL]?	-> FloatingPointConstant


[L]? [\"] ( ([\\]~[]) | ~[\\\"] )* [\"]	-> StringConstant

lexical restrictions

IntegerConstant 	-/- [0-9]
FloatingPointConstant	-/- [0-9]
HexadecimalConstant	-/- [a-fA-F0-9]

module Declarators[Declarator Identifier]

exports

sorts Pointer Expression Parameters 

context-free syntax

Pointer Declarator 			-> Declarator {non-assoc}
Identifier 				-> Declarator
"(" Declarator ")" 			-> Declarator {bracket}
Declarator "[" Expression? "]"		-> Declarator
Declarator "(" Parameters? ")" 		-> Declarator

context-free priorities
{
Declarator "(" Parameters? ")" 		-> Declarator
Declarator "[" Expression? "]" 	-> Declarator
}
> Pointer Declarator 			-> Declarator

module Expressions

imports Constants
imports Identifiers
imports Declarations

exports 

sorts Expression

context-free syntax

Identifier 				-> Expression 
HexadecimalConstant 			-> Expression {category("Constant")}
IntegerConstant				-> Expression {category("Constant")}
CharacterConstant 			-> Expression {category("Constant")}
FloatingPointConstant 			-> Expression {category("Constant")}
StringConstant 				-> Expression {category("Constant")}
"(" Expression ")" 			-> Expression {bracket}

context-free restrictions
"&" -/- [\&]
"-" -/- [\-]
"+" -/- [\+]

context-free priorities
{
Expression "[" Expression "]"	  -> Expression 
Expression "(" {Expression ","}* ")"  -> Expression 
Expression "." Identifier 		  -> Expression 
Expression "->" Identifier 	  -> Expression
Expression "++" 		           -> Expression
Expression "--" 		           -> Expression
} <0>
> 
{
"++" Expression 		 -> Expression
"--" Expression 		 -> Expression
"&" Expression 		 -> Expression
"*" Expression 	 	 -> Expression
"+" Expression 		 -> Expression
"-" Expression 		 -> Expression
"~" Expression 		 -> Expression
"!" Expression 		 -> Expression
"sizeof" Expression 	 -> Expression
"(" TypeName ")" Expression -> Expression 
}
> { left:
Expression "*" Expression -> Expression {left}
Expression "/" Expression -> Expression {left}
Expression "%" Expression -> Expression {left}}
> { left:
Expression "+" Expression -> Expression {left, cons("Plus")}
Expression "-" Expression -> Expression {left}}
> { left:
Expression "<<" Expression -> Expression {left}
Expression ">>" Expression -> Expression {left}}
> { left:
Expression "<" Expression -> Expression {left}
Expression ">" Expression -> Expression {left}
Expression "<=" Expression -> Expression {left}
Expression ">=" Expression -> Expression {left}
} >
{left:
Expression "==" Expression -> Expression {left}
Expression "!=" Expression -> Expression {left}
}
> Expression "&" Expression -> Expression {left}
> Expression "^" Expression -> Expression {left}
> Expression "|" Expression -> Expression {left}
> Expression "&&" Expression -> Expression {left}
> Expression "||" Expression -> Expression {left}
> Expression "?" Expression ":" Expression -> Expression {right}
<0,4> > 
{right:
Expression "=" Expression -> Expression {right}
Expression "*=" Expression -> Expression {right}
Expression "/=" Expression -> Expression {right}
Expression "%=" Expression -> Expression {right}
Expression "+=" Expression -> Expression {right}
Expression "-=" Expression -> Expression {right}
Expression "<<=" Expression -> Expression {right}
Expression ">>=" Expression -> Expression {right}
Expression "&=" Expression -> Expression {right}
Expression "^=" Expression -> Expression {right}
Expression "|=" Expression -> Expression {right}
}
>
Expression "," Expression -> Expression {left}


context-free priorities
Expression "?" Expression ":" Expression -> Expression {right}
 <0> >
Expression "?" Expression ":" Expression -> Expression


module Declarations

%% The syntax of abstract declarators and declarators is so similar, that
%% we could make a parameterized module for them:
imports Declarators[Declarator Identifier]
imports Declarators[AbstractDeclarator AnonymousIdentifier]
imports Identifiers
imports Expressions

exports

sorts Declaration InitDeclarator Specifier StructDeclaration StructDeclarator Parameters  MoreParameters
sorts Initializer TypeName Pointer Enumerator AbstractDeclarator Declarator Parameter

context-free syntax
Specifier+ {InitDeclarator ","}+ ";" -> Declaration
Specifier+ ";"                       -> Declaration {avoid}

context-free syntax
Declarator                 -> InitDeclarator
Declarator "=" Initializer -> InitDeclarator

context-free syntax
Identifier		-> Specifier 

"typedef"		-> Specifier
"extern"			-> Specifier
"static"			-> Specifier
"auto"			-> Specifier
"register"		-> Specifier
"void"			-> Specifier
"char" 			-> Specifier
"short" 			-> Specifier
"int" 			-> Specifier
"long"			-> Specifier
"float" 			-> Specifier
"double"			-> Specifier
"signed"			-> Specifier
"unsigned" 		-> Specifier
"const"    		-> Specifier
"volatile" 		-> Specifier

context-free syntax
"struct"|"union" Identifier "{" StructDeclaration+ "}" -> Specifier
"struct"|"union"            "{" StructDeclaration+ "}" -> Specifier
"struct"|"union" Identifier                            -> Specifier

context-free syntax
"enum"            "{" {Enumerator ","}+  "}"	 -> Specifier
"enum" Identifier "{" {Enumerator ","}+  "}"	 -> Specifier
"enum" Identifier                                -> Specifier

lexical restrictions
	"return" -/- [0-9a-zA-Z\_]
	"enum" -/- [0-9a-zA-Z\_]
	"struct" | "union" -/- [0-9a-zA-Z\_]

context-free syntax
Specifier+ {StructDeclarator ","}+ ";" -> StructDeclaration

context-free syntax
Declarator                -> StructDeclarator
           ":" Expression -> StructDeclarator
Declarator ":" Expression -> StructDeclarator


context-free syntax
Identifier 		-> Enumerator
Identifier "=" Expression 	-> Enumerator

context-free syntax

("*" Specifier*)+ -> Pointer

context-free syntax
{Parameter ","}+ MoreParameters? -> Parameters

context-free syntax
"," "..." -> MoreParameters

context-free syntax
Specifier+ Declarator 		-> Parameter
Specifier+ AbstractDeclarator 	-> Parameter

context-free syntax
Specifier+ AbstractDeclarator	-> TypeName

context-free syntax
Expression 		  -> Initializer
"{" {Initializer ","}+ ","?  "}"  -> Initializer

%% The , needs some extra attention, in order to give the initializer
%% separator and actual argument separator a higher priority than the
%% left associative comma expression.

context-free syntax 
%% for documentation purposes we repeat here a production that is 
%% otherwise also generated by the normalizer from {Expression ","}+
Expression                -> {Expression ","}+ 

context-free priorities
Expression                -> Initializer >
Expression "," Expression -> Expression,

Expression                -> {Expression ","}+ >
Expression "," Expression -> Expression,

Identifier "=" Expression -> Enumerator >
Expression "," Expression -> Expression


module Statements

imports Expressions
imports Declarations

exports

sorts Statement

context-free syntax
"{" Declaration* Statement*  "}" 			-> Statement
Identifier ":" Statement 				-> Statement
"case" Expression ":" Statement 			-> Statement
"default" ":" Statement 				-> Statement
";" 							-> Statement
Expression ";" 						-> Statement
"if" "(" Expression ")" Statement 		   	-> Statement
"if" "(" Expression ")" Statement "else" Statement 	-> Statement
"switch" "(" Expression ")" Statement 		   	-> Statement
"while" "(" Expression ")" Statement 			-> Statement
"do" Statement "while" "(" Expression ")" ";" 		-> Statement
"for" "(" Expression? ";" Expression? ";" Expression? ")" Statement	
							-> Statement
"goto" Identifier ";" 					-> Statement
"continue" ";" 						-> Statement
"break" ";" 						-> Statement
"return" ";" 						-> Statement
"return" Expression ";" 				-> Statement

module C

imports Declarations
imports Statements

exports

sorts ExternalDeclaration FunctionDefinition TranslationUnit

context-free syntax
ExternalDeclaration+ 	-> TranslationUnit

context-free syntax
FunctionDefinition 	-> ExternalDeclaration
Declaration 		-> ExternalDeclaration

context-free syntax
Specifier* Declarator Declaration* "{" Declaration* Statement* "}" -> FunctionDefinition


module Whitespace

exports

lexical syntax

[\ \t\n\r\11\12] -> LAYOUT

context-free restrictions

LAYOUT? -/- [\ \t\n\r\11\12]

module Comments

exports

sorts Comment Asterisk

lexical syntax
	[\/][\*] ( ~[\*] | Asterisk )* [\*][\/] -> Comment {category("Comment")}
	[\*] 				-> Asterisk

lexical restrictions
	Asterisk -/- [\/]

module CommentsAsLayout
imports Comments

exports

lexical syntax
  Comment -> LAYOUT

lexical restrictions
LAYOUT? -/- [\/].[\*]

module Main

imports CommentsAsLayout
imports Whitespace
imports C

hiddens

context-free start-symbols
	TranslationUnit
    FunctionDefinition
    Expression


