mod COMMON-STATEMENTS-INCLUDE is
	including COMMON-INCLUDE .
	op preparedWhile : K K -> K .
endm

mod COMMON-SEMANTICS-IF-THEN is
	including COMMON-STATEMENTS-INCLUDE .
	
	--- fixme need to represent null with 0
	mb [if-then-true]: rule
		< k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ~> S:Statement ...</ k >
		if notBool(V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool loc(0, 0) orBool V:BaseValue ==Bool 0.0)
		: KSentence [metadata "structural"] . --- nondet
	mb [if-then-false]: rule
		< k > (if (tv(V:BaseValue, ?)) S:Statement => sequencePoint) ...</ k >
		if (V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool loc(0, 0) orBool V:BaseValue ==Bool 0.0)
		: KSentence [metadata "structural"] . --- nondet
		
	mb [if-then-else-true]: rule
		< k > if (tv(V:BaseValue, ?)) S:Statement else S':Statement => sequencePoint ~> S:Statement ...</ k >
		if notBool(V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool loc(0, 0) orBool V:BaseValue ==Bool 0.0)
		: KSentence [metadata "structural"] . --- nondet
	mb [if-then-else-false]: rule
		< k > if (tv(V:BaseValue, ?)) S:Statement else S':Statement => sequencePoint ~> S':Statement ...</ k >
		if (V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool loc(0, 0) orBool V:BaseValue ==Bool 0.0)
		: KSentence [metadata "structural"] . --- nondet
endm

mod COMMON-SEMANTICS-WHILE is
	including COMMON-STATEMENTS-INCLUDE .
	
	mb [while-mark]: rule
		< k > while (B:Expression) S:Statement ~> K:K
			=> preparedWhile(B:Expression, S:Statement) ~> (break ;)
		</ k >
		< loopStack > ((.).List => ListItem(K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [while]: rule
		< k > preparedWhile(B:Expression, S:Statement)
			=> 'if`(_`)_(B:Expression,, S:Statement ~> preparedWhile(B:Expression, S:Statement))
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SWITCH is
	including COMMON-STATEMENTS-INCLUDE .
	
	--- fixme shouldn't there be sequence points here?
	mb rule
		< k > 'switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K </ k >
		< currentFunction > F:Id </ currentFunction >
		< loopStack > (? => S:List) </ loopStack >
		< gotoMap >... kpair(F:Id, case(SN:Nat, V:BaseValue)) |-> kpair(K2:K, S:List) ...</ gotoMap >
		: KSentence [metadata "computational"] .
	mb rule
		< k > 'switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K </ k >
		< currentFunction > F:Id </ currentFunction >
		< loopStack > (? => S:List) </ loopStack >
		< gotoMap > LM:Map kpair(F:Id, defaultCase(SN:Nat)) |-> kpair(K2:K, S:List) </ gotoMap >
		if notBool $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
		: KSentence [metadata "computational"] .
	mb rule
		< k > ('switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) => (.).K) ...</ k >
		< currentFunction > F:Id </ currentFunction >
		< gotoMap > LM:Map </ gotoMap >
		if notBool (
			$hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
			orBool $hasMapping(LM:Map, kpair(F:Id, defaultCase(SN:Nat)))
		)
		: KSentence [metadata "computational"] .

	mb [case-fall-through]: rule
		< k > ('case`(_`)_:_(?,, ?,, K:K) => K:K) ...</ k >
		: KSentence [metadata "structural"] .
	mb [default-fall-through]: rule
		< k > ('default`(_`):_(?,, K:K) => K:K) ...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-GOTO is
	including COMMON-STATEMENTS-INCLUDE .
	
	mb context calculateGotoMap(?, ('case`(_`)_:_(?:K,,`[HOLE`]:K,, ?) ~> ?), ?, ?) : KSentence .
	
	--- fixme shouldn't there be sequence points here?
	mb [goto]: rule 
		< k > goto(X:Id); ~> ? => K:K </ k >
		< currentFunction > F:Id </ currentFunction >
		< loopStack > (? => S:List) </ loopStack >
		< gotoMap >... kpair(F:Id, X:Id) |-> kpair(K:K, S:List) ...</ gotoMap >
		: KSentence [metadata "computational rule"] .
		
	op calculateGotoMap : Id K List K -> K . --- func name, body, loop stack, tail
	eq calculateGotoMap(X:Id, K:K) = calculateGotoMap(X:Id, K:K, (.).List, (.).K) .
	mb rule 
		< k > (calculateGotoMap(?, (.).K, ?, ?) => (.).K) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, (L:KLabel(Args:List{K}) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, K:K, S:List, Tail:K) ...</ k >
		if L:KLabel ==Bool 'Local
		orBool L:KLabel ==Bool '_; --- assumes we don't put '_; around actual statements
		orBool L:KLabel ==Bool 'goto_;
		orBool L:KLabel ==Bool 'continue`;
		orBool L:KLabel ==Bool 'break`;
		orBool L:KLabel ==Bool 'return`;
		orBool L:KLabel ==Bool 'return_;
		---orBool L:KLabel ==Bool 'default`:_
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, ('Block(.List{K}) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, K:K, S:List, Tail:K) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, ('Block(Arg:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, (L:KLabel(?,, Arg:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K) ...</ k >
		if L:KLabel ==Bool 'if`(_`)_
		---orBool L:KLabel ==Bool 'case_:_
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, ('if`(_`)_else_(?,, Arg1:K,, Arg2:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, Arg1:K, S:List, (Tail:K ~> K:K))
		~> calculateGotoMap(X:Id, Arg2:K, S:List, (Tail:K ~> K:K))
		~> calculateGotoMap(X:Id, K:K, S:List, Tail:K)
		...</ k >
		: KSentence [metadata "structural"] .	
	
	mb rule 
		< k > calculateGotoMap(X:Id, ('_:_(Target:Id,, Arg:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K) ...</ k >
		< gotoMap >... (.).Map => kpair(X:Id, Target:Id) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List) ...</ gotoMap >
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > calculateGotoMap(X:Id, ('case`(_`)_:_(SN:Nat,, tv(Target:BaseValue, T:Type),, Arg:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K) ...</ k >
		< gotoMap >... (.).Map => kpair(X:Id, case(SN:Nat, Target:BaseValue)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List) ...</ gotoMap >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > calculateGotoMap(X:Id, ('default`(_`):_(SN:Nat,, Arg:K) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K) ...</ k >
		< gotoMap >... (.).Map => kpair(X:Id, defaultCase(SN:Nat)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List) ...</ gotoMap >
		: KSentence [metadata "structural"] .

	mb rule 
		< k > calculateGotoMap(X:Id, ('while`(_`)_(B:Expression,, S:Statement) ~> K:K), S':List, Tail:K) 
			=> calculateGotoMap(X:Id, 
				(S:Statement ~> preparedWhile(B:Expression, S:Statement) ~> (break ;)),
				(ListItem((K:K ~> Tail:K)) S':List),
				Tail:K)
			...</ k >
		: KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > calculateGotoMap(X:Id, (preparedWhile(B:Expression, S:Statement) ~> (break ;)), (ListItem((K:K ~> Tail:K)) S':List), Tail:K)
		--- => calculateGotoMap(X:Id, K:K, S':List, Tail:K) ...</ k >
		--- : KSentence [metadata "structural"] .
		
	mb rule 
		< k > calculateGotoMap(X:Id, (preparedWhile(B:Expression, S:Statement) ~> (break ;)), (ListItem(K:K) S':List), Tail:K)
		=> calculateGotoMap(X:Id, K:K, S':List, Tail:K) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule 
		< k > calculateGotoMap(X:Id, ('switch`(_`)`(_`)_(?,, B:Expression,, S:Statement) ~> K:K), S:List, Tail:K) 
		=> calculateGotoMap(X:Id,
			(S:Statement ~> (break ;) ~> popLoop),
			(ListItem((K:K ~> Tail:K)) S:List),
			Tail:K) ...</ k >
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > calculateGotoMap(X:Id, popLoop, (ListItem(K:K) S:List), Tail:K)
		=> calculateGotoMap(X:Id, K:K, S:List, Tail:K) ...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-RETURN is
	including COMMON-STATEMENTS-INCLUDE .
	
	--- fixme can be combined into one cleaning rule
	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... (BagItem(loc(Block:Nat, ?)) => (.).Bag) ...</ locals >
		< buffer > (.).List </ buffer >
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... (BagItem(loc(Block:Nat, ?)) => (.).Bag) ...</ locals >	
		< buffer > (.).List </ buffer >
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .

	--- this is used for threads
	mb [return-nostack]: rule 
		< k > L:KLabel(?) ~> ? => (.).K </ k >
		< callStack > (.).List </ callStack >
		if L:KLabel ==Bool 'return`;
		orBool L:KLabel ==Bool 'return_;
		: KSentence [metadata "structural"] .
		
	--- fixme shouldn't there be sequence points here?
	mb [return]: rule 
		< k > return ; ~> ? => skipval ~> K:K </ k >
		< env > (? => E:Map) </ env >
		< locals > ((.).Bag => L:Bag) </ locals >
		< loopStack > (? => LS:List) </ loopStack >
		< types > (? => T:Map) </ types >
		< currentFunction > (? => X:Id) </ currentFunction >
		< callStack >
			List(
				< stackFrame >...
					< currentFunction > X:Id </ currentFunction >
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
		
	mb [return-value]: rule 
		< k > return V:Value ; ~> ? => sequencePoint ~> V:Value ~> K:K </ k >
		< env > (? => E:Map) </ env >
		< locals > ((.).Bag => L:Bag) </ locals >
		< loopStack > (LS':List => LS:List) </ loopStack >
		< types > (? => T:Map) </ types >
		< currentFunction > (? => X:Id) </ currentFunction >
		< callStack >
			List(
				< stackFrame >...
					< currentFunction > X:Id </ currentFunction >
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-STATEMENTS is
	including COMMON-STATEMENTS-INCLUDE .
	including COMMON-SEMANTICS-IF-THEN .
	including COMMON-SEMANTICS-WHILE .
	including COMMON-SEMANTICS-SWITCH .
	including COMMON-SEMANTICS-GOTO .
	including COMMON-SEMANTICS-RETURN .
			
	mb rule (EmptyStatement ; => (.).K) : KSentence [metadata "structural"] .
	mb rule (Block`(`) => (.).K) : KSentence [metadata "structural"] .
	
	--- replace sequencing with ~>
	mb rule S1:Statement S2:Statement => S1:Statement ~> S2:Statement : KSentence [metadata "structural"] .
		
	--- skip labels
	mb [skip-label]: rule < k > (L:Id : S:Statement => S:Statement) ...</ k > : KSentence [metadata "structural"] .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > (Block(B:SeqList) => B:SeqList) ...</ k > : KSentence [metadata "structural"] .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > (V:Value ; => sequencePoint) ...</ k > : KSentence [metadata "structural"] .
	
	--- on K, poploop is a nop.
	mb [popLoop]: rule
		< k > (popLoop => (.).K) ...</ k >
		--- < loopStack > (Li:ListItem => (.).List) ...</ loopStack >
		: KSentence [metadata "structural"] .
		
	mb [break]: rule
		< k > break ; ~> ? => K:K </ k >
		< loopStack > (ListItem(K:K) => (.).List) ...</ loopStack >
		: KSentence [metadata "computational"] . --- nondet
	
	--- fixme not sure about this, isn't it possible for K:K to grab greedily?
	--- mb [continue]: rule
		--- < k > continue ; ~> K:K => continue ; ...</ k >
		--- if K:K =/=Bool loopMarked
		--- : KSentence [metadata "structural"] . --- nondet
	--- mb [continue-done]: rule
		--- < k > (continue ; => (.).K) ~> loopMarked ...</ k >
		--- : KSentence [metadata "structural"] . --- nondet
endm
