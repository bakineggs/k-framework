mod COMMON-SEMANTICS-TYPE-DECLARATIONS is
	including COMMON-INCLUDE .
	
	mb rule
		< k > (... => typedDeclaration(no-type, ...)) ...</ k > 
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > ('Declaration(T:Type,, X:Id) => typedDeclaration(T:Type, X:Id)) ...</ k > 
		: KSentence [metadata "structural"] .
	
	mb [typedef-declaration] : rule
		< k > ('Typedef(T:Type,, X:Typedef-Name) => definedType(T:Type, X:Typedef-Name)) ...</ k >
		--- < types >... [(.).Map => X:Typedef-Name |-> T:Type] ...</ types >
		--- < typedefs >... [(.).Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > (giveGlobalType(T:Type, X:K) => (.).K) ...</ k >
		< types > (M:Map => M:Map[T:Type / X:K]) </ types >
		< typedefs > (M':Map => M':Map[T:Type / X:K]) </ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > (giveLocalType(T:Type, X:K) => (.).K) ...</ k >
		< types > (M:Map => M:Map[T:Type / X:K]) </ types >
		: KSentence [metadata "structural"] .
		
	mb [global-declaration] : rule
		< k > ('Global(definedType(T:Type, X:K)) => giveGlobalType(T:Type, X:K)) ...</ k >
		: KSentence [metadata "structural"] .
	
	
	op declarators : -> Set [memo] .
	eq declarators = Set(l('Declaration),, l('Field),, l('Parameter-Declaration),, l('Typedef),, l('Pointer)) .
	
	--- fixme hack for (int )(b705 + 0)->b6[0].b4.b1)
	mb rule 
		< type > (X:Id + I:Int => X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule 
		< type > (X:Id - I:Int => X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	
	--- these happen during casts to int* or int[5]
	--- not at < k > because these happen in < type > too
	mb rule 
		'_`[_`](T:Type,, N:Nat) => arrayType(T:Type, N:Nat)
		: KSentence [metadata "structural"] .
	--- fixme there should really be many different pointers
	mb rule 
		('Pointer(T:Type) => pointerType(T:Type))
		: KSentence [metadata "structural"] .
	mb rule 
		('Pointer(T:Type,, ?:Id) => pointerType(T:Type))
		: KSentence [metadata "structural"] .
	mb rule 
		('Direct-Function-Declarator(PTL:Parameter-Type-List) => 'Direct-Function-Declarator(anonymousId,, PTL:Parameter-Type-List))
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > ('Global(skipval) => (.).K ) ...</ k >
		: KSentence [metadata "structural"] .
	
	--- move "Pointer" to where it belongs
	mb rule
		< k > (L:KLabel(T:Type,, Pointer(D:Declarator)) => L:KLabel(pointerType(T:Type),, D:Declarator)) ...</ k > 
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .

	mb rule
		< k > L:KLabel(T:Type,, 'Direct-Function-Declarator(D:Declarator,, PTL:KResult))
		=> L:KLabel(functionType(T:Type, PTL:KResult),, D:Declarator) ...</ k > 
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > L:KLabel((X:Id => T:Type),, D:Declarator) ...</ k >
		< typedefs >... typedefName(X:Id) |-> T:Type ...</ typedefs >
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > L:KLabel(T:Type,, '_`[_`](K:K,, tv(N:Nat, ?:Base-Type))) => L:KLabel(arrayType(T:Type, N:Nat),, K:K) ...</ k >
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .
	mb rule 
		(L:KLabel(T:Type,, 'BitField(D:K,, N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, D:K))
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .
	mb rule 
		(L:KLabel(T:Type,, 'BitField(N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, unnamedBitField))
		if declarators contains l(L:KLabel)
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-TYPE-STRICTNESS is
	including COMMON-INCLUDE .

	mb context ?:KLabel(?,, 'Direct-Function-Declarator(D:Declarator,, `[HOLE`]:K)) : KSentence .
	
	mb rule
		< k > ('Parameter-Type-List(V:KResult) => typedParameterList(getList{K}(V:KResult))) ...</ k > : KSentence [metadata "structural"] .
	
	mb rule
		< k > ('Parameter-Declaration(T:Type,, X:Id) => typedDeclaration(T:Type, X:Id)) ...</ k > : KSentence [metadata "structural"] .
	mb rule
		< k > ('Parameter-Declaration(T:Type) => typedDeclaration(T:Type, anonymousId)) ...</ k > : KSentence [metadata "structural"] .

	mb context 'Field(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Declaration(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Parameter-Declaration(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Typedef(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
				
	mb [type-arrow-heat]: rule
		< type > '_->_(Kp:KProper,, X:Id) => Kp:KProper ~> '_->_(HOLE,, X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-arrow-cool]: rule
		< type > T:Type ~> '_->_(HOLE,, X:Id) => '_->_(T:Type,, X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-dot-heat]: rule
		< type > '_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-dot-cool]: rule
		< type > T:Type ~> '_._(HOLE,, X:Id) => '_._(T:Type,, X:Id) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > '_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > T:Type ~> Deref(HOLE) => 'Deref(T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-heat-deref]: rule
		< type > 'Deref(Kp:KProper) => Kp:KProper ~> Deref(HOLE) ...</ type >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-TYPING is
	including COMMON-SEMANTICS-TYPE-STRICTNESS .
	including COMMON-SEMANTICS-TYPE-DECLARATIONS .
	
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	op isAType_ : K -> Bool .
	ceq isAType T:Type = true
		if setOfTypes contains l(getKLabel(T:Type)) .
	eq isAType T:Base-Type = true .
	
	--- fixme ignoring qualifiers
	mb rule (qualifiedType(T:Type, ?) => T:Type) : KSentence [metadata "structural"] .
	
	mb rule (unsigned-short => unsigned-short-int) : KSentence [metadata "structural"] .
	mb rule (unsigned-long => unsigned-long-int) : KSentence [metadata "structural"] .
	mb rule (unsigned-long-long => unsigned-long-long-int) : KSentence [metadata "structural"] .
	mb rule (short => short-int) : KSentence [metadata "structural"] .
	mb rule (long => long-int) : KSentence [metadata "structural"] .
	mb rule (long-long => long-long-int) : KSentence [metadata "structural"] .
	
	mb rule
		< k > typeof(E:Expression) => evalToType ~> typeof(HOLE) ...</ k >
		((.).Bag => < type > E:Expression </ type >)
		: KSentence [metadata "structural"] .
	mb rule
		< k > evalToType ~> typeof(HOLE) => T:Type ...</ k >
		(< type > T:Type </ type > => (.).Bag)
		if isAType T:Type
		: KSentence [metadata "structural"] .
	mb rule
		< type > (F:Float => double) </ type >
		: KSentence [metadata "structural"] .
	--- why did this suddenly become necessary?
	mb rule
		< type > (atv(?, T:Type) => T:Type) </ type >
		: KSentence [metadata "structural"] .
	--- c99 6.4.5
	mb rule
		< type > (S:String => arrayType(char, lengthString(S:String))) </ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > (E:Expression => T:Type) ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< type > (X:Id => T:Type) ...</ type >
		< types >... typedefName(X:Id) |-> T:Type ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< type > (tv(?, T:Type) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > (cast(T:Type, ?) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-struct-arrow]: rule
		< type > '_->_(pointerType(structType(S:Id)),, X:Id) => T:Type ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence [metadata "structural"] .
	mb [type-union-arrow]: rule
		< type > '_->_(pointerType(unionType(S:Id)),, X:Id) => T:Type ...</ type >
		< structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence [metadata "structural"] .

	mb [type-struct-dot]: rule
		< type > ('_._(structType(S:Id),, X:Id) => T:Type) ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence [metadata "structural"] .
		
	mb [type-union-dot]: rule
		< type > ('_._(unionType(S:Id),, X:Id) => T:Type) ...</ type >
		< structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence [metadata "structural"] .

	mb rule
		< type > (Closure(?, T:Type, ?) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > 'Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE) ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type) ...</ type >
		: KSentence [metadata "structural"] .

	mb [type-deref-value]: rule
		< type > ('Deref(tv(?, pointerType(T:Type))) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-deref-type]: rule
		< type > ('Deref(pointerType(T:Type)) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-deref-array]: rule
		< type > ('Deref(arrayType(T:Type, ?)) => T:Type) ...</ type >
		: KSentence [metadata "structural"] .

		
	--- fixme ignoring extern
	mb rule
		(extern => (.).K)
		: KSentence [metadata "structural"] .
	--- fixme ignoring static
	mb rule
		(static => (.).K)
		: KSentence [metadata "structural"] .
	--- mb rule
		--- (register => (.).K)
		--- : KSentence [metadata "structural"] .
	mb rule
		register ~> int => registerInt
		: KSentence [metadata "structural"] .
	mb rule
		(inline => (.).K)
		: KSentence [metadata "structural"] .
		
endm
