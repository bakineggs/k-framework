***(
    The CHALLENGE Programming Language

    Definition by Grigore Rosu: http://fsl.cs.uiuc.edu/images/0/0c/CS422-Spring-2010-CHALLENGE.pdf
    This implementation by David Lazar <lazar6@illinois.edu>.
)
load ../../../k-prelude
in challenge-syntax
in challenge-programs

mod CHALLENGE-SEMANTICS is
  including CHALLENGE-SYNTAX .
  including K .

--- Configuration
  ops agents agent threads thread k env holds store ptr
      nextLoc aspect busy me parent output messages message
      sender receiver val nextAgent result
      : -> CellLabel .

  mb configuration
    < T >
        < agents >
            < agent * >
                < threads >
                    < thread * >
                        < k > .K </ k >
                        < env > .Map </ env >
                        < holds > .Map </ holds >
                    </ thread * >
                </ threads >
                < store > .Map </ store >
                < ptr > .Map </ ptr >
                < nextLoc > 0 </ nextLoc >
                < aspect > .K </ aspect >
                < busy > .Bag </ busy >
                < me > 0 </ me >
                < parent > 0 </ parent >
            </ agent * >
        </ agents >
        < output > .List </ output >
        < messages >
            < message * >
                < sender > 0 </ sender >
                < receiver > 0 </ receiver >
                < val > .K </ val >
            </ message * >
        </ messages >
        < nextAgent > 0 </ nextAgent >
        < result > .List </ result >
    </ T >
    : KSentence .

  op initconfig : Stmt -> Bag .
  eq initconfig(S) =
    < T >
        < agents >
            mkAgent(mkThread(S, .Map), 0, 0)
        </ agents >
        < output > .List </ output >
        < messages > .Bag </ messages >
        < nextAgent > 0 </ nextAgent >
    </ T >
    .

--- Semantics
  sort Val .
  subsort Val < Exp .
  subsort Int Bool < Val < KResult .
  subsort Exp Stmt List{Exp} < K .

  sort List{Val} .
  subsort Val < List{Val} < List{Exp} .
  op _,_ : List{Val} List{Val} -> List{Val} [ditto] .

  op closure : List{Id} K Map -> Val .
  op restoreEnv : Map -> K .

  var K : K .
  vars Env Holds Store : Map .
  vars Me Parent : Nat .
  var Busy : Bag .
  var Output : List .

  vars N N1 N2 L M : Nat .
  vars I I1 I2 : Int .
  vars S S1 S2 : Stmt .
  vars B E : Exp .
  vars Xl : List{Id} .
  var Vl : List{Val} .
  var T : Bool .
  var X : Id .
  var Env' : Map .
  var V : Val .

  --- TODO: make numeric operators polymorphic over Int and Float
  mb rule [I1 + I2 => I1 +Int I2] : KSentence .
  mb rule [I1 * I2 => I1 *Int I2] : KSentence .
  mb rule [I1 / I2 => I1 /Int I2] if I2 =/=Bool 0 : KSentence .
  mb rule [I1 % I2 => I1 %Int I2] if I2 =/=Bool 0 : KSentence .

  mb rule [I1 <= I2 => I1 <=Int I2] : KSentence .
  mb rule [I1 == I2 => I1 ==Bool I2] : KSentence .
  mb rule [not T => notBool T] : KSentence .
  mb rule [true and B => B] : KSentence .
  mb rule [false and ? => false] : KSentence .

  mb rule [skip => .K] : KSentence .
  mb rule [if true then S1 else ? => S1] : KSentence .
  mb rule [if false then ? else S2 => S2] : KSentence .
  mb rule [if' true then E else ? => E] : KSentence .
  mb rule [if' false then ? else E => E] : KSentence .

  mb rule [S1 ; S2 => S1 ~> S2] : KSentence .

  --- while loop
  mb rule
    < k > [while B do S => if B then (S ; while B do S) else skip] ...</ k >
    : KSentence [metadata "structural"] .

  --- output
  mb rule
     < k > [output(V) => .K] ...</ k >
     < output > Output [.List => ListItem(V)] </ output >
     : KSentence .

  --- variable lookup
  mb rule
    < k > [X => V] ...</ k >
    < env >... X |-> L ...</ env >
    < store >... L |-> V ...</ store >
    : KSentence .

  --- variable increment
  mb rule
    < k > [++ X => I +Int 1] ...</ k >
    < env >... X |-> L ...</ env >
    < store >... L |-> [I => I +Int 1] ...</ store >
    : KSentence .

  --- variable assignment
  mb rule
    < k > [X := V => .K] ...</ k >
    < env >... X |-> L ...</ env >
    < store >... L |-> [? => V] ...</ store >
    : KSentence .

  --- TODO: pointer assignment

  --- variable reference
  mb rule
    < k > [& X => L] ...</ k >
    < env >... X |-> L ...</ env >
    : KSentence .

  --- pointer dereference
  mb rule
    < k > [* L => V] ...</ k >
    < store >... L |-> V ...</ store >
    : KSentence .

  --- malloc
  mb rule
    < k > [malloc(N) => L] ...</ k >
    < nextLoc > [L => L +Nat N] </ nextLoc >
    < ptr >... [.Map => L |-> N] ...</ ptr >
    < store >... [.Map => N .. sdNat(L +Nat N, 1) |-> 0] ...</ store >
    : KSentence .

  --- TODO: free

  --- aspect
  mb rule
    < k > [aspect(S) => .K] ...</ k >
    < aspect > [? => S] </ aspect >
    : KSentence .

  --- lambda
  mb rule
    < k > [\ Xl -> E => closure(Xl, (S ~> E), Env)] ...</ k >
    < env > Env </ env >
    < aspect > S </ aspect >
    : KSentence [metadata "structural"] .

  --- fixed-point combinator
  mb rule
    < k > [\Y X -> E => E ~> restoreEnv(Env)] ...</ k >
    < nextLoc > [N => sNat(N)] </ nextLoc >
    < env > [Env => Env[N / X]] </ env >
    < store >... [.Map => N |-> (\Y X -> E)] ...</ store >
    : KSentence .

  --- function application
  mb rule
    < k > [closure(Xl, E, Env') Vl => E ~> restoreEnv(Env)] ...</ k >
    < nextLoc > [N => N +Nat length(getList{K}(Xl))] </ nextLoc >
    < env > [Env => Env'[N .. sdNat(N +Nat length(getList{K}(Xl)), 1) / getList{K}(Xl)]] </ env >
    < store > [Store => Store[getList{K}(Vl) / N .. sdNat(N +Nat length(getList{K}(Xl)), 1)]] </ store >
    : KSentence .

  --- restore environment from function application
  mb rule
    < k > V ~> [restoreEnv(Env) => .K] ...</ k >
    < env > [? => Env] </ env >
    : KSentence [metadata "structural"] .

  --- tail call optimization
  mb rule [restoreEnv(?) ~> restoreEnv(Env) => restoreEnv(Env)]
    : KSentence [metadata "structural"] .

  --- block
  mb rule
    < k > [{vars Xl ; S} => S ~> restoreEnv(Env)] ...</ k >
    < nextLoc > [N => N +Nat length(getList{K}(Xl))] </ nextLoc >
    < env > [Env => Env[N .. sdNat(N +Nat length(getList{K}(Xl)), 1) / getList{K}(Xl)]] </ env >
    < store > [Store => Store[0 / N .. sdNat(N +Nat length(getList{K}(Xl)), 1)]] </ store >
    : KSentence .

  --- restore environment from block
  mb rule
    < k > [restoreEnv(Env) => .K] ...</ k >
    < env > [? => Env] </ env >
    : KSentence [metadata "structural"] .

  --- call/cc
  op cc : K Map -> Exp .

  mb rule
    < k > [callcc(E) => E cc(K,Env)] ~> K </ k >
    < env > Env </ env >
    : KSentence .

  mb rule
    < k > [cc(K, Env) E ~> ? => E ~> K] </ k >
    < env > [Env' => Env] </ env >
    : KSentence .

  --- nondeterminism
  mb rule < k > [randomBool => true] ...</ k > : KSentence .
  mb rule < k > [randomBool => false] ...</ k > : KSentence .

  --- spawn a thread
  mb rule
    < thread >...
        < k > [spawn(S) => .K] ...</ k >
        < env > Env </ env >
    ...</ thread >
    [.Bag => mkThread(S, Env)]
    : KSentence .

  --- aquire a free lock
  mb rule
    < k > [acquire V => .K] ...</ k >
    < holds >... [.Map => V |-> 0] ...</ holds >
    < busy > Busy [.Bag => Bag(V)] </ busy >
    if notBool(BagItem(V) inBag Busy)
    : KSentence .

  --- re-aquire a lock
  mb rule
    < k > [acquire V => .K] ...</ k >
    < holds >... V |-> [N => sNat(N)] ...</ holds >
    : KSentence .

  --- release lock
  mb rule
    < k > [release V => .K] ...</ k >
    < holds >... V |-> [sNat(N) => N] ...</ holds >
    : KSentence .

  mb rule
    < k > [release V => .K] ...</ k >
    < holds >... V |-> 0 ...</ holds >
    < busy >... [Bag(V) => .Bag] ...</ busy >
    : KSentence .

  --- rendezvous synchronization
  mb rule
    < k > [rv V => .K] ...</ k >
    < k > [rv V => .K] ...</ k >
    : KSentence .

  --- spawn a new agent
  mb rule
    < k > [new-agent S => N] ...</ k >
    < me > M </ me >
    < nextAgent > [N => sNat(N)] </ nextAgent >
    [.Bag => mkAgent(mkThread(S, .Map), N, M)]
    : KSentence .

  --- my agent id
  mb rule
    < k > [me => M] ...</ k >
    < me > M </ me >
    : KSentence .

  --- parent agent id
  mb rule
    < k > [parent => N] ...</ k >
    < parent > N </ parent >
    : KSentence .

  --- receive a message from a certain agent
  mb rule
    < k > [receive-from N => V] ...</ k >
    < me > M </ me >
    [< message >
        < sender > N </ sender >
        < receiver > M </ receiver >
        < val > V </ val >
    </ message > => .Bag]
    : KSentence .

  --- receive a message from any agent
  mb rule
    < k > [receive => V] ...</ k >
    < me > M </ me >
    [< message >...
        < receiver > M </ receiver >
        < val > V </ val >
    ...</ message > => .Bag]
    : KSentence .

  --- send asynchronous message
  mb rule
    < k > [send-asynch N V => .K] ...</ k >
    < me > M </ me >
    [.Bag =>
        < message >
            < sender > M </ sender >
            < receiver > N </ receiver >
            < val > V </ val >
        </ message >]
    : KSentence .

  --- TODO: I believe the following rules for synchronous messaging
  --- suffer from the same context transformer bug as the halting rules
  --- below. I expect the following two rules to compile, but they do
  --- not, so they are commented out for the time being.

  ---( send a message synchronously
  mb rule
    < agent >...
        < k > [send-synch N V => .K] ...</ k >
        < me > M </ me >
    ...</ agent >
    < agent >...
        < k > [receive-from M => V] ...</ k >
        < me > N </ me >
    ...</ agent >
    : KSentence .

  mb rule
    < k > [send-synch N V => .K] ...</ k >
    < agent >...
        < k > [receive => V] ...</ k >
        < me > N </ me >
    ...</ agent >
    : KSentence .
  )

  --- halt thread
  mb rule [< k > halt-thread ...</ k > => < k > .K </ k >] : KSentence .

  --- TODO: I believe a bug in the context transformers level prevents
  --- the following halt rules to be less general then they could be.

  --- halt agent
  mb rule
    [< threads >...
        < thread >...
            < k > halt-agent ...</ k >
        ...</ thread >
    ...</ threads >
    => < threads > .Bag </ threads >]
    : KSentence .

  --- halt system
  mb rule
    [< agents >...
        < agent >...
            < threads >...
                < thread >...
                    < k > halt-system ...</ k >
                ...</ thread >
            ...</ threads >
        ...</ agent >
    ...</ agents >
    => < agents > .Bag </ agents >]
    : KSentence .

  --- dissolve thread and release holds
  mb rule
    [< thread >...
        < k > .K </ k >
        < holds > Holds </ holds >
    ...</ thread >
    => .Bag]
    < busy > [Busy => Busy -Bag domMap(Holds)] </ busy >
    : KSentence [metadata "structural"] .

  --- dissolve agent
  mb rule
    [< agent >...
        < threads > .Bag </ threads >
    ...</ agent >
    => .Bag]
    : KSentence [metadata "structural"] .

  --- dissolve top
  mb rule
    [< T >...
        < agents > .Bag </ agents >
        < output > Output </ output >
    ...</ T >
    => < result > Output </ result >]
    : KSentence [metadata "structural"] .

  vars Thread : BagItem .

  op mkThread : Stmt Map -> BagItem .
  eq mkThread(S, Env) =
    < thread >
        < k > S </ k >
        < env > Env </ env >
        < holds > .Map </ holds >
    </ thread >
    .

  op mkAgent : BagItem Nat Nat -> BagItem .
  eq mkAgent(Thread, Me, Parent) =
    < agent >
        < threads > Thread </ threads >
        < store > .Map </ store >
        < ptr > .Map  </ ptr >
        < nextLoc > 0 </ nextLoc >
        < aspect > .K </ aspect >
        < busy > .Bag </ busy >
        < me > Me </ me >
        < parent > Parent </ parent >
    </ agent >
    .

--- Utilities (perhaps these should be in the k-prelude)
  op _.._ : Nat Nat -> List{K} .
  eq N1 .. N2 = if N1 >Nat N2 then .List{K} else (N1,, (sNat N1) .. N2) fi .

  var Bag Bag' : Bag . var Item : BagItem .
  op _inBag_ : BagItem Bag -> Bool .
  eq Item inBag Item Bag = true .
  eq Item inBag Bag = false [owise] .

  op _-Bag_ : Bag Bag -> Bag .
  eq Bag -Bag .Bag = Bag .
  eq .Bag -Bag Bag = .Bag .
  eq (Item Bag) -Bag Bag' = if Item inBag Bag' then .Bag else Item fi (Bag -Bag Bag') .

  var Map : Map . var K' : K .
  op domMap : Map -> Bag .
  eq domMap(.Map) = .Bag .
  eq domMap((K |-> K' Map)) = BagItem(K) domMap(Map) .

endm

mod CHALLENGE is
  including CHALLENGE-SEMANTICS .
  including CHALLENGE-PROGRAMS .
endm
