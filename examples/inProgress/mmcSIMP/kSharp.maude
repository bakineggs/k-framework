--- in ../../../k-prelude
in path

mod KSHARP is 
     including SIMP-SYNTAX + PATH .
     protecting K .

 
 op listItem : Label -> ListItem .

 op list_ : List{Label} -> List .
 eq list(.List{Label}) = .List .
 eq list(L ;; Ls) = listItem(L) list(Ls) .
 
 --- @ < >_k#
  sorts Asg Cnd EdgeOp .
  sort Trans . --- Trans = TransAsg U TransCnd
  sort Pair{K,Label} .

  subsort Asg < EdgeOp .
  subsort Cnd < EdgeOp .
  subsort Trans < K .

  op asg : Var Exp -> Asg .
  op cnd : Exp -> Cnd .
  op (_:_) : Label EdgeOp -> Trans .
  op if : K K -> K .
  op while : Label Cnd K -> K .
  op skip : -> K .
 
  op stmt#  : Label Stmts -> Pair{K,Label} .
  op k# : Stmts -> K .
  op pair : K Label -> Pair{K,Label} [ctor] .
  op fst : Pair{K,Label} -> K .
  op snd : Pair{K,Label} -> Label .
  op fin : Label -> K . 


  eq fst (pair (K, L)) = K .
  eq snd (pair (K, L)) = L .

  eq stmt# (Lin, {}) = pair (.K, Lin) . 

  eq  stmt# (Lin, skip;) = pair (.K, Lin) .

  eq  stmt# (Lin, (X = A ;)) = pair ((Lin : asg(X, A)), Lin +Label 1) .

  ceq stmt# (Lin, (S1 S2)) = pair ((fst(K1Laux) ~> fst(K2Lfin)), snd(K2Lfin))
  	     if K1Laux := stmt# (Lin, S1) 
	     /\ K2Lfin := stmt# (snd(K1Laux), S2) . 

  eq stmt# (Lin, { S }) = stmt# (Lin, S) .


  ceq stmt# (Lin, ( if B then ( { S1 } ) else ( { S2 } ) )) = 
      pair (((Lin : cnd(B)) ~> if(fst(K1Laux),fst(K2Lfin))), snd(K2Lfin))
  	     if K1Laux := stmt# (Lin +Label 1 , S1) 
	     /\ K2Lfin := stmt# (snd(K1Laux), S2) . 


  ceq stmt# (Lin, ( while B do ( { S } ) )) = 
      pair (while(Lin, cnd(B), fst(KLfin)), snd(KLfin) )
  	     if KLfin := stmt#(Lin +Label 1 , S) . 
  
  ceq k# (S) = fst (KLfin) ~> fin (snd (KLfin))
	     if KLfin := stmt# (1, S) . 


  op stripVars : Stmts -> Stmts .
  eq stripVars ( (( var X ; ) S) ) = stripVars ( S ) .
  eq stripVars ( S ) = S [owise] .


  vars KLfin K1Laux K2Lfin : Pair{K,Label} .	
  vars S S1 S2 : Stmts . 
  var X : Var . var A : AExp . var B : BExp . 
  vars L Lin : Label .
  var Ls : List{Label} .
  var K : K .

endm
