in ../../../k-prelude
in simp-syntax
--- in path
in KSharp
in preds
in simp-mc-programs

mod SIMP-MC-SEMANTICS is including KSHARP + PREDS .

--- @ < >_state#   < >_store# 

  sort False . 
  sort  Pair{Label,Valid}. --- Store# = Bag (Pair{Labe,Valid}) .

  subsort False < Map . --- State# = Map .

--- from PREDS:
  subsort PREDS < K .
  subsorts Var < VarPreds < K .
  
  subsorts AExp < PExp < K .
  subsort BExp < AtomicPreds .

  subsort Pair{Label,Valid} < PREDS .

  op _notin_ : PREDS Bag -> Bool .
  eq (| L, invalid |) notin Bag = false .
  eq Item notin (BagItem(Item) Bag) = false .
  eq Item notin Bag = true [owise] .

  op valid : Map -> Map .

  op not.Bag : Bag -> Bool .
  eq not.Bag(.Bag) = false .
  eq not.Bag(Sigma) = true [owise] .


  var Item : PREDS .
  var Bag : Bag . 

  op invalid : -> False [ctor] . 

  op |_`,_| : Nat Map -> Pair{Label,Valid} [ctor] .

  op _[_>->_] : Bag Nat Map -> Bag .
  eq Sigma [ L >-> Gamma ] = BagItem((| L, Gamma |)) Sigma . 
   ---  op update : Store# Label Valid -> Store# . 
   --- |_> already defined as [...] for Bag in K... Set{PREDS} in PREDS
   --- ???!!!  update(Sigma, L, Gamma) = Sigma U (| L, Gamma |) iff (| L, Gamma |) notin Sigma . 
   --- |_> iff UPDATED as conditional rules for R5 and R6


  op post# : Map EdgeOp -> Map . 

  
--- TODO:
--- ???!!!  post#(Gamma, Op) = list(p->pTValue : p in Pi)
---  op evalPred : -> Pair[Pred, Tvalue] . 

--- for cells < inv > and < state# >
  op phi : -> List .
  op st# : -> Map .

 
--- VARIABLES
  var Gamma : Map . --- var Gamma : State# . 
  var Sigma : Bag . --- var Sigma : Store# . 
  var Phi : List .
  vars S S1 S2 : Stmt . var X : Var . var A : AExp . var B : BExp . 
  vars L Lin : Nat .
  vars K1 K2 K : K .
  var Op : EdgeOp .
  var P : List . --- var P : List{K} .


--- @ CONFIGURATION
  ops state# path trace# store# inv : -> CellLabel .
  mb configuration < T >
     		     < trace# * >
 		           < k > K </ k >
                     	   < state# > Gamma </ state# >
		     	   < path > .List </ path >
		     </ trace# * >
		     < store# > .Bag </ store# > 
		     < inv > Phi </ inv >
                   </ T > : KSentence .

--- @ RULES MC
  --- RULE R1 
  mb rule [ < trace# > 
     	     	< k > fin(L) </ k > 
	        < state# > valid(Gamma) </ state# >
 	    ...</ trace# > => .Bag ] 
     : KSentence .


  --- RULE R2
  mb rule   < k > [ fin(L) => .K ] </ k > 
	    < state# > [ invalid => .Map ] </ state# > 
	    < path >... [ .List => ListItem(L) ] </ path >  
     : KSentence .


  --- RULE R3 
  mb rule [  < trace# >
     	     	< k > (L :: ?) ...</ k > 
	     	< state# > valid(Gamma) </ state# >
	     ...</ trace# > => .Bag
	  ] 
	  < store# >... (| L, Gamma |) ...</ store# > : KSentence .


  --- RULE R4
  mb rule   < k > [ ((L :: ?) ~> ?) => .K ] </ k >
	    < state# > [ invalid => .Map ] </ state# > 
	    < path >... [ .List =>  ListItem(L) ] </ path > 
     : KSentence .


  --- RULE R5
  mb rule       < k > [ (L :: asg(X, A)) => .K ] ...</ k >
	        < state# > [ valid(Gamma) => post#(valid(Gamma), asg(X, A)) ] </ state# >
	        < path >... [ .List => ListItem(L) ] </ path >
	    < store# > [ Sigma => Sigma [ L >-> Gamma ] ] </ store# >
	    < inv > Phi </ inv >  
     if (| L, Gamma |) notin Sigma 
     : KSentence .

   
  --- RULE R6  
  mb rule 
       < T >...
     	  < trace# >
     	     < k > [ ((L :: cnd(B)) ~> if (K1, K2))  => (skip ~> K1) ] ~> K 
	     </ k >
	     < state# > [ valid(Gamma) => post# (valid(Gamma), cnd(B)) ] </ state# >
	     < path > [ P => P ListItem(L) ] </ path >  
     	  </ trace# >
	  [ .Bag => < trace# > 
	     	        < k > skip ~> K2 ~> K </ k >
	                < state# > post# (valid(Gamma), cnd (not B)) </ state# >
	                < path > P ListItem(L) </ path > 
	  	    </ trace# > 
          ]
	  < store# > [ Sigma => Sigma [ L >-> Gamma ] ] </ store# >
	  < inv > Phi </ inv > 
	...</ T >
      if (| L, Gamma |) notin Sigma 
      : KSentence .


  --- RULE R7
  mb rule [ < trace# >...
     	      < k > skip ~> ? </ k >
	      < state# > invalid </ state# >
     	    ...</ trace# > => .Bag ] : KSentence [metadata "structural"] .


  --- RULE R8
  mb rule   < k > [ skip => .K ] ...</ k >
            < state# > valid(Gamma) </ state# > 
     : KSentence [metadata "structural"] . 


  --- RULE R9 
  mb rule < k >
     	    [ (while (L, cnd (B), K)) => 
	      (( L :: cnd (B)) ~> if ((K ~> while(L, cnd (B), K)), .K ))
            ]
     	  ...</ k > : KSentence [metadata "structural"] .


  --- TERMINATION
  mb rule [ < T >... 
     	       < trace# >
     	      	 < k > .K </ k >
		 < state# > .Map </ state# >
		 < path > P </ path >
	       </ trace# >
	       < store# > Sigma </ store# >
	       < inv > Phi </ inv >
            ...</ T > 
	    => 
	    < T > < trace# > 
	       	        < k > .K </ k >
			< state# > .Map </ state# >
	       	        < path > P </ path > 
	       	  </ trace# >
		  < store# > .Bag </ store# >
	          < inv > Phi </ inv >
	    </ T >
          ] 
     if not.Bag(Sigma)
     : KSentence [metadata "structural"] .
 

  mb rule  [ < T >
		< store# > Sigma </ store# >
		< inv > Phi </ inv >
             </ T > 
	    =>  
	    < T >
		< store# > .Bag </ store# >
		< inv > Phi </ inv >
             </ T >
	   ]
      if not.Bag(Sigma) 
      : KSentence [metadata "structural"] .
 
endm


mod SIMP-MC is including SIMP-MC-SEMANTICS + SIMP-MC-PROGRAMS .
--- make sure the name of the final module is the capitalized version of the file name
  op run : -> Bag .
  var X : Var . var S : Stmts . 
--- After loading simple-untyped-compiled into maude, type "rew run .".  Replace prog by any program, then recompile.
 
  eq phi = List(err ==p 0) .List .
  


  eq post#( valid( ( st# (( err ==p 0 ) |-> eval1 )  (( x ==p 0 ) |-> eval1/2 ))) , asg(x, 0)) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ) )) .
  eq post#( valid( ( st# (( err ==p 0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) , asg(err, x)) = 
     valid(( st# (( err ==p 0 ) |-> eval1 )  (( x ==p 0 ) |-> eval1 ))) .

  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) , cnd( y <=  x)) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) .
  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) , cnd( not (y <=  x))) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) .

  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) , asg(x, x + 1)) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) .
  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) , asg(y, y + x)) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) . 
  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) , asg(x, -1 + x)) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1/2 ))) .

  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1/2 ))) , cnd(not( x == 0 ))) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) .
  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1/2 ))) , cnd(not(not( x == 0) ))) = 
     valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval1 ))) .

  eq post#( valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p  0 ) |-> eval0 ))) , asg (err, 1)) = 
     invalid .


  eq run = < T > 
             	< trace# >
		  < k > k# (stripVars(pTest)) </ k >
            	  < state# > valid(( st# (( err ==p  0 ) |-> eval1 )  (( x ==p 0 ) |-> eval1/2 ))) </ state# >
		  < path > .List </ path >
		</ trace# >
            < store# > .Bag </ store# >
            < inv > phi </ inv >
          </ T > .

endm
