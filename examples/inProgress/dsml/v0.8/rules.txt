
AttArrow ::= att : Type = Val => Exp
           | att : Type = Val

ObjArrow ::= object Id : Id { AttArrow* }
            | . => Object+
            | Object+ => .

Arrow ::= ObjArrow+   
 
Rule ::= rule [ Id ] : Arrow when Exp using Intialization* do Program

Initialization ::= Id <- Exp;
q
Program ::= Instr*
Instr ::= Id : Id . Id <- Exp ; 
        |  Id <- Exp; 
        | if ( Exp ) { Instr* } 
        | if ( Exp ) { Instr* } else { Instr* } 
        | for ( Iterator in Exp ) { Instr* } 


lhs(rule [ Id ] : Arrow when Exp using Intialization* do Program) = <model_> lhs(Arrow)  <_/model>
lhs(O1 ... On => .) = O1 ... On
lhs(. => OL) = .
...

rhs(...) = ...


using(R) = Id1 = Exp1; ...


--- semantica K a unei reguli R

syntax K ::= when ( Exp ) [strict]


rule lhs(R) ( <k> rew => when(R) ~> using(R) ~> update(rhs(R)) ~> do(R) </k> <env>.</env>)

rule <k> when(true) => . <_/k>

rule (<k> (when(false) ~> K:K) => run </k> <env>E</env> => .

rule <k> Id:LocalVariable <- V; <_/k>  <env> E => E[V/Id] </env>

rule <k> Id => V <_/k> <env_> Id |-> V <_/env>

rule Init1 Int2 => Init1 ~> Init2

rule <k>update(M:Bag> => . <_/k> <env> E</env> (<model> M':Bag </model>) => M[E]

rule M[Id |-> V E] => (M[V/Id])[E]
...

rule Instr1 Instr2 => Instr1 ~> Instr2

rule <k> O:C#Att <- V; => . <_/k> <instance>  <instName> O </instName> <ofClass> C </ofClass> <attributes_> Att |-> (_ => typedElt(V, getType(Att))) <_/attributes>

rule <k> if (true) { InstrL } => InstrL <_/k>

rule <k> if (false) { InstrL } => . <_/k>

rule <k> for (O in val(.Bag)) { InstrL } => . <_/k>

rule <k> for (O in val(BagItem(V) B:Bag)) { InstrL } =>  O <- V; InstrL; for (O in val(B)) { InstrL } <_/k>

rule <k> . => rew </k> (<env> E </env> => .)

 




   


