mod HASKELL-SYNTAX-UTILS is
    including HASKELL-SYNTAX .

  --- A token for when something is not a constructor
    op NotACon : -> String [ctor] .
  --- A token for when something isn't an identified name
    op NotAName : -> String [ctor] .

  --- Whether or not the given pat is the wildcard
    op isWild : Pat -> Bool .
    eq isWild(PWildCard) = true .
    eq isWild(Pat:Pat) = false [owise] .

    op notWild : Pat -> Bool .
    eq notWild(Pat:Pat) = notBool isWild(Pat:Pat) .

  --- Returns or not the argument is one of our special-negative tokens
    op notDefined : String -> Bool .
    eq notDefined(NotACon) = true .
    eq notDefined(NotAName) = true .
    eq notDefined(S:String) = false [owise] .

    op isDefined : String -> Bool .
    eq isDefined(S:String) = notBool notDefined(S:String) .

  --- Whether or not a HsList is empty
    op isEmpty : HsList -> Bool .
    eq isEmpty([]) = true .
    eq isEmpty(L:HsList) = false [owise] .

    op nonEmpty : HsList -> Bool .
    eq nonEmpty(L:HsList) = notBool isEmpty(L:HsList) .


  --- Fetch a name from a Name, or a QName
    op getName : QName -> String .
    op getName : Name -> String .
    eq getName(Qual M:ModuleName N:Name) = getName(N:Name) .
    eq getName(UnQual N:Name) = getName(N:Name) .

    eq getName(Ident S:String) = S:String .
    eq getName(Symbol S:String) = NotAName . --- currently don't know what to do with symbols

  --- Given an Exp or Pat, extract the name of the underlying constructor.
  --- Rewrites to NotACon if not a constructor
    op getConstructorName : Exp -> String .
    op getConstructorName : Pat -> String .
    eq getConstructorName(Paren E:Exp)      = getConstructorName(E:Exp) .
    eq getConstructorName(App E:Exp E0:Exp) = getConstructorName(E:Exp) .
    eq getConstructorName(Con Q:QName)      = getName(Q:QName) .
    --- todo: check to see if there are other cases to match
    eq getConstructorName(E:Exp)            = NotACon [owise] .

    eq getConstructorName(PParen P:Pat)                    = getConstructorName(P:Pat) .
    eq getConstructorName(PApp Q:QName L:HsList)           = getName(Q:QName) .
    eq getConstructorName(PInfixApp P1:Pat Q:QName P2:Pat) = getName(Q:QName) .
    --- todo: check to see if there are other cases to match
    eq getConstructorName(P:Pat)                           = NotACon [owise] .


  --- Given two Exp/Pats, rewrites to true it they are both constructors and have the same name, false otherwise
    op sameConstructor : Exp Exp -> Bool .
    op sameConstructor : Pat Exp -> Bool .
    op sameConstructor : Exp Pat -> Bool .
    op sameConstructor : Pat Pat -> Bool .
    eq sameConstructor(E1:Exp, E2:Exp) = (E1:Exp ==GCN E2:Exp) andBool isDefined(getConstructorName(E1:Exp)) .
    eq sameConstructor(P1:Pat, E2:Exp) = (P1:Pat ==GCN E2:Exp) andBool isDefined(getConstructorName(P1:Pat)) .
    eq sameConstructor(E1:Exp, P2:Pat) = (E1:Exp ==GCN P2:Pat) andBool isDefined(getConstructorName(E1:Exp)) .
    eq sameConstructor(P1:Pat, P2:Pat) = (P1:Pat ==GCN P2:Pat) andBool isDefined(getConstructorName(P1:Pat)) .

  --- Given two Exps/Pats, rewrites to true if they are both constructors and don't have the same name.
  --- Note that this isn't the inverse of sameConstructor in the case where argument or the other isn't a constructor
    op notSameConstructor : Exp Exp -> Bool .
    op notSameConstructor : Pat Exp -> Bool .
    op notSameConstructor : Exp Pat -> Bool .
    op notSameConstructor : Pat Pat -> Bool .
    eq notSameConstructor(E1:Exp, E2:Exp) = (E1:Exp =/=GCN E2:Exp) andBool isDefined(getConstructorName(E1:Exp)) .
    eq notSameConstructor(P1:Pat, E2:Exp) = (P1:Pat =/=GCN E2:Exp) andBool isDefined(getConstructorName(P1:Pat)) .
    eq notSameConstructor(E1:Exp, P2:Pat) = (E1:Exp =/=GCN P2:Pat) andBool isDefined(getConstructorName(E1:Exp)) .
    eq notSameConstructor(P1:Pat, P2:Pat) = (P1:Pat =/=GCN P2:Pat) andBool isDefined(getConstructorName(P1:Pat)) .

  --- Helper operators for equality with respect to the value of getConstructorName (even if it's undefined).
    op _ ==GCN _ : Exp Exp -> Bool .
    op _ ==GCN _ : Pat Exp -> Bool .
    op _ ==GCN _ : Exp Pat -> Bool .
    op _ ==GCN _ : Pat Pat -> Bool .
    eq E1:Exp ==GCN E2:Exp = getConstructorName(E1:Exp) ==Bool getConstructorName(E2:Exp) .
    eq P1:Pat ==GCN E2:Exp = getConstructorName(P1:Pat) ==Bool getConstructorName(E2:Exp) .
    eq E1:Exp ==GCN P2:Pat = getConstructorName(E1:Exp) ==Bool getConstructorName(P2:Pat) .
    eq P1:Pat ==GCN P2:Pat = getConstructorName(P1:Pat) ==Bool getConstructorName(P2:Pat) .

    op _ =/=GCN _ : Exp Exp -> Bool .
    op _ =/=GCN _ : Pat Exp -> Bool .
    op _ =/=GCN _ : Exp Pat -> Bool .
    op _ =/=GCN _ : Pat Pat -> Bool .
    eq E1:Exp =/=GCN E2:Exp = getConstructorName(E1:Exp) =/=Bool getConstructorName(E2:Exp) .
    eq P1:Pat =/=GCN E2:Exp = getConstructorName(P1:Pat) =/=Bool getConstructorName(E2:Exp) .
    eq E1:Exp =/=GCN P2:Pat = getConstructorName(E1:Exp) =/=Bool getConstructorName(P2:Pat) .
    eq P1:Pat =/=GCN P2:Pat = getConstructorName(P1:Pat) =/=Bool getConstructorName(P2:Pat) .





endm

