***(
    The Translations from high-level haskell into a lower-level haskell, as layed out in the Expressions section
    of the Haskell Report
***)

***(
TODO:
    * add new FreshVar sort for fresh variables
    * translation for let, case, etc
    * break it up into smaller modules?
    * inverse transformations
    * clean up
***)

mod HASKELL-TRANSLATIONS is
    including HASKELL-SYNTAX .

***(
The integer literal i is equivalent to fromInteger i, where fromInteger is a method in class Num (see Section 6.4.1).
***)

vars E E1 E2 E3 : Exp .
var I : Int .

op o_ : Literal -> Literal .

eq Lit (Int I) = App (Var (UnQual (Ident "fromInteger"))) (Lit (o Int I)) .

***(
The floating point literal f is equivalent to fromRational (n Ratio.% d), where fromRational is a method in class Fractional and Ratio.% constructs a rational from two integers, as defined in the Ratio library. The integers n and d are chosen so that n/d = f.
***)

***(
The following identity holds:
\ p1 ... pn -> e    =   \ x1 ... xn -> case (x1, ..., xn) of (p1, ..., pn) -> e
where the xi are new identifiers.
***)

***(
The following identities hold:
e1 op e2 = (op) e1 e2
-e       = negate (e)
***)
eq NegApp E = App (Var (UnQual (Ident "negate"))) E .

eq InfixApp E1 Q:QOp E2 = App (App fromInfix(Q:QOp) E1) E2 .


op fromInfix : QOp -> Exp .
eq fromInfix(QVarOp QN:QName) = Var QN:QName .
eq fromInfix(QConOp QN:QName) = Con QN:QName .

***(
The following identities hold:
(op e)  =   \ x -> x op e
(e op)  =   \ x -> e op x
where op is a binary operator, e is an expression, and x is a variable that does not occur free in e.
***)

op NoLoc : -> SrcLoc .
eq NoLoc = SrcLoc "<unknown.hs>" 0 0 .


***(
The following identity holds:
if e1 then e2 else e3   =   case e1 of { True -> e2 ; False -> e3 }
where True and False are the two nullary constructors from the type Bool, as defined in the Prelude. The type of e1 must be Bool; e2 and e3 must have the same type, which is also the type of the entire conditional expression.
***)

eq If E E1 E2 = Case E ((:) Alt NoLoc (PApp (UnQual (Ident "True" )) []) (UnGuardedAlt E1) (BDecls [])
                        (:) Alt NoLoc (PApp (UnQual (Ident "False")) []) (UnGuardedAlt E2) (BDecls [])
                        []) .

***(
The following identity holds:
[e1, ..., ek]   =   e1 : (e2 : ( ... (ek : [])))
where : and [] are constructors for lists, as defined in the Prelude (see Section 6.1.3). The types of e1 through ek must all be the same (call it t), and the type of the overall expression is [t] (see Section 4.1.2).
***)
var Es : HsList .

eq List ((:) E Es) = InfixApp E (QConOp (Special Cons)) (List Es) .

***(
(e1, ..., ek)  for k>=2 is an instance of a k-tuple as defined in the Prelude, and requires no translation. If t1 through tk are the types of e1 through ek, respectively, then the type of the resulting tuple is (t1, ..., tk)  (see Section 4.1.2).
***)

***(
(e) is equivalent to e.
***)
eq Paren E = E .

***(
Arithmetic sequences satisfy these identities:
[e1 ..]         =   enumFrom e1
[e1, e2 ..]     =   enumFromThen e1 e2
[e1 .. e3]      =   enumFromTo e1 e3
[e1, e2 .. e3]  =   enumFromThenTo e1 e2 e3
where enumFrom, enumFromThen, enumFromTo, and enumFromThenTo are class methods in the class Enum as defined in the Prelude (see Figure 6.1).
***)

eq EnumFrom E1 = App (Var (UnQual (Ident "enumFrom"))) E1 .
eq EnumFromThen E1 E2 = App (App (Var (UnQual (Ident "enumFromThen"))) E1) E2 .
eq EnumFromTo E1 E3 = App (App (Var (UnQual (Ident "enumFromTo"))) E1) E3 .
eq EnumFromThenTo E1 E2 E3 = App (App (App (Var (UnQual (Ident "enumFromThenTo"))) E1) E2) E3 .


***(
List comprehensions satisfy these identities, which may be used as a translation into the kernel:
[ e | True ]         =   [e]
[ e | q ]            =   [ e | q, True ]
[ e | b, Q ]         =   if b then [ e | Q ] else []
[ e | p <- l, Q ]    =   let ok p = [ e | Q ]
                             ok _ = []
                         in concatMap ok l
[ e | let decls, Q ] =   let decls in [ e | Q ]
where e ranges over expressions, p over patterns, l over list-valued expressions, b over boolean expressions, decls over declaration lists, q over qualifiers, and Q over sequences of qualifiers. ok is a fresh variable. The function concatMap, and boolean value True, are defined in the Prelude.
***)
var Q : QualStmt .
var Qs : HsList .

eq ListComp E ((:) (QualStmt (Qualifier (Con (UnQual (Ident "True"))))) []) = List ((:) E []) .
eq ListComp E ((:) Q []) = ListComp E ((:) Q ((:) (QualStmt (Qualifier (Con (UnQual (Ident "True"))))) [])) .
eq ListComp E ((:) (QualStmt (Qualifier E1)) Qs) = If E1 (ListComp E Qs) (List []) .
eq ListComp E ((:) (QualStmt (Generator Loc P E1)) Qs) =
    Let (BDecls
        ((:) (FunBind
            ((:) (Match NoLoc (Ident "ok") ((:) P []) Nothing
              (UnGuardedRhs (ListComp E Qs)) (BDecls []))
            ((:) (Match NoLoc (Ident "ok") ((:) PWildCard []) Nothing
              (UnGuardedRhs (List [])) (BDecls []))
            [])))
        []))
    (App (App (Var (UnQual (Ident "concatMap"))) (Var (UnQual (Ident "ok")))) E1) .
eq ListComp E ((:) (QualStmt (LetStmt Bs)) Qs) = Let Bs (ListComp E Qs) .


***(
Translation:
The dynamic semantics of the expression let { d1; ...; dn } in e0 are captured by this translation: After removing all type signatures, each declaration di is translated into an equation of the form pi = ei, where pi and ei are patterns and expressions respectively, using the translation in Section 4.4.3. Once done, these identities hold, which may be used as a translation into the kernel:
let {p1=e1; ...; pn=en} in e0 = let (~p1, ..., ~pn) = (e1, ..., en) in e0
let p = e1 in e0              = case e1 of ~p -> e0
                                where no variable in p appears free in e1
let p = e1 in e0              = let p = fix (\ ~p -> e1) in e0
where fix is the least fixpoint operator. Note the use of the irrefutable patterns ~p. This translation does not preserve the static semantics because the use of case precludes a fully polymorphic typing of the bound variables. The static semantics of the bindings in a let expression are described in Section 4.4.3.
***)


***(
Do expressions satisfy these identities, which may be used as a translation into the kernel, after eliminating empty stmts:
do {e}                = e
do {e;stmts}          = e >> do {stmts}
do {p <- e; stmts}    = let ok p = do {stmts}
                            ok _ = fail "..."
                          in e >>= ok
do {let decls; stmts} = let decls in do {stmts}
The ellipsis "..." stands for a compiler-generated error message, passed to fail, preferably giving some indication of the location of the pattern-match failure; the functions >>, >>=, and fail are operations in the class Monad, as defined in the Prelude; and ok is a fresh identifier.
***)

var Ss : HsList .
var Loc : SrcLoc .
var P : Pat .
var Bs : Binds .

eq Do ((:) (Qualifier E) []) = E .
eq Do ((:) (Qualifier E) Ss) = InfixApp E (QVarOp (UnQual (Symbol ">>"))) (Do Ss) .
eq Do ((:) (Generator Loc P E) Ss) =
    Let (BDecls
        ((:) (FunBind
            ((:) (Match NoLoc (Ident "ok") ((:) P []) Nothing
              (UnGuardedRhs (Do Ss)) (BDecls []))
            ((:) (Match NoLoc (Ident "ok") ((:) PWildCard []) Nothing
              (UnGuardedRhs (App (Var (UnQual (Ident "fail")))
                (Lit (String "pattern fail")))) (BDecls []))
            [])))
        []))
    (InfixApp E (QVarOp (UnQual (Symbol ">>="))) (Var (UnQual (Ident "ok")))) .
eq Do ((:) (LetStmt Bs) Ss) = Let Bs (Do Ss) .


***(
A field label f introduces a selector function defined as:
f x     =   case x of { C1 p11 ...p1k  ->  e1 ; ... ; Cn pn1 ...pnk  ->  en }
where C1 ...Cn are all the constructors of the datatype containing a field labeled with f, pij is y when f labels the jth component of Ci or _ otherwise, and ei is y when some field in Ci has a label of f or undefined otherwise.
***)

***(
In the binding f = v, the field f labels v.
C { bs }    =   C (pickC1 bs undefined) ...(pickCk bs undefined)
where k is the arity of C.

The auxiliary function pickCi bs d is defined as follows:

    If the ith component of a constructor C has the field label f, and if f=v appears in the binding list bs, then pickCi bs d is v. Otherwise, pickCi bs d is the default value d.
***)

***(
Using the prior definition of pick,
e { bs }    =   case e of
                C1 v1 ... vk1 -> C1 (pickC11 bs v1) ... (pickC1k1 bs vk1)
                     ...
                Cj v1 ... vkj -> Cj (pickCj1 bs v1) ... (pickCjkj bs vkj)
                _ -> error "Update error"
where {C1,...,Cj} is the set of constructors containing all labels in bs, and ki is the arity of Ci.
***)

***(
e :: t   =   let {  v :: t;  v = e } in v
***)


endm
