***(
    Formal semantics of case statements, as layed out in the Expressions section of the Haskell Report
***)

mod HASKELL-CASE-SEMANTICS is
    including HASKELL-SYNTAX .

***(
(a)	case e of { alts } = (\v -> case v of { alts }) e
	where v is a new variable
***)

***(
(b)	case v of { p1 match1;  ... ; pn matchn }
	=  case v of { p1 match1 ;
	                _  -> ... case v of {
	                           pn matchn ;
	                           _  -> error "No match" }...}
	 where each matchi has the form:
	  | gi,1  -> ei,1 ; ... ; | gi,mi -> ei,mi where { declsi }
***)

***(
(c)	case v of { p | g1 -> e1 ; ...
	             | gn -> en where { decls }
	            _     -> e' }
	= case e' of
	  {y ->  (where y is a new variable)
	   case v of {
	         p -> let { decls } in
	                if g1 then e1 ... else if gn then en else y ;
	         _ -> y }}
***)

***(
(d)	case v of { ~p -> e; _ -> e' }
	= (\x1 ... xn -> e ) (case v of { p-> x1 }) ... (case v of { p -> xn})
	where x1, ..., xn are all the variables in p
***)

***(
(e)	case v of { x@p -> e; _ -> e' }
	=  case v of { p -> ( \ x -> e ) v ; _ -> e' }
***)

***(
(f)	case v of { _ -> e; _ -> e' } = e
***)

***(
(g)	case v of { K p1  ...pn -> e; _ -> e' }
	= case v of {
	     K x1 ...xn -> case x1 of {
	                    p1 -> ... case xn of { pn -> e ; _ -> e' } ...
	                    _  -> e' }
	     _ -> e' }
	at least one of p1, ..., pn is not a variable; x1, ..., xn are new variables
***)

***(
(h)	case v of { k -> e; _ -> e' } = if (v==k) then e else e'
	where k is a numeric, character, or string literal.
***)

***(
(i)	case v of { x -> e; _ -> e' } = case v of { x -> e }
***)

***(
(j)	case v of { x -> e } = ( \ x -> e ) v
***)

***(
(k)	case N v of { N p -> e; _ -> e' }
	= case v of { p -> e; _ -> e' }
	where N is a newtype constructor
***)

***(
(l)	case _|_ of { N p -> e; _ -> e' } = case _|_ of { p -> e }
	where N is a newtype constructor
***)

***(
(m)	case  v  of {  K  { f1  =  p1  ,  f2  =  p2  ,  ... } ->  e ; _ ->  e'  }
	=  case e' of {
	   y ->
	    case  v  of {
	      K  {  f1  =  p1  } ->
	            case  v  of { K  { f2  =  p2  ,  ...  } ->  e ; _ ->  y  };
	            _ ->  y  }}
	where f1, f2, ... are fields of constructor K; y is a new variable
***)

***(
(n)	case  v  of {  K  { f  =  p } ->  e ; _ ->  e'  }
	= case  v  of {
	     K p1 ... pn  ->  e ; _ ->  e'  }
	where pi is p if f labels the ith component of K, _ otherwise
***)

***(
(o)	case  v  of {  K  {} ->  e ; _ ->  e'  }
	= case  v  of {
	     K _ ... _ ->  e ; _ ->  e'  }
***)

***(
(p)	case (K' e1 ... em) of { K x1 ... xn -> e; _ -> e' } = e'
	where K and K' are distinct data constructors of arity n and m, respectively
***)

***(
(q)	case (K e1 ... en) of { K x1 ... xn -> e; _ -> e' }
	= (\x1 ... xn -> e) e1 ... en
	where K is a data constructor of arity n

***)

***(
(r)
	case _|_ of { K x1 ... xn -> e; _ -> e' } = _|_
	where K is a data constructor of arity n

***)

***(
(s)
	case v of { x+k -> e; _ -> e' }
	= if v >= k then (\x -> e) (v-k) else e'
	where k is a numeric literal
***)

endm