***(
    Formal semantics of case statements, as layed out in the Expressions section of the Haskell Report
***)

mod HASKELL-CASE-SEMANTICS is
    including HASKELL-SYNTAX .
    including HASKELL-SYNTAX-UTILS .
    vars Loc1 Loc2 Loc3 Loc4 Loc5 : SrcLoc .
    vars Binds1 Binds2 Binds3 Decls1 Decls2 Decls3 : Binds .
    vars Pat1 Pat2 Pat3 PatN Underscore : Pat .
    vars Match1 Match2 MatchN : GuardedAlts .

***(
    Current assumptions:
      - I generalize Binds in all these rules
***)

***(
(a) case e of { alts } = (\v -> case v of { alts }) e
  where v is a new variable
***)

***(
(b) case v of { p1 match1;  ... ; pn matchn }
  =  case v of { p1 match1 ;
                  _  -> ... case v of {
                             pn matchn ;
                             _  -> error "No match" }...}
   where each matchi has the form:
    | gi,1  -> ei,1 ; ... ; | gi,mi -> ei,mi where { declsi }

Base case:
  AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-b.hs" 2 26) (PApp (UnQual (Ident "P1")) ([])) (UnGuardedAlt (Var (UnQual (Ident "match1")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-b.hs" 2 41) (PApp (UnQual (Ident "Pn")) ([])) (UnGuardedAlt (Var (UnQual (Ident "matchn")))) (BDecls ([]))) ([]))))
     ===
      (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-b.hs" 3 26) (PApp (UnQual (Ident "P1")) ([])) (UnGuardedAlt (Var (UnQual (Ident "match1")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-b.hs" 3 41) PWildCard (UnGuardedAlt (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-b.hs" 3 58) (PApp (UnQual (Ident "Pn")) ([])) (UnGuardedAlt (Var (UnQual (Ident "matchn")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-b.hs" 4 58) PWildCard (UnGuardedAlt (App (Var (UnQual (Ident "error"))) (Lit (String "No match")))) (BDecls ([]))) ([]))))) (BDecls ([]))) ([]))))

  more-general: (Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1 Binds1) ((:)(Alt Loc2 PatN MatchN Binds2) [])))
      ===
        (Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1:GuardedAlts Binds1) ((:)(Alt Loc1 PWildCard (UnGuardedAlt (Case (Var V:QName) ((:)(Alt Loc2 PatN MatchN Binds2) ((:)(Alt Loc2 PWildCard TerminatingMatch (BDecls [])) [])))) (BDecls [])) [])))
       if nonWild(PatN)

Inductive Case:
  more-general: (Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1 Binds1) ((:)(Alt Loc2 Pat2 Match2 Binds2) Rest:HsList)))
     ===
       (Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1:GuardedAlts Binds1) ((:)(Alt Loc1 PWildCard (UnGuardedAlt (Case (Var V:QName) ((:)(Alt Loc2 Pat2 Matchd2 Binds2) Rest:HsList))) (BDecls [])) [])))
      if nonEmpty(Rest)
***)

    --- The final termination of a case statement
    op TerminatingMatch : -> GuardedAlts [ctor] .
    eq TerminatingMatch = UnGuardedAlt (App (Var (UnQual (Ident "error"))) (Lit (String "No match"))) .

    --- Base Case
   ceq Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1 Binds1) ((:)(Alt Loc2 PatN MatchN Binds2) []))
     = Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1:GuardedAlts Binds1) ((:)(Alt Loc1 PWildCard (UnGuardedAlt (Case (Var V:QName) ((:)(Alt Loc2 PatN MatchN Binds2) ((:)(Alt Loc2 PWildCard (UnGuardedAlt (App (Var (UnQual (Ident "error"))) (Lit (String "No match")))) (BDecls [])) [])))) (BDecls [])) []))
    if notWild(PatN) .

   --- Inductive Case
  ceq Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1 Binds1) ((:)(Alt Loc2 Pat2 Match2 Binds2) Rest:HsList))
    = Case (Var V:QName) ((:)(Alt Loc1 Pat1 Match1:GuardedAlts Binds1) ((:)(Alt Loc1 PWildCard (UnGuardedAlt (Case (Var V:QName) ((:)(Alt Loc2 Pat2 Match2 Binds2) Rest:HsList))) (BDecls [])) []))
   if nonEmpty(Rest:HsList) .


***(
(c) case v of { p | g1 -> e1 ; ...
                  | gn -> en where { decls }
                _      -> e' }
  = case e' of
    {y ->  (where y is a new variable)
     case v of {
           p -> let { decls } in
                case () of {
                  () | gs1 -> e1;
                  _ -> ... case () of {
                             () | gsn -> en;
                             _ -> y } ... }
           _ -> y }}
***)

***(
(d) case v of { ~p -> e; _ -> e' }
  = (\x1 ... xn -> e ) (case v of { p-> x1 }) ... (case v of { p -> xn})
  where x1, ..., xn are all the variables in p
***)

***(
(e) case v of { x@p -> e; _ -> e' }
  =  case v of { p -> ( \ x -> e ) v ; _ -> e' }
Pending questions:
  - Again with the _, currently assume it to be any pattern

AST:  (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 26) (PAsPat (Ident "x") (PVar (Ident "p"))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 36) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 26) (PVar (Ident "p")) (UnGuardedAlt (App (Paren (Lambda (SrcLoc "tests/case-e.hs" 3 33) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 48) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))

more-general: (Case (Var V:QName) ((:)(Alt Loc1 (PAsPat X:Name Pat1) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))
   ===
     (Case (Var V:QName) ((:)(Alt Loc1 Pat1 (UnGuardedAlt (App (Paren (Lambda Loc2 ((:)(PVar X:Name) []) E:Exp)) (Var (UnQual V:QName)))) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 (PAsPat X:Name Pat1) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Case (Var V:QName) ((:)(Alt Loc1 Pat1 (UnGuardedAlt (App (Paren (Lambda Loc2 ((:)(PVar X:Name) []) E:Exp)) (Var (UnQual V:QName)))) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])) .


***(
(f) case v of { _ -> e; _ -> e' } = e
Pending Questions:
  - I think the second _ just means some pattern, while the first must be an actual underscore

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 26) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 34) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
    (Var (UnQual (Ident "e")))

more-general: (Case (Var V:QName) ((:)(Alt Loc1 UnderscoreLit:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) [])))
    ===
    E:Exp

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 PWildCard (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = E:Exp .

***(
(g) case v of { K p1  ...pn -> e; _ -> e' }
  = case v of {
       K x1 ...xn -> case x1 of {
                      p1 -> ... case xn of { pn -> e ; _ -> e' } ...
                      _  -> e' }
       _ -> e' }
  at least one of p1, ..., pn is not a variable; x1, ..., xn are new variables
***)

***(
(h) case v of { k -> e; _ -> e' } = if (v==k) then e else e'
  where k is a numeric, character, or string literal .
***)


***(
(i) case v of { x -> e; _ -> e' } = case v of { x -> e }

Pending questions:
  - Is the _ able to be any pattern, or must this only apply when an underscore is present?
    Currently, I say it can be any pattern, as I think that's the intent.

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 23) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 31) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 3 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))


more-general: Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []) .

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []) .

***(
(j) case v of { x -> e } = ( \ x -> e ) v

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-j.hs" 2 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))
   ===
     (App (Paren (Lambda (SrcLoc "tests/case-j.hs" 3 16) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))

more-general:  (Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []))
   ===
     (App (Paren (Lambda Loc1 ((:)(PVar X:Name) []) E:Exp)) (Var V:QName))
***)

    *** eq (Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []))
    ***  = (App (Paren (Lambda Loc1 ((:)(PVar X:Name) []) E:Exp)) (Var V:QName)) .

***(
(k) case N v of { N p -> e; _ -> e' }
  = case v of { p -> e; _ -> e' }
  where N is a newtype constructor

Note: We'll need to use K for this one, as the AST doesn't know that N is a newtype constructor

***)

***(
(l) case _|_ of { N p -> e; _ -> e' } = case _|_ of { p -> e }
  where N is a newtype constructor
Pending questions:
  - I have no idea what bottom means in the context of dynamic semantics
Note: We'll need to use K for this one, as the AST doesn't know that N is a newtype constructor

***)

***(
(m) case  v  of {  K  { f1  =  p1  ,  f2  =  p2  ,  ... } ->  e ; _ ->  e'  }
  =  case e' of {
     y ->
      case  v  of {
        K  {  f1  =  p1  } ->
              case  v  of { K  { f2  =  p2  ,  ...  } ->  e ; _ ->  y  };
              _ ->  y  }}
  where f1, f2, ... are fields of constructor K; y is a new variable
***)

***(
(n) case  v  of {  K  { f  =  p } ->  e ; _ ->  e'  }
  = case  v  of {
       K p1 ... pn  ->  e ; _ ->  e'  }
  where pi is p if f labels the ith component of K, _ otherwise
Note: Will have to use K in order to know about the "K" constructor
***)

***(
(o) case  v  of {  K  {} ->  e ; _ ->  e'  }
  = case  v  of {
       K _ ... _ ->  e ; _ ->  e'  }
Note: Will have to use K in order to know the arity of the "K" constructor
***)

***(
(p) case (K' e1 ... em) of { K x1 ... xn -> e; _ -> e' } = e'
  where K and K' are distinct data constructors of arity n and m, respectively
Pending questions:
  - I think the underscore has to be a literal underscore

AST: (Case (Paren (App (App (App (Con (UnQual (Ident "K'"))) (Lit (Int 1))) (Lit (Int 2))) (Lit (Int 3)))) ((:)(Alt (SrcLoc "tests/case-p.hs" 4 35) (PApp (UnQual (Ident "K")) ((:)(PVar (Ident "x1")) ((:)(PVar (Ident "x2")) ((:)(PVar (Ident "x3")) ([]))))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-p.hs" 4 52) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Var (UnQual (Ident "e'")))

more-general: (Case KPrime:Exp ((:)(Alt Loc1 K:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))
   ===
     EPrime:Exp
   if notSameConstructor(KPrime:Exp, K:Pat)
***)

    ceq Case KPrime:Exp ((:)(Alt Loc1 K:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
      = EPrime:Exp
     if notSameConstructor(KPrime:Exp, K:Pat) .

***(
(q) case (K e1 ... en) of { K x1 ... xn -> e; _ -> e' }
  = (\x1 ... xn -> e) e1 ... en
  where K is a data constructor of arity n

***)

***(
(r)
  case _|_ of { K x1 ... xn -> e; _ -> e' } = _|_
  where K is a data constructor of arity n
Pending Questions:
  - I'm unsure of what bottom here would mean in a dynamic semantics

***)

***(
(s)   case () of { () | g1, ..., gn -> e; _ -> e' }
  = case () of {
      () | g1 -> ... case () of {
                     () | gn -> e;
                     _ -> e' } ...
      _ -> e' }
  where y is a new variable
***)

***(
(t)   case () of { () | p <- e0 -> e; _ -> e' }
  = case e0 of { p -> e; _ -> e' }
Pending Questions:
  - I'm unsure of the _ here, so I'll have it be literal

AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-t.hs" 4 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-t.hs" 4 30) ((:)(Generator (SrcLoc "tests/case-t.hs" 4 32) (PApp (UnQual (Ident "Pat")) ((:)(PVar (Ident "pat")) ([]))) (Var (UnQual (Ident "e0")))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-t.hs" 4 52) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "e0"))) ((:)(Alt (SrcLoc "tests/case-t.hs" 5 27) (PApp (UnQual (Ident "Pat")) ((:)(PVar (Ident "pat")) ([]))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-t.hs" 5 41) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))

more-general: Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Generator Loc3 Pat1 E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Case E0:Exp ((:)(Alt Loc1 Pat1 (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))

***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Generator Loc3 Pat1 E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Case E0:Exp ((:)(Alt Loc1 Pat1 (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])) .


***(
(u)   case () of { () | let decls -> e; _ -> e' }
  = let decls in e

Pending questions:
  - I think the _ could be generalized to any pattern

AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-u.hs" 3 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-u.hs" 3 30) ((:)(LetStmt (BDecls ((:)(PatBind (SrcLoc "tests/case-u.hs" 3 36) (PVar (Ident "x1")) Nothing (UnGuardedRhs (Var (UnQual (Ident "a")))) (BDecls ([]))) ([])))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-u.hs" 3 49) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Let (BDecls ((:)(PatBind (SrcLoc "tests/case-u.hs" 4 18) (PVar (Ident "x1")) Nothing (UnGuardedRhs (Var (UnQual (Ident "a")))) (BDecls ([]))) ([]))) (Var (UnQual (Ident "e"))))

more-general: Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(LetStmt Decls1) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Let Decls1 E:Exp
***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(LetStmt Decls1) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Let Decls1 E:Exp .


***(
(v)   case () of { () | e0 -> e; _ -> e' }
  = if e0 then e else e'

Pending Questions:
  - This time I'm assuming the _ is a literal underscore

AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-v.hs" 2 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-v.hs" 2 30) ((:)(Qualifier (Var (UnQual (Ident "e0")))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-v.hs" 2 42) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (If (Var (UnQual (Ident "e0"))) (Var (UnQual (Ident "e"))) (Var (UnQual (Ident "e'"))))

more-general: (Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Qualifier E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))
   ===
     (If E0:Exp E:Exp EPrime:Exp)
***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Qualifier E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
     = If E0:Exp E:Exp EPrime:Exp .


endm