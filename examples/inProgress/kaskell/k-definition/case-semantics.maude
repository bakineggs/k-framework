***(
    Formal semantics of case statements, as layed out in the Expressions section of the Haskell Report
***)

mod HASKELL-CASE-SEMANTICS is
    including HASKELL-SYNTAX .

***(
(a)	case e of { alts } = (\v -> case v of { alts }) e
	where v is a new variable
***)

***(
(b)	case v of { p1 match1;  ... ; pn matchn }
	=  case v of { p1 match1 ;
	                _  -> ... case v of {
	                           pn matchn ;
	                           _  -> error "No match" }...}
	 where each matchi has the form:
	  | gi,1  -> ei,1 ; ... ; | gi,mi -> ei,mi where { declsi }
***)

***(
(c)	case v of { p | g1 -> e1 ; ...
	             | gn -> en where { decls }
	            _     -> e' }
	= case e' of
	  {y ->  (where y is a new variable)
	   case v of {
	         p -> let { decls } in
                case () of {
                  () | gs1 -> e1;
                  _ -> ... case () of {
                             () | gsn -> en;
                             _ -> y } ... }
	         _ -> y }}
***)

***(
(d)	case v of { ~p -> e; _ -> e' }
	= (\x1 ... xn -> e ) (case v of { p-> x1 }) ... (case v of { p -> xn})
	where x1, ..., xn are all the variables in p
***)

***(
(e)	case v of { x@p -> e; _ -> e' }
	=  case v of { p -> ( \ x -> e ) v ; _ -> e' }
Pending questions:
  - Again with the _, currently assume it to be any pattern
  - Again with Binds, again generalized

AST:  (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 26) (PAsPat (Ident "x") (PVar (Ident "p"))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 36) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 26) (PVar (Ident "p")) (UnGuardedAlt (App (Paren (Lambda (SrcLoc "tests/case-e.hs" 3 33) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 48) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))

more-general: (Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PAsPat X:Name (PVar P:Name)) (UnGuardedAlt (Var E:QName)) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt (Var EPrime:QName)) B2:Binds) [])))
   ===
     (Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar P:Name) (UnGuardedAlt (App (Paren (Lambda Loc2:SrcLoc ((:)(PVar X:Name) []) (Var (UnQual E:QName)))) (Var (UnQual V:QName)))) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt (Var EPrime:QName)) B2:Binds) [])))

***)

    eq Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PAsPat X:Name (PVar P:Name)) (UnGuardedAlt (Var E:QName)) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt (Var EPrime:QName)) B2:Binds) []))
     = Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar P:Name) (UnGuardedAlt (App (Paren (Lambda Loc2:SrcLoc ((:)(PVar X:Name) []) (Var (UnQual E:QName)))) (Var (UnQual V:QName)))) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt (Var EPrime:QName)) B2:Binds) [])) .



***(
(f)	case v of { _ -> e; _ -> e' } = e
Pending Questions:
  - I think the second _ just means some pattern, while the first must be an actual underscore

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 26) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 34) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
    (Var (UnQual (Ident "e")))

more-general: (Case (Var V:QName) ((:)(Alt Loc1:SrcLoc UnderscoreLit:Pat (UnGuardedAlt E:Exp) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt EPrime:Exp) B2:Binds) [])))
    ===
    E:Exp

***)

    eq Case (Var V:QName) ((:)(Alt Loc1:SrcLoc PWildCard (UnGuardedAlt E:Exp) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt EPrime:Exp) B2:Binds) []))
     = E:Exp .

***(
(g)	case v of { K p1  ...pn -> e; _ -> e' }
	= case v of {
	     K x1 ...xn -> case x1 of {
	                    p1 -> ... case xn of { pn -> e ; _ -> e' } ...
	                    _  -> e' }
	     _ -> e' }
	at least one of p1, ..., pn is not a variable; x1, ..., xn are new variables
***)

***(
(h)	case v of { k -> e; _ -> e' } = if (v==k) then e else e'
	where k is a numeric, character, or string literal.
***)

***(
(i)	case v of { x -> e; _ -> e' } = case v of { x -> e }

Pending questions:
  - Is the _ able to be any pattern, or must this only apply when an underscore is present?
    Currently, I say it can be any pattern, as I think that's the intent.
  - The parser gives us Binds in Alts. I don't know why. Currently I generalize them

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 23) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 31) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 3 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))


minus-srcLoc: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (Loc1:SrcLoc) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (Loc2:SrcLoc) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (Loc1) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))


more-general: (Case (Var (V:QName)) ((:)(Alt (Loc1:SrcLoc) (PVar (X:Name)) (UnGuardedAlt (E:Exp)) (BDecls ([]))) ((:)(Alt (Loc2:SrcLoc) (Underscore:Pat) (UnGuardedAlt (EPrime:Exp)) (BDecls ([]))) ([]))))
   ===
     (Case (Var (V)) ((:)(Alt (Loc1) (PVar (X)) (UnGuardedAlt (E)) (BDecls ([]))) ([])))

minus-bdecls: (Case (Var (V:QName)) ((:)(Alt (Loc1:SrcLoc) (PVar (X:Name)) (UnGuardedAlt (E:Exp)) (B1:Binds)) ((:)(Alt (Loc2:SrcLoc) (Underscore:Pat) (UnGuardedAlt (EPrime:Exp)) (B2:Binds)) ([]))))
   ===
     (Case (Var (V)) ((:)(Alt (Loc1) (PVar (X)) (UnGuardedAlt (E)) (B1)) ([])))

final: Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt EPrime:Exp) B2:Binds) []))
   ===
     Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) []) .

***)

    eq Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) ((:)(Alt Loc2:SrcLoc Underscore:Pat (UnGuardedAlt EPrime:Exp) B2:Binds) []))
     = Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) []) .

***(
(j)	case v of { x -> e } = ( \ x -> e ) v

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-j.hs" 2 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))
   ===
     (App (Paren (Lambda (SrcLoc "tests/case-j.hs" 3 16) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))

more-general:  (Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) []))
   ===
     (App (Paren (Lambda Loc1:SrcLoc ((:)(PVar X:Name) []) E:Exp)) (Var V:QName))
***)

    eq (Case (Var V:QName) ((:)(Alt Loc1:SrcLoc (PVar X:Name) (UnGuardedAlt E:Exp) B1:Binds) []))
     = (App (Paren (Lambda Loc1:SrcLoc ((:)(PVar X:Name) []) E:Exp)) (Var V:QName)) .

***(
(k)	case N v of { N p -> e; _ -> e' }
	= case v of { p -> e; _ -> e' }
	where N is a newtype constructor
***)

***(
(l)	case _|_ of { N p -> e; _ -> e' } = case _|_ of { p -> e }
	where N is a newtype constructor
***)

***(
(m)	case  v  of {  K  { f1  =  p1  ,  f2  =  p2  ,  ... } ->  e ; _ ->  e'  }
	=  case e' of {
	   y ->
	    case  v  of {
	      K  {  f1  =  p1  } ->
	            case  v  of { K  { f2  =  p2  ,  ...  } ->  e ; _ ->  y  };
	            _ ->  y  }}
	where f1, f2, ... are fields of constructor K; y is a new variable
***)

***(
(n)	case  v  of {  K  { f  =  p } ->  e ; _ ->  e'  }
	= case  v  of {
	     K p1 ... pn  ->  e ; _ ->  e'  }
	where pi is p if f labels the ith component of K, _ otherwise
***)

***(
(o)	case  v  of {  K  {} ->  e ; _ ->  e'  }
	= case  v  of {
	     K _ ... _ ->  e ; _ ->  e'  }
***)

***(
(p)	case (K' e1 ... em) of { K x1 ... xn -> e; _ -> e' } = e'
	where K and K' are distinct data constructors of arity n and m, respectively
***)

***(
(q)	case (K e1 ... en) of { K x1 ... xn -> e; _ -> e' }
	= (\x1 ... xn -> e) e1 ... en
	where K is a data constructor of arity n

***)

***(
(r)
	case _|_ of { K x1 ... xn -> e; _ -> e' } = _|_
	where K is a data constructor of arity n

***)

***(
(s) 	case () of { () | g1, ..., gn -> e; _ -> e' }
	= case () of {
	    () | g1 -> ... case () of {
	                   () | gn -> e;
	                   _ -> e' } ...
	    _ -> e' }
	where y is a new variable
***)

***(
(t) 	case () of { () | p <- e0 -> e; _ -> e' }
	= case e0 of { p -> e; _ -> e' }
***)

***(
(u) 	case () of { () | let decls -> e; _ -> e' }
	= let decls in e
***)

***(
(v) 	case () of { () | e0 -> e; _ -> e' }
	= if e0 then e else e'
***)

endm