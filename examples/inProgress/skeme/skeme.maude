in ../../../k-prelude

mod SKEME-SYNTAX is including PL-INT + PL-RAT + PL-FLOAT + PL-ID + PL-STRING . 

    sort Literal .     op #t :  -> Literal .     op #f :  -> Literal .    op #unspecified :  -> Literal . 
                       op [] :  -> Literal .     op #[] :  -> Literal .
                       subsort Int <  Literal .    subsort Float <  Literal .    subsort Rat <  Literal .    op #\_ :  Char -> Literal .  

    sort Exp .    subsort Literal <  Exp . 
                  subsort Id <  Exp .    op {_} :  String -> Exp . 
                  op [_] :  List{Exp} -> Exp .    op #[_] :  List{Exp} -> Exp .    op [_._] :  List{Exp}  Exp -> Exp .      

    sort List{Exp} .    subsort Exp <  List{Exp} .    op .List{Exp} :  -> List{Exp} .    op __ : List{Exp}  List{Exp} -> List{Exp} [assoc id: .List{Exp} metadata "hybrid"] .  

    sort Program .    op program(List{Exp}) :  -> Program .  

        op eval :  -> Id .    op display :  -> Id .    op set-car! :  -> Id .    op set-cdr! :  -> Id .    op = :  -> Id .    op + :  -> Id .    op - :  -> Id .    op * :  -> Id .    op / :  -> Id .
                 op call-with-current-continuation :  -> Id .    op call/cc :  -> Id .    op car :  -> Id .    op cdr :  -> Id . 

  eq [ .List{Exp}  ] =  [] .  
  eq # [ .List{Exp}  ] =  #[] . 
  eq [EL:List{Exp} .  [] ] =  [EL:List{Exp}] . 
  eq [EL:List{Exp} .  [EL':List{Exp}]] =  [EL:List{Exp} EL':List{Exp}] . 
  eq [EL:List{Exp} .  [EL':List{Exp} .  E:Exp]] =  [EL:List{Exp} EL':List{Exp} .  E:Exp] . 

var EL' : List{Exp} . var EL : List{Exp} . var E : Exp .  endm

mod SKEME-INTERNAL is including K + SKEME-SYNTAX .

    sort Closure .       op closure(List{Id},List{Exp},Map) :  -> Closure .
                         op varClosure(List{Id{,Id,List{Exp},Map) :  -> Closure . 

    sort Continuation .    op continuation(K,Map) :  -> Continuation . 

    sort Internal .      op vT :  -> Internal .    op vF :  -> Internal .    op vUnspec :  -> Internal .    op vNil :  -> Internal . 
                         op vi(Int) :  -> Internal .    op vf(Float) :  -> Internal .    op vr(Rat) :  -> Internal .    op vc(Char) :  -> Internal .                                            
                         op cons(K,K) :  -> Internal .    op vec(Map) :  -> Internal .    op string(Map) :  -> Internal .    subsort Builtin <  Internal .  
  
    sort Builtin .      op bEval :  -> Builtin .    op bDisplay :  -> Builtin .    op bSetCar :  -> Builtin .    op bSetCdr :  -> Builtin .    op bEqual :  -> Builtin .    op b+ :  -> Builtin .    op b- :  -> Builtin .    op b* :  -> Builtin .    op b/ :  -> Builtin . 
                        op bCallCC :  -> Builtin .    op bCar :  -> Builtin .    op bCdr :  -> Builtin . 

    sort List{Id} .    subsort Id <  List{Id} .    op .List{Id} :  -> List{Id} .    op _,_ : List{Id}  List{Id} -> List{Id} [assoc id: .List{Id} metadata "hybrid"] . 

        op #procedure(Closure) :  -> Literal .    op #continuation(Continuation) :  -> Literal .    op #builtin(Builtin) :  -> Literal .    
  
endm

mod SKEME-PROGRAMS is including SKEME-SYNTAX .
        op bar :  -> List{Exp} .    op foo :  -> List{Exp} .  

  eq foo =  [3][4] .
  eq bar =  [1 2] .
endm

mod SKEME-SEMANTICS is including SKEME-INTERNAL .

        subsort Program <  K .    subsort Exp <  K .    subsort Char <  K .    subsort String <  K .  
        subsort Internal <  KResult . 

  op loc : K -> Rat .

  mb configuration < T >  < k > (.).K  </ k >  
                    < program >  (.).List  </ program > 
                    < globalEnv > (.).Map  </ globalEnv >  
                    < env >   (.).Map  </ env >  
                    < store >  
                          (.).Map 
                           
                          
                           
                          
                           
                          
                           
                           
                           
                           
                          
                          
                    </ store >  
                    < nextLoc >  0 </ nextLoc >  
                    < output >  (.).List  </ output > 
               </ T > : KSentence . 
ops program k globalEnv store output nextLoc env T : -> CellLabel .  endm

mod SKEME is including SKEME-SEMANTICS + SKEME-PROGRAMS . 
        op run(_) :  List{K} -> Bag .  

     op KLtoL : List{K} -> List . 
     eq KLtoL((K:K ,, KL:List{K})) =  ListItem(K) KLtoL(KL) .  
     eq KLtoL(.List{K} ) =  (.).List . 

       
  eq run(KL:List{K}) =  < T >...   < program >  KLtoL(KL) </ program >   ...</ T > . 
 
                     
  mb rule 
      < globalEnv >   (.).Map  => 
                       eval                           |->  loc(0)                         
                       display                        |->  loc(1)  
                       set-car!                        |->  loc(2) 
                       set-cdr!                        |->  loc(3) 
                       =                               |->  loc(4) 
                       +                               |->  loc(5) 
                       -                               |->  loc(6)  
                       *                               |->  loc(7)  
                       /                               |->  loc(8)  
                       call-with-current-continuation  |->  loc(9)   
                       call/cc                         |->  loc(9)   
                       car                            |->  loc(10) 
                       cdr                            |->  loc(11) 
      </ globalEnv > 
      < store >       (.).Map  =>  
                       loc(0)  |->  bEval 
                       loc(1)  |->  bDisplay 
                       loc(2)  |->  bSetCar 
                       loc(3)  |->  bSetCdr
                       loc(4)  |->  bEqual 
                       loc(5)  |->  b+ 
                       loc(6)  |->  b-  
                       loc(7)  |->  b*  
                       loc(8)  |->  b/  
                       loc(9)  |->  bCallCC 
                       loc(10) |->  bCar 
                       loc(11) |->  bCdr 
      </ store >  : KSentence [metadata "structural"] .


                   
      
  mb rule < k >  (.).K  =>  K </ k >  < program >  ListItem(K) =>  (.).List   ...</ program >  : KSentence [metadata "structural"] . 
var KL : List{K} .  var K : K .  endm

