--- remove DESUGARED- below
mod FUN-PROGRAMS is including FUN-DESUGARED-SYNTAX .
  ops a b c d e f g h i j k l m n o p q r s t u v w x y z : -> Id .
 
  ops p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15-1 p15-2 p16 p17 p18 p19 p20 p21 p22 : -> Exp .
  ops factorial max map : -> Id .
  ops f00 f01 f02 f03 f04 f05 f06 f07 f08 f09 f10 f11 f12 f13 f14 : -> Id .

  eq p1 = (
    letrec factorial x = if x <= 0 then 1 else x * factorial(x - 1)
    in factorial 5
  ) .

  eq p2 = (
    letrec max l =
             if null?(cdr l)
             then car l
             else let x = max (cdr l)
                  in if (x <= car l)
                     then car l
                     else x
    in max [1, 3, 5, 2, 4, 0, -1, -5]
  ) .

  eq p3 = (
    letrec max l x = (car (cdr l))
    in max [1, 3, 5, 2, 4, 0, -1, -5] true
  ) .

  eq p4 = (
    let max l x = (car (cdr l))
    in max [1, 3, 5, 2, 4, 0, -1, -5] true
  ) .

  eq p5 = (
    letrec
      max l x y
        = if null?(cdr l)
          then car l
          else let x = max(cdr l) x y
               in if (x <= car l)
                  then car l
                  else x
    and
      factorial x
        = if x <= 0
          then 1
          else x * factorial(x - 1)
    in max [1, 3, 5, 2, 4, 0, -1, -5] true 5
  ) .

  eq p6 = (
    let (x, y) = (1,2)
    in x + y
  ) .

  eq p7 = (
    let f (x, y) = x + y
    in f(1,2)
  ) .

  eq p8 = (
    let f (a, b) (x, y)	= a(x,y) + b(x,y)
    in f (fun (x, y) -> x * y, fun (x, y) -> x + y) (1,2)
  ) .

  eq p9 = (
    letrec
      max l (x, y) =
        if (* x) != y
        then -1
        else if null?(cdr l)
             then (car l)
             else let x = max (cdr l) ((x := (* x) + 1 ; x), y + 1)
                  in if (x <= car l)
                     then (car l)
                     else x
    and
      map f l = 
        if null? l
        then []
        else cons (f (car l)) (map f (cdr l))
    and
      factorial x =
        if x <= 0
        then 1
        else x * factorial(x - 1)
    in max (map factorial [1, 2, 3, 4, 5, factorial 5]) (ref 1, 1)
  ) .

  eq p10 = (
    let f x y = (x := (* x) + 2 ; y := (* y) + 3)
    and x = ref 0
    in (f x x ; * x)
  ) .

--- next should get stuck
  eq p11 = (
    let x = 1
    in letrec x = 2
       and    y = x
       in y
  ) .

  eq p12 = (
    let f x = x + x
    in let y = ref 5
       in f (y := (* y) + 3 ; * y)
  ) .

--- replace parameter passing style of f from name with val or need 
  eq p13 = (
    let f
          = let c = ref 0
            in (
                c := (* c) + 100 ;
                fun x -> (
                                c := (* c) + 1000 ;
                                x + x + (* c)
                               )
               )
    in let y = ref 0
       in f(y := (* y) + 1 ; * y) + f(0)
  ) .

--- test & x (address of x)
  eq p14 = (
    let f x = x := (* x) + 1
    and x = 7
    in [x, (f(& x) ; x), (f(& x) ; x)]
  ) .

--- test empty argument
  eq p15-1 = (
    let f () = 7
    in f
  ) .

  eq p15-2 = (
    let x = 7
    in let f () = x
       in f()
  ) .

--- test polymorphism
  eq p16 = (
    let f x = x
    in f
  ) .

  eq p17 = (
    let f x = x
    in f 3
  ) .

  eq p18 = (
    let f = fun x -> x
     in if (f true) then (f 2) else (f 3)
  ) .

  eq p19 = (
    let f = fun x -> let y = x
                               in y
    in (fun x -> f) 7
  ) .

--- p20 justifies the restriction that reference types should not be polymorphic
--- the following runs in our semantics, but it should not type (elements of different types are added in *r)!
  eq p20 = (
    let f = let r = ref []
            in fun x -> (r := cons x (* r) ; x)
    in if f true then f 3 else f 4
  ) .

  eq p21 = (
    fun (x,y,z) -> y
  ) .

  eq p22 = (
    let f00 = fun x -> fun y -> x in
      let f01 = fun x -> f00 (f00 x) in
        let f02 = fun x -> f01 (f01 x) in
          let f03 = fun x -> f02 (f02 x) in
            let f04 = fun x -> f03 (f03 x) in
              let f05 = fun x -> f04 (f04 x) in
                let f06 = fun x -> f05 (f05 x) in
                  let f07 = fun x -> f06 (f06 x) in
                    let f08 = fun x -> f07 (f07 x) in
                       f08
  ) .

endm

rew p1 .
rew p2 .
rew p3 .
rew p4 .
rew p5 .
rew p6 .
rew p7 .
rew p8 .
rew p9 .
rew p10 .
rew p11 .
rew p12 .
rew p13 .
rew p14 .
rew p15-1 .
rew p15-2 .
rew p16 .
rew p17 .
rew p18 .
rew p19 .
rew p20 .
rew p21 .
rew p22 .

q
