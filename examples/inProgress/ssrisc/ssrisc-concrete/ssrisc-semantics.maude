mod SSRISC-CONFIGURATION is including SSRISC-TIME-MODEL + SSRISC-COMMUNICATION-INTERFACE + SSRISC-SYNTAX + PL-CONVERSION + K .

      subsort Instr <  K .    subsort Reg <  K .    subsort FReg <  K .  

      subsort Int32 <  KResult .    subsort Float <  KResult .  

mb configuration 

    < k > (.).K  </ k > 
    < pc > 0 </ pc > 
    < regs > (.).Map  </ regs > 
    < fregs > (.).Map  </ fregs > : KSentence . 

ops fregs k regs pc : -> CellLabel .  endm
 
mod SSRISC-SEMANTICS is including SSRISC-CONFIGURATION .

   
mb rule < k >  .  =>  geti(PC) </ k > 
     < pc > PC:Int32 </ pc > : KSentence .   

mb rule  < k >  R:Reg =>  I  ...</ k > 
      < regs >...  R |->  I:Int32 ...</ regs > : KSentence . 

mb rule < k >  incPC(PC) =>  .   ...</ k > 
     < pc > PC:Int32 =>  PC +Int32  4 </ pc > : KSentence .   

mb rule < k >  setPC(1, NewV:Int32) =>  .   ...</ k > 
     < pc > Pc:Int32 =>  NewV </ pc > : KSentence .  

mb rule < k >  setPC(0,  ? ) =>  (.).K   ...</ k > : KSentence . 

mb rule < k >  update(I:Int32, Rd:Reg) =>  .  </ k > 
     < regs >...   Rd |->  ( ?  =>  I)  ...</ regs > : KSentence . 

mb rule  < k >  FR:FReg =>  F  ...</ k > 
      < fregs >...  FR |->  F:Float ...</ fregs > : KSentence . 

mb rule < k >  update(F:Float, FRd:FReg) =>  .  </ k > 
     < fregs >...   FRd |->  ( ?  =>  F)  ...</ fregs > : KSentence . 


       


     

 
    
mb rule < k >  add Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 +Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  addu Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 +Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  addi Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 +Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  addiu Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 +Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  sub Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 -Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  subi Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 -Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  and Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 &Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  andi Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 &Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  or Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 |Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  ori Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(V1 |Int32  V2, Rd) </ k > : KSentence . 

    
mb rule < k >  sll Rd:Reg,V1:Int32,V3:Nat ;  =>  update(V1 <<Int32  V3, Rd) </ k > : KSentence . 

    
mb rule < k >  srl Rd:Reg,V1:Int32,V3:Nat ;  =>  update(V1 >>Int32  V3, Rd) </ k > : KSentence . 

   
    
mb rule < k >  sra Rd:Reg,V1:Int32,V3:Nat ;  =>  update(V1 >>Int32  V3, Rd) </ k > : KSentence . 

    
mb rule < k >  slt Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(Bool2Int(V1 <Int32  V2), Rd) </ k > : KSentence . 

    
mb rule < k >  slti Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(Bool2Int(V1 <Int32  V2), Rd) </ k > : KSentence . 

    
mb rule < k >  sltu Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(Bool2Int(V1 <Int32  V2), Rd) </ k > : KSentence . 

    
mb rule < k >  sltiu Rd:Reg,V1:Int32,V2:Int32 ;  =>  update(Bool2Int(V1 <Int32  V2), Rd) </ k > : KSentence . 

  
mb rule < k >  j Addr:Int32 ;  =>  setPC(1, Addr) </ k > : KSentence . 

  
mb rule < k >  jr Rs:Reg ;  =>  setPC(1, Rs) </ k > : KSentence . 

   
mb rule < k >  jal Imm:Int32 ;  =>  setPC(1, Imm) </ k > : KSentence . 

    
mb rule < k >  beq V1:Int32, V2:Int32, Addr ;  =>  setPC(Bool2Int(V1 ==Bool  V2), Addr) </ k > : KSentence . 

    
mb rule < k >  bne V1:Int32, V2:Int32, Addr ;  =>  setPC(Bool2Int(V1 =/=Bool  V2), Addr) </ k > : KSentence . 

   
mb rule < k >  bltz V1:Int32, Addr ;  =>  setPC(Bool2Int(V1 <Int32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  bgtz V1:Int32, Addr ;  =>  setPC(Bool2Int(V1 >Int32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  blez V1:Int32, Addr ;  =>  setPC(Bool2Int(V1 <=Int32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  bgez V1:Int32, Addr ;  =>  setPC(Bool2Int(V1 >=Int32  0), Addr) </ k > : KSentence . 

   
mb rule < k >  lui Rt:Reg, Imm:Int32 ;  =>  update(Imm, Rt) </ k > : KSentence . 

   
mb rule < k >  lw Rd:Reg, Off:Int32(V1:Int32);  =>  update(getd(V1 +Int32  Off), Rd) </ k > : KSentence . 

   
mb rule < k >  lw Rd:Reg, (V1:Int32 +  V2:Int32);  =>  update(getd(V1 +Int32  V2), Rd) </ k > : KSentence . 

   
mb rule < k >  sw Rd:Reg, Off:Int32(V1:Int32);  =>  putd(V1 +Int32  Off, Rd) </ k > : KSentence . 

   
mb rule < k >  sw Rd:Reg, (V1:Int32 +  V2:Int32);  =>  putd(V1 +Int32  V2, Rd) </ k > : KSentence . 
     
 
mb rule < k >  nop ;  =>  .  </ k > : KSentence . 

    
mb rule < k >  add.s  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 +Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  add.d  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 +Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  sub.s  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 -Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  sub.d  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 -Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  mul.s  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 *Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  mul.d  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 *Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  div.s  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 /Float  FV2, FRd) </ k > : KSentence . 

    
mb rule < k >  div.d  FRd:FReg,FV1:Float,FV2:Float ;  =>  update(FV1 /Float  FV2, FRd) </ k > : KSentence . 

var F : Float . var V3 : Nat . var Rd : Reg . var Off : Int32 . var FV2 : Float . var Rt : Reg . var V1 : Int32 . var V2 : Int32 . var FV1 : Float . var Pc : Int32 . var PC : Int32 . var FRd : FReg . var Addr : Int32 . var Imm : Int32 . var I : Int32 . var R : Reg . var FR : FReg . var Rs : Reg . var NewV : Int32 .  endm


