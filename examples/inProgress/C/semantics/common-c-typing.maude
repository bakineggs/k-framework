--- FIXME need to automatically pad structs

mod COMMON-SEMANTICS-TYPE-DECLARATIONS is
	including COMMON-INCLUDE .
	
	--- mb rule
		--- < k > [... => typedDeclaration(no-type, ...)] ...</ k > 
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > ['Declaration(T:Type,, X:Id) => typedDeclaration(T:Type, X:Id)] ...</ k > 
		--- : KSentence [metadata "structural"] .
	
	--- mb [typedef-declaration] : rule
		--- < k > ['Typedef(T:Type,, X:Typedef-Name) => definedType(T:Type, X:Typedef-Name)] ...</ k >
		--- --- < types >... [.Map => X:Typedef-Name |-> T:Type] ...</ types >
		--- --- < typedefs >... [.Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		--- : KSentence [metadata "structural"] .
	op giveGlobalType : Id Type -> K .
	op giveLocalType : Id Type -> K .
	
	mb rule
		< k > giveType(X:Id, T:Type) => 
			if (Fun:Id ==Bool File-Scope) then giveGlobalType(X:Id, T:Type) else giveLocalType(X:Id, T:Type) fi
			...</ k >
		< currentFunction > Fun:Id </ currentFunction >
		: KSentence [metadata "structural"] .
	mb rule
		< k > giveGlobalType(X:Id, T:Type) => (.).K ...</ k >
		< types > M:Map => M:Map[T:Type / X:Id] </ types >
		< gtypes > M':Map => M':Map[T:Type / X:Id] </ gtypes >
		: KSentence [metadata "structural"] .
	mb rule
		< k > giveLocalType(X:Id, T:Type) => (.).K ...</ k >
		< types > M:Map => M:Map[T:Type / X:Id] </ types >
		: KSentence [metadata "structural"] .		
		
	--- mb [global-declaration] : rule
		--- < k > ['Global(definedType(T:Type, X:K)) => giveGlobalType(T:Type, X:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	
	--- op declarators : -> Set [memo] .
	--- eq declarators = Set(l('Declaration),, l('Field),, l('Parameter-Declaration),, l('Typedef),, l('Pointer)) .
	
	--- --- fixme hack for (int )(b705 + 0)->b6[0].b4.b1
	--- mb rule 
		--- < type > [X:Id + I:Int => X:Id] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < type > [X:Id - I:Int => X:Id] ...</ type >
		--- : KSentence [metadata "structural"] .
	
	--- --- these happen during casts to int* or int[5]
	--- --- not at < k > because these happen in < type > too
	--- mb rule 
		--- ['_`[_`](T:Type,, N:Nat) => arrayType(T:Type, N:Nat)]
		--- : KSentence [metadata "structural"] .
	--- --- fixme there should really be many different pointers
	--- mb rule 
		--- ['Pointer(T:Type) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- ['Pointer(T:Type,, ?:Id) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- ['Direct-Function-Declarator(PTL:Parameter-Type-List) => 'Direct-Function-Declarator(anonymousId,, PTL:Parameter-Type-List)]
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > ['Global(skipval) => .K ] ...</ k >
		--- : KSentence [metadata "structural"] .

	--- mb rule
		--- < k > [L:KLabel(T:Type,, 'Direct-Function-Declarator(D:Declarator,, PTL:KResult))
		--- => L:KLabel(functionType(T:Type, PTL:KResult),, D:Declarator)] ...</ k > 
		--- if declarators contains l(L:KLabel)
		--- : KSentence [metadata "structural"] .
	
	--- mb rule
		--- < k > L:KLabel([X:Id => T:Type],, D:Declarator) ...</ k >
		--- < typedefs >... typedefName(X:Id) |-> T:Type ...</ typedefs >
		--- if declarators contains l(L:KLabel)
		--- : KSentence [metadata "structural"] .
	
	--- mb rule 
		--- < k > [L:KLabel(T:Type,, '_`[_`](K:K,, tv(N:Nat, ?:Base-Type))) => L:KLabel(arrayType(T:Type, N:Nat),, K:K)] ...</ k >
		--- if declarators contains l(L:KLabel)
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- [L:KLabel(T:Type,, 'BitField(D:K,, N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, D:K)]
		--- if declarators contains l(L:KLabel)
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- [L:KLabel(T:Type,, 'BitField(N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, unnamedBitField)]
		--- if declarators contains l(L:KLabel)
		--- : KSentence [metadata "structural"] .
endm
***(
mod COMMON-SEMANTICS-TYPE-STRICTNESS is
	including COMMON-INCLUDE .

	mb context ?:KLabel(?,, 'Direct-Function-Declarator(D:Declarator,, `[HOLE`]:K)) : KSentence .
	
	mb rule
		< k > ['Parameter-Type-List(V:KResult) => typedParameterList(getList{K}(V:KResult))] ...</ k > : KSentence [metadata "structural"] .
	
	mb rule
		< k > ['Parameter-Declaration(T:Type,, X:Id) => typedDeclaration(T:Type, X:Id)] ...</ k > : KSentence [metadata "structural"] .
	mb rule
		< k > ['Parameter-Declaration(T:Type) => typedDeclaration(T:Type, anonymousId)] ...</ k > : KSentence [metadata "structural"] .

	mb context 'Field(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Declaration(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Parameter-Declaration(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
	mb context 'Typedef(?,, '_`[_`](?,, `[HOLE`]:K)) : KSentence .
				
	mb [type-arrow-heat]: rule
		< type > ['_->_(Kp:KProper,, X:Id) => Kp:KProper ~> '_->_(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-arrow-cool]: rule
		< type > [T:Type ~> '_->_(HOLE,, X:Id) => '_->_(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-dot-heat]: rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-dot-cool]: rule
		< type > [T:Type ~> '_._(HOLE,, X:Id) => '_._(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > ['_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > [T:Type ~> Deref(HOLE) => 'Deref(T:Type)] ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-heat-deref]: rule
		< type > ['Deref(Kp:KProper) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		: KSentence [metadata "structural"] .
endm
***)

mod COMMON-SEMANTICS-TYPE-CANONICALIZATION is
	including COMMON-INCLUDE .
	
	op canonicalizeType : Bag -> K .
	op canonicalizeType : Bag K Bag Bag Bag -> K [metadata "strict(2)"] .
		
	mb rule
		< k > canonicalizeType(B:Bag) => canonicalizeType(B:Bag, (.).K, (.).Bag, (.).Bag, (.).Bag) ...</ k >
		: KSentence .
		
	--- specifier, modifier, storage
	mb rule
		< k > canonicalizeType((B:Bag (BagItem(T:K) => (.).Bag)), ?, (? ((.).Bag => BagItem(T:K))), ?, ?) ...</ k >
		if false
		orBool (T:K ==Bool Void)
		orBool (T:K ==Bool Char)
		orBool (T:K ==Bool Short)
		orBool (T:K ==Bool Int)
		orBool (T:K ==Bool Long)
		orBool (T:K ==Bool Float)
		orBool (T:K ==Bool Double)
		orBool (T:K ==Bool Signed)
		orBool (T:K ==Bool Unsigned)
		orBool (getKLabel(T:K) ==Bool 'StructDef)
		orBool (getKLabel(T:K) ==Bool 'UnionDef)
		orBool (getKLabel(T:K) ==Bool 'EnumDef)
		orBool (getKLabel(T:K) ==Bool 'Named)
		--- orBool (T:K ==Bool Complex)
		: KSentence .
	
	mb rule
		< k > canonicalizeType(B:Bag (BagItem(T:K) => (.).Bag), ?, ?, (? (.).Bag => BagItem(T:K)), ?) ...</ k >
		if (T:K ==Bool SpecTypedef)
		orBool (T:K ==Bool Inline)
		: KSentence .

	mb rule
		< k > canonicalizeType(B:Bag (BagItem(T:K) => (.).Bag), ?, ?, ?, (? (.).Bag => BagItem(T:K))) ...</ k >
		if (T:K ==Bool Extern)
		: KSentence .
		
	mb rule
		< k > canonicalizeType((.).Bag, (T:Type => qualifiedType(T:Type, Extern)), (.).Bag, (.).Bag, (? BagItem(Extern) => (.).Bag)) ...</ k >
		: KSentence .
		
	mb rule
		< k > canonicalizeSpecifier(BagItem(Named(X:Id)))
			=> typedefType(X:Id, T:Type)
		...</ k >
		< types >... typedef(X:Id) |-> T:Type ...</ types >
		if X:Id =/=Bool Identifier("")
		: KSentence .
		
	mb rule
		< k > canonicalizeSpecifier(BagItem(EnumDef(X:Id, L:List{C})))
			=> EnumDef(X:Id, L:List{C})
			~> enumType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	
	mb rule
		< k > canonicalizeSpecifier(BagItem(StructDef((X:Id => unnamed(N:Nat)), L:List{C}))) ...</ k >
		< freshNat > N:Nat => sNat(N:Nat) </ freshNat >
		: KSentence .
	
	mb rule
		< k > canonicalizeSpecifier(BagItem(StructDef(X:Id, L:List{C})))
			=> StructDef(X:Id, L:List{C})
			~> structType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	mb rule
		< k > canonicalizeSpecifier(BagItem(UnionDef(X:Id, L:List{C})))
			=> UnionDef(X:Id, L:List{C})
			~> unionType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
		
		
	--- FIXME what good is this?
	eq BagItem(SpecTypedef) = (.).Bag .
	eq BagItem(Const) = (.).Bag .

	mb rule 
		< k > canonicalizeType((.).Bag, ((.).K => canonicalizeSpecifier(B:Bag)), (B:Bag => (.).Bag), ?, ?) ...</ k >
		: KSentence .
		
	mb rule
		< k > canonicalizeType((.).Bag, T:Type, (.).Bag, (.).Bag, (.).Bag) => T:Type ...</ k >
		: KSentence .
		
	op canonicalizeSpecifier : Bag -> K .
	--- C99 6.7.2:2
	eq canonicalizeSpecifier(BagItem(Void)) = void .
	eq canonicalizeSpecifier(BagItem(Char)) = char .
	eq canonicalizeSpecifier(BagItem(Signed) BagItem(Char)) = signed-char .
	eq canonicalizeSpecifier(BagItem(Unsigned) BagItem(Char)) = unsigned-char .
	
	ceq canonicalizeSpecifier(B:Bag) = short-int
		if B:Bag ==Bool BagItem(Short)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Short)
		orBool B:Bag ==Bool BagItem(Short) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Short) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-short-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Short)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Short) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = int
		if B:Bag ==Bool BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-int
		if B:Bag ==Bool BagItem(Unsigned)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Int) .

	ceq canonicalizeSpecifier(B:Bag) = long-int
		if B:Bag ==Bool BagItem(Long)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Long) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-long-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = long-long-int
		if B:Bag ==Bool BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Long) BagItem(Long) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Long) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = unsigned-long-long-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Long) BagItem(Int) .
		
endm

mod COMMON-C-TYPING is
	including COMMON-INCLUDE .
	--- including COMMON-SEMANTICS-TYPE-STRICTNESS .
	including COMMON-SEMANTICS-TYPE-DECLARATIONS .
	including COMMON-SEMANTICS-TYPE-CANONICALIZATION .
	
	--- op preFunctionType : List{Type} -> Type .
	--- op preBitfieldType : Nat -> Type .
	--- op preArrayType : Nat -> Type .
	--- op prePointerType : -> Type .
	op structDefType : Id List{Type} -> Type .
	
	op DeclType : K K -> K .
	op BitFieldType : K K -> K [metadata "strict"] .
	
	mb rule
		Specifier(L:List{Type}) => canonicalizeType(Bag(getList{K}(L:List{Type})))
		: KSentence .
	mb rule
		< k > StructRef(X:Id) => structType(X:Id) ...</ k >
		: KSentence .
		
	op variadic : -> Type .
	eq Prototype(T:Type, L:List{Type}, false) = functionType(T:Type, L:List{Type}) .
	eq Prototype(T:Type, L:List{Type}, true) = functionType(T:Type, (L:List{Type} :: variadic)) .
	eq BitFieldType(T:Type, tv(N:Nat, ?)) = bitfieldType(T:Type, N:Nat) .
	eq ArrayType(T:Type, tv(N:Nat, ?)) = arrayType(T:Type, N:Nat) .
	eq ArrayType(T:Type, emptyValue) = incompleteArrayType(T:Type) .
	eq PointerType(T:Type) = pointerType(T:Type) .
				
	mb rule 
		< k > JustBase => T:Type ...</ k >
		< declarationTypeHolder > T:Type => . ...</ declarationTypeHolder >
		: KSentence .
		
	--- op bah : Type Type -> K .
	--- mb rule
		--- < k > (. => bah(T:Type, T':Type)) ...</ k >
		--- (< declarationTypeHolder > T:Type </ declarationTypeHolder >
		--- < declarationTypeHolder > T':Type </ declarationTypeHolder > => (.).Bag)
		--- : KSentence .
			
	mb rule
		< k > DeclType(T:Type, K:K) => K:K ...</ k >
		< declarationTypeHolder > (. => T:Type) ...</ declarationTypeHolder >
		: KSentence .
	
	op fillBitHoles : List{Type} -> List{Type} .
	op fillBitHoles : Nat List{Type} -> List{Type} .
	eq fillBitHoles(Nil) = Nil .
	--- if we haven't seen bitfields
	ceq fillBitHoles((typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= typedDeclaration(T:Type, X:Id) :: fillBitHoles(L:List{Type})
	if notBool hasBitfieldType(T:Type) .
	
	ceq fillBitHoles((typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= fillBitHoles(0, typedDeclaration(T:Type, X:Id) :: L:List{Type})
	if hasBitfieldType(T:Type) .
	
	--- if we have seen bitfields
	ceq fillBitHoles(N:Nat, (typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= typedDeclaration(bitfieldType(unsigned-int, absInt(numBitsPerByte -Int (N:Nat %Nat numBitsPerByte)) %Nat numBitsPerByte), #NoName)
		:: fillBitHoles(typedDeclaration(T:Type, X:Id) :: L:List{Type})
	if notBool hasBitfieldType(T:Type) .
	
	ceq fillBitHoles(N:Nat, (typedDeclaration(bitfieldType(T:Type, N':Nat), X:Id) :: L:List{Type})) 
		= typedDeclaration(bitfieldType(T:Type, N':Nat), X:Id)
		:: fillBitHoles(N:Nat +Nat N':Nat, typedDeclaration(T:Type, X:Id) :: L:List{Type}) 
		if N':Nat =/=Bool 0 .
	
	mb rule
		< k > StructDef(X:Id, L:List{Type})
			=> addAggregate(X:Id, fillBitHoles(L:List{Type}))
			~> giveType(X:Id, structType(X:Id))
			--- ~> structType(X:Id)
		...</ k >
		: KSentence .

	--- FIXME what good is this?
	mb rule
		< k > OnlyTypedef(?) => . ...</ k >
		: KSentence .
			
	op addAggregate : Id List{Type} -> K .
	op addGlobalAggregate : Id List{Type} -> K .
	op addLocalAggregate : Id List{Type} -> K .
	mb rule
		< k > addAggregate(X:Id, L:List{Type}) 
			=> if (F:Id ==Bool File-Scope) then 
				(addGlobalAggregate(X:Id, L:List{Type})) 
			else
				(addLocalAggregate(X:Id, L:List{Type}))
			fi
		...</ k >
		< currentFunction > F:Id </ currentFunction >
		: KSentence .
	mb rule
		< k > addGlobalAggregate(X:Id, L:List{Type}) => . ...</ k >
		< structs > M:Map => M:Map[L:List{Type} / X:Id] </ structs >
		< gstructs > M:Map => M:Map[L:List{Type} / X:Id] </ gstructs >
		: KSentence .
	mb rule
		< k > addLocalAggregate(X:Id, L:List{Type}) => . ...</ k >
		< structs > M:Map => M:Map[L:List{Type} / X:Id] </ structs >
		: KSentence .
		
	mb rule
		NameAndType(X:Id, T:Type) => typedDeclaration(T:Type, X:Id)
		: KSentence .
	op NameAndType : K K -> K [metadata "strict(2)"] .
	
	mb rule
		SingleName(T:Type, Name(X:Id, K:K)) => NameAndType(X:Id, DeclType(T:Type, K:K))
		: KSentence .
	mb rule
		FieldGroup(T:Type, Name(X:Id, K:K)) => NameAndType(X:Id, DeclType(T:Type, K:K))
		: KSentence .
	mb rule
		FieldGroup(T:Type, BitFieldName(Name(X:Id, K:K), Size:K))
		=> NameAndType(X:Id, DeclType(T:Type, BitFieldType(K:K, Size:K)))
		: KSentence .
	eq FieldName(K:K) = K:K .
	
	op isAType_ : K -> Bool .
	ceq isAType T:Type = true
		if setOfTypes contains l(getKLabel(T:Type)) .
	eq isAType T:BaseType = true .
	***(
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	
	--- fixme ignoring qualifiers
	mb rule [qualifiedType(T:Type, ?) => T:Type] : KSentence [metadata "structural"] .
	
	mb rule [unsigned-short => unsigned-short-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long => unsigned-long-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long-long => unsigned-long-long-int] : KSentence [metadata "structural"] .
	mb rule [short => short-int] : KSentence [metadata "structural"] .
	mb rule [long => long-int] : KSentence [metadata "structural"] .
	mb rule [long-long => long-long-int] : KSentence [metadata "structural"] .
	***)
			
	--- eq byteSizeofType(T:Type) = bitsToBytes(bitSizeofType(T:Type)) .
			
	eq hasArrayType(arrayType(?, ?)) = true .
	ceq hasArrayType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'arrayType .
		
	eq hasIncompleteType(incompleteArrayType(?)) = true .
	ceq hasIncompleteType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'incompleteArrayType .
		
	eq hasExternType(qualifiedType(T:Type, K:K)) = if (K:K ==Bool Extern) then (true) else (hasExternType(T:Type)) fi .
	ceq hasExternType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasBitfieldType(bitfieldType(?, ?)) = true .
	ceq hasBitfieldType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'bitfieldType .	
		
	eq hasFunctionType(functionType(?, ?)) = true .
	ceq hasFunctionType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'functionType .
		
	eq hasFunctionPointerType(pointerType(functionType(?, ?))) = true .
	ceq hasFunctionPointerType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'pointerType .
	ceq hasFunctionPointerType(pointerType(T:Type)) = false
		if getKLabel(T:Type) =/=Bool 'functionType .
		
	op evalToType : -> K .
	op HOLE : -> K .
	mb rule
		< k > typeof(E:Expression) => evalToType ~> typeof(HOLE) ...</ k >
		((.).Bag => < type > E:Expression </ type >)
		: KSentence [metadata "structural"] .
	mb rule
		< k > evalToType ~> typeof(HOLE) => T:Type ...</ k >
		(< type > T:Type </ type > => (.).Bag)
		if isAType T:Type
		: KSentence [metadata "structural"] .
		
	mb rule
		< type > functionObject(?, T:Type, ?) => T:Type ...</ type >
		: KSentence [metadata "structural"] .

	--- mb rule
		--- < type > [F:Float => double] </ type >
		--- : KSentence [metadata "structural"] .
	--- --- why did this suddenly become necessary?
	--- mb rule
		--- < type > [atv(?, T:Type) => T:Type] </ type >
		--- : KSentence [metadata "structural"] .
	--- --- c99 6.4.5
	--- mb rule
		--- < type > [S:String => arrayType(char, lengthString(S:String))] </ type >
		--- : KSentence [metadata "structural"] .
	mb rule
		< type > K:K => T:Type ...</ type >
		< types >... K:K |-> T:Type ...</ types >
		: KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [X:Id => T:Type] ...</ type >
		--- < types >... typedefName(X:Id) |-> T:Type ...</ types >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [tv(?, T:Type) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [cast(T:Type, ?) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb [type-struct-arrow]: rule
		--- < type > ['_->_(pointerType(structType(S:Id)),, X:Id) => T:Type] ...</ type >
		--- < structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence [metadata "structural"] .
	--- mb [type-union-arrow]: rule
		--- < type > ['_->_(pointerType(unionType(S:Id)),, X:Id) => T:Type] ...</ type >
		--- < structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence [metadata "structural"] .

	--- mb [type-struct-dot]: rule
		--- < type > ['_._(structType(S:Id),, X:Id) => T:Type] ...</ type >
		--- < structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence [metadata "structural"] .
		
	--- mb [type-union-dot]: rule
		--- < type > ['_._(unionType(S:Id),, X:Id) => T:Type] ...</ type >
		--- < structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence [metadata "structural"] .


	--- mb rule
		--- < type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type)] ...</ type >
		--- : KSentence [metadata "structural"] .

	--- mb [type-deref-value]: rule
		--- < type > ['Deref(tv(?, pointerType(T:Type))) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb [type-deref-type]: rule
		--- < type > ['Deref(pointerType(T:Type)) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb [type-deref-array]: rule
		--- < type > ['Deref(arrayType(T:Type, ?)) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .

endm
