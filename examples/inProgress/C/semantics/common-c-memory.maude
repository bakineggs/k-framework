mod COMMON-MEMORY-INCLUDE is
	including COMMON-INCLUDE .
	
	--- returns the bytes in the order in which they are in memory
	op extractBytesFromMem : Nat Nat -> K . --- loc, size in bytes
	
	op encodedPointer : Int -> Nat .
	op encodedFloat : Float -> Nat .
	
	op explodeToBits : List{K} -> List{K} .
	
	op reverseList : List{K} -> List{K} .
endm

mod COMMON-SEMANTICS-READING is
	including COMMON-MEMORY-INCLUDE .
	
	op extractBitsFromMem : Nat Nat -> K . --- loc, size in bits
	op extractByteFromMem : Nat -> K .
	op getBitOffset : Nat -> Nat .
	eq getBitOffset(? +Nat bito(M:Nat)) = M:Nat .
	eq getBitOffset(?) = 0 [owise] .
	
			
	--- 1100 1100

***(
	('extractBitsFromList).KProperLabel(('dataList).KResultLabel(kList("wklist_")(BaseValue piece(204, 8)(.List{K}),,BaseValue piece(7, 8)(.List{K}),,BaseValue piece(0, 8)(.List{K}),,BaseValue piece(0, 8)(.List{K}),,BaseValue piece(0, 8)(.List{K}))),,BaseValue 0(.List{K}),,BaseValue 40(.List{K}))
***)
	--- 0100 0000
	
	op extractBitsFromList : K Nat Nat List{K} -> K . --- datalist, offset in bits into list, number of bits to extract, accumulator
	eq extractBitsFromList(dataList(L:List{K}), N:Nat, M:Nat) 
		= extractBitsFromList(dataList(explodeToBits(L:List{K})), N:Nat, M:Nat, .List{K}) .
	mb rule
		< k > extractBitsFromList(dataList((piece(?, 1),, L:List{K})), sNat(Offset:Nat), NumBits:Nat, .List{K})
			=> extractBitsFromList(dataList(L:List{K}), Offset:Nat, NumBits:Nat, .List{K})
		...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractBitsFromList(dataList((piece(N:Nat, 1),, L:List{K})), 0, sNat(NumBits:Nat), Done:List{K})
			=> extractBitsFromList(dataList(L:List{K}), 0, NumBits:Nat, (Done:List{K},, piece(N:Nat, 1)))
		...</ k >
		: KSentence [metadata "structural"] .

	mb rule
		< k > extractBitsFromList(?, 0, 0, Done:List{K}) => dataList(Done:List{K}) ...</ k >
		: KSentence [metadata "structural"] .
	
	op read : K K K -> K .
	mb context read(?, ?, value(`[HOLE`]:K)) : KSentence .
	ceq read(Loc:Nat, T:Type) = read(Loc:Nat, T:Type, value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	
	mb rule
		< k > readFunction(Loc:Nat) => extractByteFromMem(Loc:Nat) ...</ k >
		: KSentence [metadata "structural"] .

	
	mb rule
		< k > read(Loc:Nat, T:Type, bitSize:Nat)
			=> concretize(T:Type, fillToBytes(extractBitsFromMem(Loc:Nat, bitSize:Nat))) 
		...</ k >
		: KSentence [metadata "structural"] .
		
	op joinIntegerBytes : Type List{K} -> K .
	ceq concretize(T:Type, dataList(L:List{K})) = joinIntegerBytes(T:Type, L:List{K})
		if hasIntegerType(T:Type) 
		--- andBool isConcreteList(L:List{K}) 
		andBool notBool hasBitfieldType(T:Type) .
	ceq concretize(T:Type, dataList(L:List{K})) = joinIntegerBytes(T:Type, reverseList(L:List{K}))
		if hasIntegerType(T:Type) 
		--- andBool isConcreteList(L:List{K}) 
		andBool hasBitfieldType(T:Type) .
		
	--- FIXME very unsafe, not checking size of list or its contents
	ceq concretize(T:Type, dataList((piece(encodedFloat(F:Float), Len:Nat),, L:List{K}))) 
		= tv(F:Float, T:Type)
		if hasFloatType(T:Type)
		andBool Len:Nat ==Bool numBitsPerByte .
		--- andBool lengthList{K}(L:List{K}) ==Bool cfg:ptrsize -Int 1 .
	--- fixme should also check sizes are appropriate
	--- fixme very unsafe as is.  doesn't care if other bytes were overwritten
	ceq concretize(pointerType(T:Type), dataList((piece(encodedPointer(N:Nat), Len:Nat),, L:List{K}))) 
		= tv(N:Nat, pointerType(T:Type))
		if Len:Nat ==Bool numBitsPerByte
		andBool lengthList{K}(L:List{K}) ==Bool cfg:ptrsize -Int 1 .
		
	eq concretize(structType(S:Id), dataList(L:List{K})) = tv(L:List{K}, structType(S:Id)) .
	eq concretize(unionType(S:Id), dataList(L:List{K})) = tv(L:List{K}, unionType(S:Id)) .

	---  -13 == 1110011
	---   51 == 0110011
	---  115 == 1110011
	--- FIXME assuming bytes?
	op joinIntegerBytes : Type List{K} K -> K .
	eq joinIntegerBytes(T:Type, L:List{K}) = joinIntegerBytes(T:Type, L:List{K}, piece(0, 0)) .
	
	ceq joinIntegerBytes(T:Type, (L:List{K},, piece(N:Nat, Len:Nat)), piece(N':Nat, Len':Nat))
		= joinIntegerBytes(T:Type, L:List{K}, piece(_bit::_(piece(N':Nat, Len':Nat), piece(N:Nat, Len:Nat)), Len:Nat +Nat Len':Nat))
		if Len:Nat ==Bool numBitsPerByte
		andBool N':Nat >=Nat 0 .
		--- andBool N:Nat >=Nat 0 .
	ceq joinIntegerBytes(T:Type, .List{K}, piece(N:Nat, Len:Nat)) 
		= interpret(T:Type, piece(N:Nat, Len:Nat)) 
		if N:Nat >=Nat 0 .
	
	op isConcreteList : List{K} -> Bool .
	op isConcreteNumber : Nat -> Bool .
	ceq isConcreteList((N:Nat,, L:List{K})) = isConcreteList(L:List{K})
		if isConcreteNumber(N:Nat) .
	eq isConcreteList(.List{K}) = true .
	eq isConcreteNumber(sym(?) +Nat ?) = false .
	eq isConcreteNumber(bito(?) +Nat ?) = false .
	eq isConcreteNumber(?) = true [owise] .
	
	eq floorLoc(sym(N:Nat) +Nat bito(M:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat .
	eq floorLoc(sym(N:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat [owise] .
	
	mb rule
		< k > extractBitsFromMem(Loc:Nat, Size:Nat)
			=> extractBitsFromList(extractBytesFromMem(floorLoc(Loc:Nat), bitsToBytes(Size:Nat)), getBitOffset(Loc:Nat), Size:Nat) 
		...</ k >
		if floorLoc(Loc:Nat) ==Bool Loc:Nat
		: KSentence [metadata "structural"] .
	
	mb context extractBytesFromMem-aux(?, ?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	--- this next op should use Nats, but the context doesn't allow it.  See issue 54
	op extractBytesFromMem-aux : K K List{K} -> K . --- loc, size in bytes, aux list
	
	mb rule
		< k > extractBytesFromMem(Loc:Nat, Size:Nat) => extractBytesFromMem-aux(Loc:Nat, Size:Nat, .List{K}) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > extractBytesFromMem-aux(Loc:Nat, sNat(Size:Nat), Aux:List{K})
			=> extractBytesFromMem-aux(sNat(Loc:Nat), Size:Nat, (Aux:List{K},, extractByteFromMem(Loc:Nat)))
		...</ k >
		: KSentence [metadata "structural"] .
	
	op values : List{K} -> List{K} .
	eq values((tv(K:K, ?),, L:List{KResult})) = (K:K,, values(L:List{KResult})) .
	eq values(.List{K}) = .List{K} .
	mb rule
		< k > extractBytesFromMem-aux(?, 0, Aux:List{KResult}) => dataList(values(Aux:List{KResult})) ...</ k >
		: KSentence [metadata "structural"] .
	
	op rawData : BaseValue Nat -> KResult .
	--- FIXME make sure it's a byte
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => V:K ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (? Offset:Nat |-> V:K)) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		andBool Offset:Nat <Nat Size:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => piece(unknown(numBitsPerByte), numBitsPerByte) ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (M:Map => M:Map[piece(unknown(numBitsPerByte), numBitsPerByte) / Offset:Nat])) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		andBool notBool($hasMapping(M:Map, Offset:Nat))
		andBool Offset:Nat <Nat Size:Nat
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-WRITING is
	including COMMON-MEMORY-INCLUDE .
	mb context alloc(?, value(`[HOLE`]:K)) : KSentence .

	mb rule allocateType(Loc:Nat, T:Type) => alloc(Loc:Nat, value(byteSizeofType(T:Type))) : KSentence [metadata "structural"] .
	mb rule 
		< k > allocateTypeIfAbsent(Loc:Nat, T:Type) => alloc(Loc:Nat, value(byteSizeofType(T:Type))) ...</ k >
		< mem > Mem:Map </ mem >
		if notBool $hasMapping(Mem:Map, Loc:Nat)
		: KSentence [metadata "structural"] .
	mb rule 
		< k > allocateTypeIfAbsent(Loc:Nat, T:Type) => (.).K ...</ k >
		< mem >... Loc:Nat |-> ? ...</ mem >
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > alloc(sym(Block:Nat) +Nat 0, Len:Nat) => (.).K ...</ k >
		< mem >... (.).Map => Block:Nat |-> memblock(Len:Nat, (.).Map) ...</ mem >
		: KSentence [metadata "structural"] .
		
		
	
	--- problem is that we're not reading the bytes in the same order we're writing them
	--- 0000 0000  0011 is turning into 0011 0000 0000 
		
		
	op writeBytes : Nat K -> K [metadata "strict(2)"] .
	op writeBitfield : Nat Type K -> K [metadata "strict(3)"] .
	op isByteLoc : Nat -> Bool .
	op splitBytes : Value -> K .
	op calculateNewBytes : Nat K K -> K [metadata "strict(3)"] .
	
	op write : K Value K -> K [metadata "strict(2)"] .
	ceq write(K:K, tv(V:List{K}, T:Type)) 
		= write(K:K, tv(V:List{K}, T:Type), value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	--- FIXME should check types
	mb rule
		< k > write(Loc:Nat, tv(V:K, functionType(?, ?))) 
			=> writeByte(Loc:Nat, V:K) 
		...</ k >
		: KSentence [metadata "structural"] .	
	mb context write(?, ?, value(`[HOLE`])) : KSentence . 
	mb rule
		< k > write(Loc:Nat, tv(V:K, T:Type), bitSize:Nat)
			=> writeBytes(Loc:Nat, splitBytes(tv(V:K, T:Type)))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte ==Bool 0
		andBool isByteLoc(Loc:Nat)
		andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > write(Loc:Nat, tv((V:K,, V':K,, L:List{K}), T:Type), bitSize:Nat)
			=> writeBytes(Loc:Nat, dataList((V:K,, V':K,, L:List{K})))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte ==Bool 0
		andBool isByteLoc(Loc:Nat)
		andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
		

	eq bitoffset(? +Nat bito(N:Nat)) = N:Nat .
	eq bitoffset(?) = 0 [owise] .
	

	eq byteoffset(N:Nat +Nat bito(?)) = N:Nat .
	eq byteoffset(N:Nat) = N:Nat [owise] .
		
	op justBits : Int Type -> Value .
	op justBits-aux : Int Type -> Value .
	ceq justBits(I:Int, ?) = I:Int
		if I:Int >=Int 0 .
		
	ceq justBits(I:Int, T:Type) = justBits-aux(I:Int, T:Type)
		if I:Int <Int 0 .
	ceq justBits-aux(I:Int, T:Type) = justBits-aux((I:Int +Int max(T:Type) +Int 1), T:Type)
		if I:Int <Int 0 .
	eq justBits-aux(N:Nat, bitfieldType(T:Type, sNat(Len:Nat))) = N:Nat +Nat (1 <<Nat Len:Nat) .
	
	mb rule
		< k > write(Loc:Nat, tv(I:Int, T:Type), bitSize:Nat)
			=> write(Loc:Nat, tv(justBits(I:Int, T:Type), T:Type), bitSize:Nat)
		...</ k >
		if (bitSize:Nat %Nat numBitsPerByte =/=Bool 0
		orBool notBool(isByteLoc(Loc:Nat)))
		andBool I:Int <Int 0
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > write(Loc:Nat, tv(N:Nat, T:Type), bitSize:Nat)
			=> writeBitfield(Loc:Nat, T:Type, calculateNewBytes(bitoffset(Loc:Nat), piece(N:Nat, bitSize:Nat), extractBytesFromMem(floorLoc(Loc:Nat), bitsToBytes(bitSize:Nat +Nat bitoffset(Loc:Nat)))))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte =/=Bool 0
		orBool notBool(isByteLoc(Loc:Nat))
		orBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > writeBitfield(Loc:Nat, ?, dataList(L:List{K}))
			=> writeBytes(byteoffset(Loc:Nat), dataList(L:List{K}))
		...</ k >
		: KSentence [metadata "structural"] .
		
	op calculateNewBytes-aux : Nat K K List{K} -> K .
	eq calculateNewBytes(Len:Nat, N:Nat, dataList(L:List{K})) = calculateNewBytes-aux(Len:Nat, dataList(explodeToBits(N:Nat)), dataList(explodeToBits(L:List{K})), .List{K}) .
	
	eq reverseList(.List{K}) = .List{K} .
	eq reverseList((K:K,, L:List{K})) = reverseList(L:List{K}),, K:K .
	
	op joinBitsToBytes : List{K} -> K .
	op joinBitsToBytes-aux : K K -> K .
	
	eq calculateNewBytes-aux(sNat(N:Nat), K:K, dataList((piece(Bit:Nat, 1),, L:List{K})), Result:List{K}) 
		= calculateNewBytes-aux(N:Nat, K:K, dataList(L:List{K}), (Result:List{K},, piece(Bit:Nat, 1))) .
	
	eq calculateNewBytes-aux(0, dataList((piece(N:Nat, 1),, L:List{K})), dataList((piece(?, 1),, L':List{K})), Result:List{K}) 
		= calculateNewBytes-aux(0, dataList(L:List{K}), dataList(L':List{K}), (Result:List{K},, piece(N:Nat, 1))) .
	eq calculateNewBytes-aux(0, dataList(.List{K}), dataList(L:List{K}), Result:List{K}) 
		= joinBitsToBytes((Result:List{K},, L:List{K})) .
	
	eq joinBitsToBytes(L:List{K}) = joinBitsToBytes-aux(dataList(L:List{K}), dataList(.List{K})) .
	ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, piece(M:Nat, 1),, L:List{K})), dataList(R:List{K}))
		= joinBitsToBytes-aux(dataList((piece(_bit::_(piece(N:Nat, Len:Nat), piece(M:Nat, 1)), sNat(Len:Nat)),, L:List{K})), dataList(R:List{K}))
		if Len:Nat <Nat numBitsPerByte .
		--- andBool N:Nat >=Nat 0
		--- andBool M:Nat >=Nat 0 .
	ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, L:List{K})), dataList(R:List{K}))
		= joinBitsToBytes-aux(dataList(L:List{K}), dataList((R:List{K},, piece(N:Nat, Len:Nat))))
		if Len:Nat ==Bool numBitsPerByte .
	--- ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, L:List{K})), dataList(R:List{K}))
		--- = joinBitsToBytes-aux(dataList(L:List{K}), dataList((piece(N:Nat, Len:Nat),, R:List{K})))
		--- if Len:Nat ==Bool numBitsPerByte .
	eq joinBitsToBytes-aux(dataList(.List{K}), dataList(R:List{K}))
		= dataList(R:List{K}) .
	
	
	eq explodeToBits((K:K,, L:NeList{K})) = (explodeToBits(K:K),, explodeToBits(L:NeList{K})) .
	eq explodeToBits(piece(N:Nat, sNat(Len:Nat)))
		= splinter(N:Nat, sNat(Len:Nat)) .
		--- = (explodeToBits(piece(N:Nat >>Nat 1, Len:Nat)),, piece(N:Nat &Nat 1, 1)) .
	eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	eq explodeToBits(.List{K}) = .List{K} .
	
	op splinter : Nat Nat -> List{K} .
	op splinter-aux : Nat Nat Nat -> List{K} .
	eq splinter(N:Nat, Len:Nat) = splinter-aux(N:Nat, Len:Nat, 0) .
	eq splinter-aux(?, Len:Nat, Len:Nat) = .List{K} .
	ceq splinter-aux(N:Nat, Len:Nat, Pos:Nat)
		= splinter-aux(N:Nat, Len:Nat, sNat(Pos:Nat)),, piece(bitRange(N:Nat, Pos:Nat, Pos:Nat), 1)
		if Pos:Nat <Nat Len:Nat .
	
		
	op writeByte : Nat K -> K .
	mb rule
		< k > writeBytes(sym(Block:Nat) +Nat Offset:Nat, dataList((V:K,, L:List{K})))
			=> writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K)
			~> writeBytes(sym(Block:Nat) +Nat sNat(Offset:Nat), dataList(L:List{K}))
		...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K) => . ...</ k >
		< mem >... Block:Nat |-> memblock(Len:Nat, (M:Map => M:Map[V:K / Offset:Nat])) ...</ mem >
		if Offset:Nat <Nat Len:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeBytes(?, dataList(.List{K})) => . ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule splitBytes(tv(I:Int, T:Type)) 
		=> splitIntegerBytes(I:Int, T:Type, value(byteSizeofType(T:Type)))
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule splitBytes(tv(F:Float, T:Type)) 
		=> splitFloatBytes(F:Float, T:Type, value(byteSizeofType(T:Type)))
		if hasFloatType(T:Type)
		: KSentence .
	mb rule splitBytes(tv(I:Int, pointerType(T:Type))) 
		=> splitPointerBytes(I:Int, pointerType(T:Type), value(byteSizeofType(pointerType(T:Type))))
		: KSentence .
	
	op splitIntegerBytes : K K K -> K .
	op splitIntegerBytes : K K K List{K} -> K .
	mb context splitIntegerBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	eq splitIntegerBytes(I:Int, T:Type, Len:Nat) = splitIntegerBytes(I:Int, T:Type, Len:Nat, .List{K}) .
	eq splitIntegerBytes(I:Int, T:Type, sNat(Len:Nat), L:List{K})
		= splitIntegerBytes(I:Int >>Int numBitsPerByte, T:Type, Len:Nat, (L:List{K},, lowestByte(I:Int, T:Type))) .
	eq splitIntegerBytes(I:Int, T:Type, 0, L:List{K})
		= dataList(L:List{K}) .
		
	op splitPointerBytes : K K K -> K .
	op splitPointerBytes : K K K List{K} -> K .
	mb context splitPointerBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	eq splitPointerBytes(I:Int, T:Type, sNat(Len:Nat)) 
		= splitPointerBytes(I:Int, T:Type, Len:Nat, piece(encodedPointer(I:Int), numBitsPerByte)) .
	eq splitPointerBytes(I:Int, T:Type, sNat(Len:Nat), L:List{K}) = splitPointerBytes(I:Int, T:Type, Len:Nat, (L:List{K},, piece(unknown(numBitsPerByte), numBitsPerByte))) .
	eq splitPointerBytes(I:Int, T:Type, 0, L:List{K}) 
		= dataList(L:List{K}) .
		
		
	op splitFloatBytes : K K K -> K .
	op splitFloatBytes : K K K List{K} -> K .
	mb context splitFloatBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	eq splitFloatBytes(F:Float, T:Type, sNat(Len:Nat)) 
		= splitFloatBytes(F:Float, T:Type, Len:Nat, piece(encodedFloat(F:Float), numBitsPerByte)) .
	eq splitFloatBytes(F:Float, T:Type, sNat(Len:Nat), L:List{K}) = splitFloatBytes(F:Float, T:Type, Len:Nat, (L:List{K},, piece(unknown(numBitsPerByte), numBitsPerByte))) .
	eq splitFloatBytes(F:Float, T:Type, 0, L:List{K}) 
		= dataList(L:List{K}) .
		
	
	op lowestByte : Int Type -> K .
	ceq lowestByte(I:Int, T:Type) = piece(I:Int &Int byteMaskSet, numBitsPerByte)
		if hasIntegerType(T:Type) .
	
	op byteMaskSet : -> Nat .
	--- FIXME why does this parse?
	eq byteMaskSet = (2 ^Nat numBitsPerByte) -Int 1 .
		
	eq isByteLoc(? +Nat bito(?)) = false .
	eq isByteLoc(?) = true [owise] .
endm

mod COMMON-C-MEMORY-MISC is
	including COMMON-MEMORY-INCLUDE .

	mb [storeNew]: rule
		< k > storeNew tv(V:K, T:Type) atLoc Loc:Nat 
			=> alloc(Loc:Nat, value(byteSizeofType(T:Type))) 
			~> write(Loc:Nat, tv(V:K, T:Type)) 
		...</ k >
		: KSentence [metadata "structural"] .
	mb [storeAt]: rule
		< k > store tv(V:K, T:Type) atLoc Loc:Nat 
			=> write(Loc:Nat, tv(V:K, T:Type)) 
		...</ k >
		: KSentence [metadata "structural"] .
	
	--- c99 6.5:2 If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings
	--- i take this to mean that if i write to a location twice or read from a location after being written to, then it is a problem

	
	--- --- fixme it's interesting we need this.  what do the rules say about when string allocation happens?
	--- op dontCountWrite : Nat -> K .
	--- mb rule
		--- < k > [dontCountWrite(Loc:Nat) => .K] ...</ k >
		--- < locsWrittenTo >... [BagItem(Loc:Nat) => .Bag] ...</ locsWrittenTo >
		--- : KSentence [metadata "structural"] .
		
	op writeString : Nat String -> K .
	mb [alloc-string]: rule
		< k > allocString(Loc:Nat, S:String)
			=> allocateType(Loc:Nat, arrayType(char, lengthString(S:String)))
			~> writeString(Loc:Nat, S:String)
		...</ k >
		: KSentence [metadata "structural"] .
		
	mb [write-string]: rule
		< k > writeString(Loc:Nat, S:String)
			=> *(tv(Loc:Nat, pointerType(char))) := tv(charToAscii(firstChar(S:String)), char)
			~> discard
			~> writeString(sNat(Loc:Nat), butFirstChar(S:String))
		...</ k >
		if S:String =/=Bool ""
		: KSentence [metadata "structural"] .
		
	mb [write-empty-string]: rule
		< k > writeString(Loc:Nat, "") 
			=> (.).K --- *(tv(Loc:Nat, pointerType(char))) := tv(0, char) 
			--- ~> discard
		...</ k >
		: KSentence [metadata "structural"] .	
			
	--- --- fixme: fixes the type of function types so they are equivalent
	--- mb rule
		--- < k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		--- => putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		--- if L:List{K} =/=Bool L':List{K}
		--- : KSentence [metadata "structural"] .
		
	--- op isLocation : K -> Bool .
	--- eq isLocation(loc(?, ?)) = true .
	--- eq isLocation(bitloc(?, ?, ?)) = true .
	--- eq isLocation(K:K) = false [owise] .
	--- --- needs to make sure not a bitfield
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putByteInMem(loc(Block:Nat, Offset:Nat), ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(loc(Block:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if notBool(isLocation(N:Int))
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme can now check oob
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(F:Float, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[F:Float / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool (
			--- (T:Type ==Bool double)
			--- orBool T:Type ==Bool float
			--- orBool T:Type ==Bool long-double
		--- )
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme: put pointer in memory
	--- mb rule
		--- < k > putInMem(?, [tv(loc(0, 0), T:Type) => tv(0, T:Type)], ?, ?) ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(loc(Block':Nat, Offset':Nat), T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[loc(Block':Nat, Offset':Nat) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool notBool(Block':Nat ==Bool 0 andBool Offset':Nat ==Bool 0)
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))
		--- => putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), ((N:Int %Int 2) +Int 2) %Int 2) ~> 
		--- putInMem(bitloc(Block:Nat, Base:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 1, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if (Offset:Nat <Nat 8)
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, 8), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putInMem(bitloc(Block:Nat, sNat(Base:Nat), 0), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule
		--- < k > [putByteInMem(loc(Block:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, [M:Map => M:Map[piece(N:Nat, 8) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- --- this helps be fast, but is unsafe
	--- --- mb rule
		--- --- < k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		--- --- < mem > [M:Map => M:Map[piece(N:Nat, 8) / Loc:Nat]] </ mem >
		--- --- : KSentence [metadata "structural"] .
	--- --- fixme need better fidelity; shouldn't zero out bits
	--- --- fixme also need to handle the case where it's already unknown
	--- mb rule 
		--- < k > putBitInMem(bitloc(Block:Nat, Base:Nat, ?), ?) ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[piece(0, numBitsPerByte) / Base:Nat]]) ...</ mem >
		--- if notBool($hasMapping(M:Map, Base:Nat))
		--- : KSentence [metadata "structural"] .
	--- op known : Nat -> Bool .
	--- eq known(unknown(?)) = false .
	--- eq known(?) = true [owise] .
	--- --- fixme not handling undefined writing twice in a sequence point 
	--- mb rule
		--- < k > [putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, 
			--- (? Base:Nat |-> [piece(Old:Nat, 8) => 
				--- piece((Old:Nat &Nat ((1 <<Nat Offset:Nat) xorNat 255)) |Nat (N:Nat <<Nat Offset:Nat), 8)
			--- ])
		--- ) ...</ mem >
		--- if known(Old:Nat)
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-C-MEMORY is
	including COMMON-MEMORY-INCLUDE .
	including COMMON-C-MEMORY-MISC .
	including COMMON-SEMANTICS-WRITING .
	including COMMON-SEMANTICS-READING .
endm
