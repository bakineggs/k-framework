mod COMMON-SEMANTICS-STATEMENTS-INCLUDE is
	including COMMON-INCLUDE .
	op loopMarked : -> Statement .
	op deleteLoc : Nat -> K . --- deletes the base object from memory, given a location
endm 
 
mod COMMON-SEMANTICS-IF-THEN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- fixme need to represent null with 0
	--- mb [if-then-true]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ~> S:Statement ...</ k >
		--- if notBool(V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
	--- mb [if-then-false]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ...</ k >
		--- if (V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else-true]: rule
		< k > IfThenElse(tv(1, int), S:K, ?) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
	mb [if-then-else-false]: rule
		< k > IfThenElse(tv(0, int), ?, S:K) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else]: rule
		< k > IfThenElse(tv(V:BaseValue, T:Type), S:K, S':K)
			=> IfThenElse(tv(V:BaseValue, T:Type) != tv(0, int), S:K, S':K) 
		...</ k >
		if T:Type =/=Bool int
		orBool (
			V:BaseValue =/=Bool 0
			andBool V:BaseValue =/=Bool 1 
		)
		: KSentence [metadata "structural rule"] .
endm

mod COMMON-SEMANTICS-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [while-mark]: rule
		< k > While(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> While(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [while]: rule
		< k > loopMarked ~> While(B:Expression, S:Statement)
			=> IfThenElse(B:Expression, (S:Statement ~> loopMarked ~> While(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-DO-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [do-while-mark]: rule
		< k > DoWhile(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> DoWhile(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [do-while]: rule
		< k > loopMarked ~> DoWhile(B:Expression, S:Statement)
			=> S:Statement ~> IfThenElse(B:Expression, (loopMarked ~> DoWhile(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-FOR is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	eq ForClauseDeclaration(K:K) = K:K .
	eq ForClauseExpression(K:K) = K:K ~> discard .
	
	mb [for-mark]: rule
		< k > (For(Pre:K, Control:K, Post:K, S:Statement) ~> K:K
			=> pushBlock ~> Pre:K ~> loopMarked ~> For(Pre:K, (if Control:K =/=Bool emptyValue then Control:K else tv(1, int) fi), Post:K, S:Statement) ~> popLoop)
		</ k >
		< loopStack > . => ListItem((popBlock ~> K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [for]: rule
		< k > loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)
			=> IfThenElse(Control:K, (S:Statement ~> Post:K ~> discard ~> loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SWITCH is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- --- fixme shouldn't there be sequence points here?
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap >... kpair(F:Id, case(SN:Nat, V:BaseValue)) |-> kpair(K2:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap > LM:Map kpair(F:Id, defaultCase(SN:Nat)) |-> kpair(K2:K, S:List) </ gotoMap >
		--- if notBool $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) => .K] ...</ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < gotoMap > LM:Map </ gotoMap >
		--- if notBool (
			--- $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
			--- orBool $hasMapping(LM:Map, kpair(F:Id, defaultCase(SN:Nat)))
		--- )
		--- : KSentence [metadata "computational rule"] .

	--- mb [case-fall-through]: rule
		--- < k > ['case`(_`)_:_(?,, ?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb [default-fall-through]: rule
		--- < k > ['default`(_`):_(?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-GOTO is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- mb context 'calculateGotoMap(?,, ('case`(_`)_:_(?:K,,`[HOLE`]:K,, ?) ~> ?),, ?,, ?) : KSentence .
	
	--- CONFIRM It seems there are no sequence points for a goto
	--- mb rule 
		--- < k > goto(X:Id); ~> ? => K:K </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > ? => S:List </ loopStack >
		--- < gotoMap >... kpair(F:Id, X:Id) |-> kpair(K:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
		
	op calculateGotoMap : Id K List K -> K . --- func name, body, loop stack, tail
	eq calculateGotoMap(X:Id, K:K) = calculateGotoMap(X:Id, K:K, (.).List, (.).K) .
	mb rule 
		< k > calculateGotoMap(?, (.).K, ?, ?) => (.).K ...</ k >
		: KSentence [metadata "structural"] .

	--- fixme this is just temporary
	mb rule 
		< k > calculateGotoMap(?, ?, ?, ?) => (.).K ...</ k >
		: KSentence [metadata "structural"] .
	
***(
	things I have to keep track of:
		remaining computation
		...
		
***)
	
		
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (L:KLabel(Args:List{K}) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- if L:KLabel ==Bool 'Local
		--- orBool L:KLabel ==Bool '_; --- assumes we don't put '_; around actual statements
		--- orBool L:KLabel ==Bool 'goto_;
		--- orBool L:KLabel ==Bool 'continue`;
		--- orBool L:KLabel ==Bool 'break`;
		--- orBool L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- ---orBool L:KLabel ==Bool 'default`:_
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('Block`(`)(.List{K}) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('Block(Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (L:KLabel(?,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- if L:KLabel ==Bool 'if`(_`)_
		--- ---orBool L:KLabel ==Bool 'case_:_
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('if`(_`)_else_(?,, Arg1:K,, Arg2:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, Arg1:K, S:List, (Tail:K ~> K:K))
		--- ~> calculateGotoMap(X:Id, Arg2:K, S:List, (Tail:K ~> K:K))
		--- ~> calculateGotoMap(X:Id, K:K, S:List, Tail:K)
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .	
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('_:_(Target:Id,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, Target:Id) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('case`(_`)_:_(SN:Nat,, tv(Target:BaseValue, T:Type),, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, case(SN:Nat, Target:BaseValue)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('default`(_`):_(SN:Nat,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, defaultCase(SN:Nat)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .

	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('while`(_`)_(B:Expression,, S:Statement) ~> K:K), S':List, Tail:K) 
		--- => calculateGotoMap(X:Id, 
			---xxx (S:Statement ~> loopMarked ~> (while (B:Expression) S:Statement) ~> K:K),
			---xxx (ListItem((K:K ~> Tail:K)) S':List),
			--- Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (loopMarked ~> (while (B:Expression) S:Statement) ~> K:K), (ListItem( (K:K ~> Tail:K)) S':List), Tail:K)
		--- => calculateGotoMap(X:Id, K:K, S':List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('switch`(_`)`(_`)_(?,, B:Expression,, S:Statement) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id,
			---xxx (S:Statement ~> popLoop ~> K:K),
			---xxx (ListItem((K:K ~> Tail:K)) S:List),
			--- Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (popLoop ~> K:K), (? S:List), Tail:K)
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-RETURN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [erase-loc]: rule
		< k > deleteLoc(sym(Block:Nat) +Nat ?) => (.).K ...</ k >
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .
	
	mb [return-clean-local]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> Return(?) ...</ k >
		< localAddresses >... SetItem(Loc:Nat) => (.).Set ...</ localAddresses >	
		: KSentence [metadata "structural"] .
		
	mb [fetch-all-locals]: rule
		< k > Return(?) ...</ k >
		< localAddresses > (.).Set => Addresses:Set </ localAddresses >
		< blockStack > List(< stackFrame > 
			?
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
			=> (.).List
		...</ blockStack >
		: KSentence [metadata "structural"] .

	--- --- this is used for threads
	--- mb [return-nostack]: rule 
		--- < k > [L:KLabel(?) ~> ? => .K] </ k >
		--- < callStack > .List </ callStack >
		--- if L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- : KSentence [metadata "structural"] .

	--- this is used for returns with no return value as well, since we return "emptyValue", which will hopefully be cast to void
	mb [return]: rule 
		< control >
			< k > Return(V:Value) ~> ? 
				=> sequencePoint 
				~> cast(T:Type, V:Value) 
				~> K:K
			</ k >
			--- these cells get replaced by the ones in C:Bag, so we can delete them when we match them
			(< local >... < localAddresses > (.).Set </ localAddresses > ...</ local > => (.).Bag)
			--- i can't say the below line alone, but i want to :(
			--- (< localAddresses > (.).Set </ localAddresses > => (.).Bag)
			(< currentFunction > F:Id </ currentFunction > => (.).Bag)
			(< currentTranslationUnit > Tu:K </ currentTranslationUnit > => (.).Bag)
			(< blockStack > (.).List </ blockStack > => (.).Bag)
			(? => C:Bag)
		</ control >
		< gtypes >... Tu:K |-> Map((? (F:Id |-> functionType(T:Type, ?)))) ...</ gtypes >
		< callStack >
			List(
				< stackFrame >
					C:Bag
					< continuation > K:K </ continuation >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BLOCKS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb rule BlockStatement(Block:K) => pushBlock ~> Block:K ~> popBlock : KSentence .
	
	mb [push-block]: rule
		< k > pushBlock => (.).K ...</ k > 
		< local >
			C:Bag
			< localVariables > Vars:Set => (.).Set </ localVariables >
			< localAddresses > Addresses:Set => (.).Set </ localAddresses >
			< nestingDepth > N:Nat => sNat(N:Nat) </ nestingDepth >
		</ local >
		< blockStack > (.).List 
			=> List(< stackFrame > C:Bag 
			< nestingDepth > N:Nat </ nestingDepth > 
			< localVariables > Vars:Set </ localVariables >
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
		...</ blockStack >
		: KSentence [metadata "structural"] .
		
	mb [pop-block-free-memory]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> popBlock ...</ k >
		< localAddresses >... (SetItem(Loc:Nat) => (.).Set) ...</ localAddresses >
		: KSentence [metadata "structural"] .
		
	mb [pop-block]: rule
		< k > popBlock => (.).K ...</ k >
		< local > 
			(? => C:Bag)
			(< localAddresses > (.).Set </ localAddresses > => (.).Bag)
		</ local >
		< blockStack > List(< stackFrame > C:Bag </ stackFrame >) => (.).List ...</ blockStack >
		: KSentence [metadata "structural"] .
	
	
	mb [dissolve-block]: rule
		< k > Block(BlockNum:Nat, ?, Statements:List{C}) => listToK(Statements:List{C}) ...</ k > 
		< currentBlock > ? => BlockNum:Nat </ currentBlock >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-STATEMENTS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	including COMMON-SEMANTICS-IF-THEN .
	including COMMON-SEMANTICS-FOR .
	including COMMON-SEMANTICS-WHILE .
	including COMMON-SEMANTICS-SWITCH .
	including COMMON-SEMANTICS-GOTO .
	including COMMON-SEMANTICS-RETURN .
	including COMMON-SEMANTICS-BLOCKS .
	including COMMON-SEMANTICS-DO-WHILE .
	
	mb rule Nop => . : KSentence [metadata "structural"] .

	--- skip labels
	mb [skip-label]: 
		rule < k > Label(L:Id, K:K) => K:K ...</ k >
		: KSentence [metadata "structural"] .

	--- dissolve expression statements that are finished evaluating
	mb [expression-statement]: rule < k > Computation(K:K) => K:K ~> discard ~> sequencePoint ...</ k > : KSentence [metadata "structural"] .
	
	mb [popLoop]: rule
		< k > (popLoop ~> ?) => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "structural"] .
		
	mb [break]: rule
		< k > Break ~> ? => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "computational rule"] . --- nondet
	
	--- --- fixme not sure about this, isn't it possible for K:K to grab greedily?
	mb [continue]: rule
		--- < k > Continue ~> K:K => Continue ...</ k >
		< k > Continue ~> ((L:KLabel)(?) => .) ...</ k >
		if L:KLabel =/=Bool 'loopMarked
		andBool L:KLabel =/=Bool 'popBlock
		andBool L:KLabel =/=Bool 'pushBlock
		andBool L:KLabel =/=Bool 'popLoop
		: KSentence [metadata "structural"] . --- nondet
	mb [continue]: rule
		< k > Continue ~> popBlock 
			=> popBlock 
			~> Continue
		...</ k >
		: KSentence [metadata "structural"] . --- nondet
	mb [continue-done]: rule
		< k > (Continue => Post:K ~> discard) ~> loopMarked ~> For(?, ?, Post:K, ?) ...</ k >
		: KSentence [metadata "structural"] . --- nondet
	mb [continue-done]: rule
		< k > (Continue => .) ~> loopMarked ~> L:KLabel(?) ...</ k >
		if L:KLabel =/=Bool 'For
		: KSentence [metadata "structural"] . --- nondet
endm
