mod COMMON-SEMANTICS-STATEMENTS-INCLUDE is
	including COMMON-INCLUDE .
	op loopMarked : -> Statement .
	op deleteLoc : Nat -> K . --- deletes the base object from memory, given a location
endm 
 
mod COMMON-SEMANTICS-IF-THEN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- fixme need to represent null with 0
	--- mb [if-then-true]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ~> S:Statement ...</ k >
		--- if notBool(V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
	--- mb [if-then-false]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ...</ k >
		--- if (V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else-true]: rule
		< k > IfThenElse(tv(1, int), S:K, ?) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
	mb [if-then-else-false]: rule
		< k > IfThenElse(tv(0, int), ?, S:K) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else]: rule
		< k > IfThenElse(tv(V:BaseValue, T:Type), S:K, S':K)
			=> IfThenElse(tv(V:BaseValue, T:Type) != tv(0, int), S:K, S':K) 
		...</ k >
		if T:Type =/=Bool int
		orBool (
			V:BaseValue =/=Bool 0
			andBool V:BaseValue =/=Bool 1 
		)
		: KSentence [metadata "structural rule"] .
endm

mod COMMON-SEMANTICS-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [while-mark]: rule
		< k > While(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> While(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [while]: rule
		< k > loopMarked ~> While(B:Expression, S:Statement)
			=> IfThenElse(B:Expression, (S:Statement ~> loopMarked ~> While(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-DO-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [do-while-mark]: rule
		< k > DoWhile(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> DoWhile(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [do-while]: rule
		< k > loopMarked ~> DoWhile(B:Expression, S:Statement)
			=> S:Statement ~> IfThenElse(B:Expression, (loopMarked ~> DoWhile(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-FOR is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	eq ForClauseDeclaration(K:K) = K:K .
	eq ForClauseExpression(K:K) = K:K ~> discard .
	
	mb [for-mark]: rule
		< k > (For(Pre:K, Control:K, Post:K, S:Statement) ~> K:K
			=> pushBlock ~> Pre:K ~> loopMarked ~> For(Pre:K, (if Control:K =/=Bool emptyValue then Control:K else tv(1, int) fi), Post:K, S:Statement) ~> popLoop)
		</ k >
		< loopStack > . => ListItem((popBlock ~> K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [for]: rule
		< k > loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)
			=> IfThenElse(Control:K, (S:Statement ~> Post:K ~> discard ~> loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SWITCH is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- --- fixme shouldn't there be sequence points here?
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap >... kpair(F:Id, case(SN:Nat, V:BaseValue)) |-> kpair(K2:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap > LM:Map kpair(F:Id, defaultCase(SN:Nat)) |-> kpair(K2:K, S:List) </ gotoMap >
		--- if notBool $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) => .K] ...</ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < gotoMap > LM:Map </ gotoMap >
		--- if notBool (
			--- $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
			--- orBool $hasMapping(LM:Map, kpair(F:Id, defaultCase(SN:Nat)))
		--- )
		--- : KSentence [metadata "computational rule"] .

	--- mb [case-fall-through]: rule
		--- < k > ['case`(_`)_:_(?,, ?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb [default-fall-through]: rule
		--- < k > ['default`(_`):_(?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-GOTO is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- fixme CONFIRM It seems there are no sequence points for a goto
	--- mb rule 
		--- < k > goto(X:Id); ~> ? => K:K </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > ? => S:List </ loopStack >
		--- < gotoMap >... kpair(F:Id, X:Id) |-> kpair(K:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
		
	--- op calculateGotoMap : Id K Map List K -> K . --- func name, body, variables, loop stack, tail
	
	op waitingOnGotoMap : -> K .
	mb rule 
		< k > calculateGotoMap(F:Id, K:K) => waitingOnGotoMap ...</ k >
		< gotoMap > M:Map => M:Map[Map((.).Map) / kpair(Tu:K, F:Id)] </ gotoMap >
		< currentFunction > ? => F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< calculateGotoMap >
			. => (< gotoCalculation >... < computation > K:K </ computation > ...</ gotoCalculation >)
		</ calculateGotoMap >
		: KSentence .
		
	mb rule
		(< gotoCalculation > < computation > (.).K </ computation > ...</ gotoCalculation >) => (.).Bag
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > calculateGotoMap(?, (.).K, ?, ?, ?) => (.).K ...</ k >
		--- : KSentence [metadata "structural"] .
	
***(
	things I have to keep track of:
		in goto map:
			remaining computation
			which variables are allocated on the path
			...
		in blocks:
			which variables i've allocated so far
	
	I need to adjust the block stack, 
		
	When we goto, we need to take the variables on the goto path and subtract the variables we've already allocated in the real history.  Then we need to declare the remaining variables.
		
***)

	mb rule
		< k > waitingOnGotoMap => (.).K ...</ k >
		< calculateGotoMap > (.).Bag </ calculateGotoMap >
		< currentFunction > ? => File-Scope </ currentFunction >
		: KSentence [metadata "structural"] .

	op endBlockForGoto : Nat -> K .
	mb rule 
		< computation > BlockStatement(Block:K)
			=> Block:K ~> endBlockForGoto(OldNum:Nat)
		...</ computation >
		< nestingDepthGoto > N:Nat => sNat(N:Nat) </ nestingDepthGoto >
		< currentBlockGoto > OldNum:Nat </ currentBlockGoto >
		: KSentence .
	mb rule
		< computation > Block(Num:Nat, ?, L:List{C}) => listToK(L:List{C}) ...</ computation > 
		< currentBlockGoto > ? => Num:Nat </ currentBlockGoto >
		< declarationStack > . => ListItem((.).K) ...</ declarationStack >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > endBlockForGoto(Num:Nat) => (.).K ...</ computation >
		< nestingDepthGoto > sNat(N:Nat) => N:Nat </ nestingDepthGoto >
		< currentBlockGoto > ? => Num:Nat </ currentBlockGoto >
		: KSentence [metadata "structural"] .
		
	mb [StatementLoc]: rule
		< computation > StatementLoc(K:K, L:CabsLoc) => K:K ...</ computation >
		< currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		: KSentence .
	--- mb [DefinitionLoc]: rule
		--- < computation > DefinitionLoc(K:K, L:CabsLoc) => K:K ...</ computation >
		--- < currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		--- : KSentence .

	op frozenDeclaration : Nat Nat K -> K . --- nestingDepth, currentBlock, decl
	
	mb rule
		< computation > LocalDefinition(K:K) => (.).K ...</ computation >
		< declarationStack > ListItem(((. => frozenDeclaration(Depth:Nat, BlockNum:Nat, LocalDefinition(K:K))) ~> ?)) ...</ declarationStack >
		< nestingDepthGoto > Depth:Nat </ nestingDepthGoto >
		< currentBlockGoto > BlockNum:Nat </ currentBlockGoto >
		: KSentence [metadata "structural"] .
		
	mb rule 
		< computation > L:KLabel(Args:List{K}) => (.).K ...</ computation >
		if false
		orBool L:KLabel ==Bool 'Nop
		orBool L:KLabel ==Bool 'Computation
		orBool L:KLabel ==Bool 'Break
		orBool L:KLabel ==Bool 'Continue
		orBool L:KLabel ==Bool 'Return
		orBool L:KLabel ==Bool 'Goto
		orBool L:KLabel ==Bool 'CompGoto
		: KSentence [metadata "structural"] .
		
***(
	op Switch : K K -> PureStatement
	op Case : K K -> PureStatement
	op Default : K -> PureStatement
	op Label : Id K -> PureStatement
	
	op Sequence : K K -> PureStatement --- still don't know what this is
	
	--- gcc specific
	op CaseRange : K K K -> PureStatement
	op CompGoto : K -> PureStatement
	op TryExcept : K K K -> PureStatement
	op TryFinally : K K -> PureStatement	
***)

	---- dowhile, while, and for are all basically the same here
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> For(E1:K, E2:K, E3:K, S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (. => ListItem((K:K ~> Tail:K))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> For(E1:K, E2:K, E3:K, S:K) => (.).K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> DoWhile(E:K, S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (. => ListItem((K:K ~> Tail:K))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> DoWhile(E:K, S:K) => (.).K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> While(E:K, S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (. => ListItem((K:K ~> Tail:K))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> While(E:K, S:K) => (.).K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
			
	mb rule
		< computation > (Switch(E:K, S:K) => S:K ~> popLoop) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > (. => ListItem((K:K ~> Tail:K))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > popLoop => (.).K ...</ computation >
		< loopStackGoto > (?:ListItem => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	op gotoObject : K List List -> K . --- continuation, loop stack, decl stack
	mb rule
		< computation > (Label(Target:Id, S:K) => S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > LoopStack:List </ loopStackGoto >
		< declarationStack > DeclStack:List </ declarationStack >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map => M:Map[gotoObject((S:K ~> K:K ~> Tail:K), LoopStack:List, DeclStack:List) / Target:Id])) ...</ gotoMap >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool $hasMapping(M:Map, Target:Id)
		: KSentence [metadata "structural"] .	
		

		
	mb rule
		< gotoCalculation >
			< computation > (IfThenElse(?, S1:K, S2:K) => (.).K) ~> K:K </ computation >
			< computationTail > Tail:K </ computationTail >
			B:Bag
		</ gotoCalculation >
		(. =>
			< gotoCalculation > 
				< computation > S1:K </ computation > 
				< computationTail > Tail:K ~> K:K </ computationTail >
				B:Bag 
			</ gotoCalculation >
		)
		(. =>
			< gotoCalculation > 
				< computation > S2:K </ computation >
				< computationTail > Tail:K ~> K:K </ computationTail >
				B:Bag 
			</ gotoCalculation >
		)
		
		: KSentence [metadata "structural"] .
	

	
	--- skipping cases for now :(
	mb rule
		< computation > Case(E:K, S:K) => S:K ...</ computation >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > Default(S:K) => S:K ...</ computation >
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < computation > (Case(E:K, S:K) => S:K) ~> K:K </ computation >
		--- < computationTail > Tail:K </ computationTail >
		--- < loopStackGoto > LoopStack:List </ loopStackGoto >
		--- < declarationStack > DeclStack:List </ declarationStack >
		--- < gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map => M:Map[gotoObject((S:K ~> K:K ~> Tail:K), LoopStack:List, DeclStack:List) / Target:Id])) ...</ gotoMap >
		--- < currentFunction > F:Id </ currentFunction >
		--- < currentTranslationUnit > Tu:K </ currentTranslationUnit >
		--- if notBool $hasMapping(M:Map, Target:Id)
		--- : KSentence [metadata "structural"] .	
		
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('case`(_`)_:_(SN:Nat,, tv(Target:BaseValue, T:Type),, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, case(SN:Nat, Target:BaseValue)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('default`(_`):_(SN:Nat,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, defaultCase(SN:Nat)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .	
	
		
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (L:KLabel(?,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- if L:KLabel ==Bool 'if`(_`)_
		--- ---orBool L:KLabel ==Bool 'case_:_
		--- : KSentence [metadata "structural"] .
	


		
	
endm

mod COMMON-SEMANTICS-RETURN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [erase-loc]: rule
		< k > deleteLoc(sym(Block:Nat) +Nat ?) => (.).K ...</ k >
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .
	
	mb [return-clean-local]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> Return(?) ...</ k >
		< localAddresses >... SetItem(Loc:Nat) => (.).Set ...</ localAddresses >	
		: KSentence [metadata "structural"] .
		
	mb [fetch-all-locals]: rule
		< k > Return(?) ...</ k >
		< localAddresses > (.).Set => Addresses:Set </ localAddresses >
		< blockStack > List(< stackFrame > 
			?
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
			=> (.).List
		...</ blockStack >
		: KSentence [metadata "structural"] .

	--- --- this is used for threads
	--- mb [return-nostack]: rule 
		--- < k > [L:KLabel(?) ~> ? => .K] </ k >
		--- < callStack > .List </ callStack >
		--- if L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- : KSentence [metadata "structural"] .

	--- this is used for returns with no return value as well, since we return "emptyValue", which will hopefully be cast to void
	mb [return]: rule 
		< control >
			< k > Return(V:Value) ~> ? 
				=> sequencePoint 
				~> cast(T:Type, V:Value) 
				~> K:K
			</ k >
			--- these cells get replaced by the ones in C:Bag, so we can delete them when we match them
			(< local >... < localAddresses > (.).Set </ localAddresses > ...</ local > => (.).Bag)
			--- i can't say the below line alone, but i want to :(
			--- (< localAddresses > (.).Set </ localAddresses > => (.).Bag)
			(< currentFunction > F:Id </ currentFunction > => (.).Bag)
			(< currentTranslationUnit > Tu:K </ currentTranslationUnit > => (.).Bag)
			(< blockStack > (.).List </ blockStack > => (.).Bag)
			(? => C:Bag)
		</ control >
		< gtypes >... Tu:K |-> Map((? (F:Id |-> functionType(T:Type, ?)))) ...</ gtypes >
		< callStack >
			List(
				< stackFrame >
					C:Bag
					< continuation > K:K </ continuation >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BLOCKS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb rule 
		< k > BlockStatement(Block:K)
			=> pushBlock ~> Block:K ~> popBlock
		...</ k >
		: KSentence .
	
	mb [push-block]: rule
		< k > pushBlock => (.).K ...</ k > 
		< local >
			C:Bag
			< localVariables > Vars:Set => (.).Set </ localVariables >
			< localAddresses > Addresses:Set => (.).Set </ localAddresses >
			< nestingDepth > N:Nat => sNat(N:Nat) </ nestingDepth >
		</ local >
		< blockStack > (.).List 
			=> List(< stackFrame > C:Bag 
			< nestingDepth > N:Nat </ nestingDepth > 
			< localVariables > Vars:Set </ localVariables >
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
		...</ blockStack >
		: KSentence [metadata "structural"] .
		
	mb [pop-block-free-memory]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> popBlock ...</ k >
		< localAddresses >... (SetItem(Loc:Nat) => (.).Set) ...</ localAddresses >
		: KSentence [metadata "structural"] .
		
	mb [pop-block]: rule
		< k > popBlock => (.).K ...</ k >
		< local > 
			(? => C:Bag)
			(< localAddresses > (.).Set </ localAddresses > => (.).Bag)
		</ local >
		< blockStack > List(< stackFrame > C:Bag </ stackFrame >) => (.).List ...</ blockStack >
		: KSentence [metadata "structural"] .
	
	
	mb [dissolve-block]: rule
		< k > Block(BlockNum:Nat, ?, Statements:List{C}) => listToK(Statements:List{C}) ...</ k > 
		< currentBlock > ? => BlockNum:Nat </ currentBlock >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-STATEMENTS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	including COMMON-SEMANTICS-IF-THEN .
	including COMMON-SEMANTICS-FOR .
	including COMMON-SEMANTICS-WHILE .
	including COMMON-SEMANTICS-SWITCH .
	including COMMON-SEMANTICS-GOTO .
	including COMMON-SEMANTICS-RETURN .
	including COMMON-SEMANTICS-BLOCKS .
	including COMMON-SEMANTICS-DO-WHILE .
	
	mb rule Nop => . : KSentence [metadata "structural"] .

	--- skip labels
	mb [skip-label]: 
		rule < k > Label(L:Id, K:K) => K:K ...</ k >
		: KSentence [metadata "structural"] .

	--- dissolve expression statements that are finished evaluating
	mb [expression-statement]: rule < k > Computation(K:K) => K:K ~> discard ~> sequencePoint ...</ k > : KSentence [metadata "structural"] .
	
	mb [popLoop]: rule
		< k > (popLoop ~> ?) => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "structural"] .
		
	mb [break]: rule
		< k > Break ~> ? => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "computational rule"] . --- nondet
	
	mb [continue]: rule
		< k > Continue ~> ((L:KLabel)(?) => .) ...</ k >
		if L:KLabel =/=Bool 'loopMarked
		andBool L:KLabel =/=Bool 'popBlock
		andBool L:KLabel =/=Bool 'pushBlock
		andBool L:KLabel =/=Bool 'popLoop
		: KSentence [metadata "structural"] . --- nondet
	mb [continue]: rule
		< k > Continue ~> popBlock 
			=> popBlock 
			~> Continue
		...</ k >
		: KSentence [metadata "structural"] . --- nondet
	mb [continue-done]: rule
		< k > (Continue => Post:K ~> discard) ~> loopMarked ~> For(?, ?, Post:K, ?) ...</ k >
		: KSentence [metadata "structural"] . --- nondet
	mb [continue-done]: rule
		< k > (Continue => .) ~> loopMarked ~> L:KLabel(?) ...</ k >
		if L:KLabel =/=Bool 'For
		: KSentence [metadata "structural"] . --- nondet
endm
