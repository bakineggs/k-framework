mod COMMON-SEMANTICS-STATEMENTS-INCLUDE is
	including COMMON-INCLUDE .
	op loopMarked : -> Statement .
	op deleteLoc : Nat -> K . --- deletes the base object from memory, given a location
	op genLabel : Nat K -> Id . --- switchid, value (tv or 'Default)
	op popLoop : -> K .
	op popBlock : -> K .
	op pushBlock : -> K .
endm 
 
mod COMMON-SEMANTICS-IF-THEN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
		
	mb [if-then-else-true]: rule
		< k > IfThenElse(tv(1, int), S:K, ?) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
	mb [if-then-else-false]: rule
		< k > IfThenElse(tv(0, int), ?, S:K) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else]: rule
		< k > IfThenElse(tv(V:BaseValue, T:Type), S:K, S':K)
			=> IfThenElse(tv(V:BaseValue, T:Type) != tv(0, int), S:K, S':K) 
		...</ k >
		if T:Type =/=Bool int
		orBool (
			V:BaseValue =/=Bool 0
			andBool V:BaseValue =/=Bool 1 
		)
		: KSentence [metadata "structural rule"] .
endm

mod COMMON-SEMANTICS-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [while-mark]: rule
		< k > While(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> While(B:Expression, S:Statement) ~> popLoop
		</ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		< loopStack > (.).List => ListItem(kpair(Num:Nat, K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [while]: rule
		< k > loopMarked ~> While(B:Expression, S:Statement)
			=> IfThenElse(B:Expression, (S:Statement ~> loopMarked ~> While(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-DO-WHILE is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [do-while-mark]: rule
		< k > DoWhile(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> DoWhile(B:Expression, S:Statement) ~> popLoop
		</ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		< loopStack > (.).List => ListItem(kpair(Num:Nat, K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [do-while]: rule
		< k > loopMarked ~> DoWhile(B:Expression, S:Statement)
			=> S:Statement ~> IfThenElse(B:Expression, (loopMarked ~> DoWhile(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-FOR is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	eq ForClauseDeclaration(K:K) = K:K .
	eq ForClauseExpression(K:K) = K:K ~> discard .
	
	op addToHistory : Nat -> K .
	mb rule
		< k > addToHistory(Num:Nat) => (.).K ...</ k >
		< blockHistory > . => ListItem(Num:Nat) ...</ blockHistory >
		--- < xmessages >... (. => "For: adding " +String toString(Num:Nat) +String " to history") </ xmessages >
		: KSentence [metadata "structural"] .
	
	--- fixme should these blocks be here?
	--- fixme fishy interaction with continue i think
	mb [for-mark]: rule
		< k > (For(Pre:K, Control:K, Post:K, S:Statement) ~> K:K
			=> pushBlock ~> addToHistory(sym(Fresh:Nat)) ~> Pre:K ~> loopMarked ~> For(Pre:K, (if Control:K =/=Bool emptyValue then Control:K else tv(1, int) fi), Post:K, S:Statement) ~> popLoop)
		</ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		< loopStack > . => ListItem(kpair(Num:Nat, K:K)) ...</ loopStack >
		< freshNat > Fresh:Nat => sNat(Fresh:Nat) </ freshNat >
		--- < xmessages >... (. => "For: loop in " +String toString(Num:Nat) +String ", creating " +String toString(sym(Fresh:Nat))) </ xmessages >
		: KSentence [metadata "structural"] .
		
	mb [for]: rule
		< k > loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)
			=> IfThenElse(Control:K, (S:Statement ~> Post:K ~> discard ~> loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)), Nop)
		...</ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		--- < xmessages >... (. => "For: finished a loop, in " +String toString(Num:Nat) +String ", looping...") </ xmessages >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SWITCH is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- fixme shouldn't there be sequence points here?

--- < k > (For(Pre:K, Control:K, Post:K, S:Statement) ~> K:K
	--- => pushBlock 
	--- ~> Pre:K 
	--- ~> loopMarked 
	--- ~> For(Pre:K, (if Control:K =/=Bool emptyValue then Control:K else tv(1, int) fi), Post:K, S:Statement) ~> popLoop)
--- </ k >
--- < blockHistory > ListItem(Num:Nat) ...</ blockHistory >
--- < loopStack > . => ListItem(kpair(Num:Nat, K:K)) ...</ loopStack >
	
	--- fixme not doing promoting or conversion
	mb rule
		< k > Switch(SN:Nat, tv(V:BaseValue, T:Type), ?) => Goto(genLabel(SN:Nat, tv(V:BaseValue, T:Type))) ...</ k >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((? genLabel(SN:Nat, tv(V:BaseValue, T:Type)) |-> ?)) ...</ gotoMap >
		if hasIntegerType(T:Type)
		: KSentence [metadata "computational rule"] .
	--- fixme this is wrong if the arguments/types would match if we promoted
	
	mb rule
		< k > Switch(SN:Nat, tv(V:BaseValue, T:Type), ?) => Goto(genLabel(SN:Nat, l('Default))) ...</ k >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map genLabel(SN:Nat, l('Default)) |-> ?)) ...</ gotoMap >
		if hasIntegerType(T:Type)
		andBool notBool $hasMapping(M:Map, genLabel(SN:Nat, tv(V:BaseValue, T:Type)))
		: KSentence [metadata "computational rule"] .
		
	mb rule
		< k > Switch(SN:Nat, tv(V:BaseValue, T:Type), ?) => (.).K ...</ k >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map(M:Map) ...</ gotoMap >
		if hasIntegerType(T:Type)
		andBool notBool $hasMapping(M:Map, genLabel(SN:Nat, tv(V:BaseValue, T:Type)))
		andBool notBool $hasMapping(M:Map, genLabel(SN:Nat, l('Default)))
		: KSentence [metadata "computational rule"] .

	mb [case-fall-through]: rule
		< k > Case(?, ?, K:K) => K:K ...</ k >
		: KSentence [metadata "structural"] .
	mb [default-fall-through]: rule
		< k > Default(?, K:K) => K:K ...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-GOTO is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	--- fixme CONFIRM It seems there are no sequence points for a goto
	
--- c1x 6.2.4:6 For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which it is associated until execution of that block ends in any way. (Entering an enclosed block or calling a function suspends, but does not end, execution of the current block.) If the block is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate. If an initialization is specified for the object, it is performed each time the declaration or compound literal is reached in the execution of the block; otherwise, the value becomes indeterminate each time the declaration is reached.
		
***(
	things I have to keep track of:
		in goto map:
			remaining computation
			which variables are allocated on the path
			...
		in blocks:
			which variables i've allocated so far
	
	I need to adjust the block stack, 
		
	When we goto, we need to take the variables on the goto path and subtract the variables we've already allocated in the real history.  Then we need to declare the remaining variables.
		
***)

	***( 
		To do the actual goto:
			- Case 1: We are in the same block as the target.
				1. We might be jumping forwards or backwards, across declarations, so we need to figure out which variables should be left alone, allocated but not initialized, or deallocated.
					a. Skip any entries in the frozen declarationStack where the nestingDepth is smaller than our current nestingDepth
					b. All that remains should be variables in the same block as the target.
					c. As we step through the variables in the frozen declarationStack
						i. any variables we see that we have already declared stay allocated and keep their old value.
						ii. any variables that are in the declarationStack but have not been declared are variables we must allocate but not initialize
						iii. any variables that have been declared but are not in the declarationStack need to be deallocated
			- Case 2: We are in a different block than the target.
				1. We need to unwind blocks from the blockstack until we're in at nestingDepth 1 less than the nesting depth of the target.
					a. for each block we pop, we need to unallocate the memory
					b. once we're at the right place, we enter the block and then proceed similarly to case 1, except all the cases will be to allocate and not initialize
		
		The variables mentioned above are meant to be those with automatic storage duration.  Variables with external or static storage duration have their own rules.
				
	***)

	op processGoto : K -> K .
	op processGotoDown : K -> K .
	op gotoObject : Nat List K List List -> K . --- nestingDepth, block history, continuation, loop stack, decl stack
	op frozenDeclaration : Nat Nat K -> K . --- nestingDepth, currentBlock, decl
	op processGotoSameBlock : List List -> K .  --- declaration stack, actual local variables
	mb rule
		< k > Goto(Label:Id) ~> ? => processGoto(GotoInfo:K) </ k >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((? (Label:Id |-> GotoInfo:K))) ...</ gotoMap >
		: KSentence [metadata "structural"] .
		
	---- first case, when we're in the same block
	mb rule
		< k > L:KLabel(gotoObject(Depth:Nat, (ListItem(CurrentBlock:Nat) BlockHistory:List), K:K, LoopStack:List, DeclStack:List)) ~> ? 
			=> addVariablesForBlock(CurrentBlock:Nat, DeclStack:List)
			~> K:K
		</ k >
		< nestingDepth > Depth:Nat </ nestingDepth >
		< blockHistory > ListItem(CurrentBlock:Nat) BlockHistory:List </ blockHistory >
		< loopStack > ? => LoopStack:List </ loopStack >
		< localVariables > Vars:List </ localVariables >
		if L:KLabel ==Bool 'processGoto
		orBool L:KLabel ==Bool 'processGotoDown
		: KSentence [metadata "structural"] .
		
	---- second case, we're in a different block
	
	--- as long as there are entries in the actual block history that differ from the target block history, we need to pop
	mb rule
		< k > (. => popBlock) 
			~> processGoto(gotoObject(TargetDepth:Nat, TargetBlockHistory:List, K:K, LoopStack:List, DeclStack:List))
		...</ k >
		< blockHistory > ListItem(BlockNum:Nat) ActualHistory:List </ blockHistory >
		if notBool BlockNum:Nat in TargetBlockHistory:List
		: KSentence [metadata "structural"] .
		
	--- once we share a history, we start to push
	mb rule
		< k > processGoto(gotoObject(TargetDepth:Nat, (Prefix:List ListItem(TargetBlock:Nat) ActualHistory:List), K:K, LoopStack:List, DeclStack:List))
			=> addVariablesForBlock(CurrentBlock:Nat, DeclStack:List)
			~> processGotoDown(gotoObject(TargetDepth:Nat, (Prefix:List ListItem(CurrentBlock:Nat) ActualHistory:List), K:K, LoopStack:List, DeclStack:List))
		...</ k >
		< nestingDepth > ActualDepth:Nat </ nestingDepth >
		< blockHistory > ListItem(CurrentBlock:Nat) ActualHistory:List </ blockHistory >
		if sNat(ActualDepth:Nat) =/=Bool TargetDepth:Nat
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > ( . 
				=> pushBlock
				~> addVariablesForBlock(TargetBlock:Nat, DeclStack:List)
			)
			~> processGotoDown(gotoObject(TargetDepth:Nat, (? ListItem(TargetBlock:Nat) ActualHistory:List), ?, ?, DeclStack:List))
		...</ k >
		< nestingDepth > ActualDepth:Nat </ nestingDepth >
		< blockHistory > (. => ListItem(TargetBlock:Nat)) ActualHistory:List </ blockHistory >
		if sNat(ActualDepth:Nat) =/=Bool TargetDepth:Nat
		: KSentence [metadata "structural"] .
	
	--- We've made it to the block above the target
	mb rule
		< k > L:KLabel(gotoObject(sNat(Depth:Nat), 
				(ListItem(TargetBlock:Nat) BlockHistory:List),
				K:K, 
				LoopStack:List, 
				DeclStack:List)
			) ~> ?
			=> pushBlock
			~> addVariablesForBlock(TargetBlock:Nat, DeclStack:List)
			~> K:K
		</ k >
		< nestingDepth > Depth:Nat </ nestingDepth >
		< blockHistory > (. => ListItem(TargetBlock:Nat)) BlockHistory:List </ blockHistory >
		< loopStack > ? => LoopStack:List </ loopStack >
		if L:KLabel ==Bool 'processGoto
		orBool L:KLabel ==Bool 'processGotoDown
		: KSentence [metadata "structural"] .
		
	op addVariablesForBlock : Nat List -> K .
	
	--- skip variables from other blocks
	mb rule
		< k > addVariablesForBlock(TargetBlock:Nat, 
				((ListItem(frozenDeclaration(?, BlockNum:Nat, ?)) => .) DeclStack:List)
			)
		...</ k >
		< blockHistory > ListItem(TargetBlock:Nat) ...</ blockHistory >
		if BlockNum:Nat =/=Bool TargetBlock:Nat
		: KSentence [metadata "structural"] .
		
	--- skip variables in the real history
	mb rule
		< k > addVariablesForBlock(TargetBlock:Nat,
				((ListItem(frozenDeclaration(?, TargetBlock:Nat, Decl:K)) => .) DeclStack:List)
			)
		...</ k >
		< localVariables > Vars:List </ localVariables >
		< blockHistory > ListItem(TargetBlock:Nat) ...</ blockHistory >
		if getIdOfDeclaration(Decl:K) in Vars:List
		: KSentence [metadata "structural"] .
		
	--- op stripInit : K -> K .
	
	    --- < k > ('stripInit).KProperLabel(('LocalDefinition).KProperLabel(('DefinitionLoc).KProperLabel(('DeclarationDefinition).KProperLabel(('InitNameGroup).KProperLabel(('Specifier).KProperLabel(('_::_).KHybridLab
--- el(('Int).KResultLabel(.List{K}))),,('_::_).KHybridLabel(('InitName).KProperLabel(('Name).KProperLabel(Id Identifier("x")(.List{K}),,('JustBase).KProperLabel(.List{K})),,('SingleInit).KHybridLabel(('tv).KResult
--- Label(kList("wklist_")(BaseValue 0(.List{K})),,BaseType int(.List{K}))))))),,('CabsLoc).KProperLabel(String "testBadGoto.prepre.gen"(.List{K}),,BaseValue 5(.List{K}),,BaseValue 130(.List{K}),,BaseValue 19(.List
--- {K})))))

	--- mb rule
		--- < k > stripInit(LocalDefinition(DefinitionLoc(DeclarationDefinition(Decl:K, Loc:K)))
		--- ...</ k >
		--- : KSentence [metadata "structural"] .
	
	op enableInits : -> K .
	mb rule
		< k > enableInits => (.).K ...</ k >
		< shouldInit > ? => true </ shouldInit >
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > (. => Decl:K ~> enableInits) ~> addVariablesForBlock(TargetBlock:Nat, 
				((ListItem(frozenDeclaration(?, TargetBlock:Nat, Decl:K)) => (.).List) ?)
			)
		...</ k >
		< localVariables > Vars:List </ localVariables >
		< blockHistory > ListItem(TargetBlock:Nat) ...</ blockHistory >
		< shouldInit > ? => false </ shouldInit >
		if notBool getIdOfDeclaration(Decl:K) in Vars:List
		: KSentence [metadata "structural"] .
	--- fixme this is wrong
	mb rule
		< k > addVariablesForBlock(?, (.).List) => (.).K ...</ k >
		: KSentence [metadata "structural"] .
		
	--- if we're at a less deep 
	--- mb rule
		--- < k > processGoto(gotoObject(TargetDepth:Nat, TargetNum:Nat, K:K, LoopStack:List, DeclStack:List)) 
			--- => processGotoFromHigherBlock((ListItem(frozenDeclaration(Depth:Nat, Num:Nat, Decl:K)) DeclStack:List), (ListItem(X:Id) Vars:List))
		--- ...</ k >
		--- < nestingDepth > ActualDepth:Nat </ nestingDepth >
		--- < currentBlock > ActualNum:Nat </ currentBlock >
		--- < loopStack > ? => LoopStack:List </ loopStack >
		--- < localVariables > Vars:List </ localVariables >
		--- if ActualDepth:Num <Nat TargetDepth
		--- : KSentence [metadata "structural"] .
	
	--- skip over variables that are in both the actual past and in the target's past
	--- mb rule
		--- < k > processGotoSameBlock((ListItem(frozenDeclaration(Depth:Nat, Num:Nat, Decl:K)) DeclStack:List), (ListItem(X:Id) Vars:List))
			--- => processGotoSameBlock(DeclStack:List, Vars:List)
		--- ...</ k >
		--- < nestingDepth > Depth:Nat </ nestingDepth >
		--- < blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		--- if getIdOfDeclaration(Decl:K) ==Bool X:Id
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > processGotoSameBlock((.).List, (.).List) => (.).K ...</ k >
		--- : KSentence [metadata "structural"] .
		
	op getIdOfDeclaration : K -> K .
	op getIdOfName : K -> K .
	eq getIdOfDeclaration(LocalDefinition(K:K)) = getIdOfDeclaration(K:K) .
	eq getIdOfDeclaration(DefinitionLoc(K:K, ?)) = getIdOfDeclaration(K:K) .
	eq getIdOfDeclaration(DeclarationDefinition(InitNameGroup(?, K:C))) = getIdOfName(K:C) .
	eq getIdOfName(InitName(K:K, ?)) = getIdOfName(K:K) .
	eq getIdOfName(SingleName(?, K:K)) = getIdOfName(K:K) .
	eq getIdOfName(Name(X:Id, ?)) = X:Id .
***(	('LocalDefinition).KProperLabel(('DefinitionLoc).KProperLabel(('DeclarationDefinition).KProperLabel(('InitNameGroup).KProperLabel(('Specifier).KProperLabel(('_::_).KHybridLabel(('Int).KResultLabel(.List{K}))),,('_::_).KHybridLabel(('InitName).KProperLabel(('Name).KProperLabel(Id Identifier("x")(.List{K}),,('JustBase).KProperLabel(.List{K})),,('SingleInit).KHybridLabel(('tv).KResultLabel(kList("wklist_")(BaseValue 5(.List{K})),,BaseType int(.List{K}))))))),,('CabsLoc).KProperLabel(String "simplestGoto.prepre.gen"(.List{K}),,BaseValue 2(.List{K}),,BaseValue 115(.List{K}),,BaseValue 13(.List{K}))))
***)
		
	--- op calculateGotoMap : Id K Map List K -> K . --- func name, body, variables, loop stack, tail
	
	op waitingOnGotoMap : -> K .
	mb rule 
		< k > calculateGotoMap(F:Id, K:K) => waitingOnGotoMap ...</ k >
		< gotoMap > M:Map => M:Map[Map((.).Map) / kpair(Tu:K, F:Id)] </ gotoMap >
		< currentFunction > ? => F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< calculateGotoMap >
			. => (< gotoCalculation >... < computation > K:K </ computation > ...</ gotoCalculation >)
		</ calculateGotoMap >
		: KSentence .
		
	mb rule
		(< gotoCalculation > < computation > (.).K </ computation > ...</ gotoCalculation >) => (.).Bag
		: KSentence [metadata "structural"] .


	mb rule
		< k > waitingOnGotoMap => (.).K ...</ k >
		< calculateGotoMap > (.).Bag </ calculateGotoMap >
		< currentFunction > ? => File-Scope </ currentFunction >
		: KSentence [metadata "structural"] .

	op endBlockForGoto : Nat -> K .
	mb rule 
		< computation > BlockStatement(Block:K)
			=> Block:K ~> popBlock
		...</ computation >
		< nestingDepthGoto > N:Nat => sNat(N:Nat) </ nestingDepthGoto >
		< blockHistoryGoto > ListItem(OldNum:Nat) ...</ blockHistoryGoto >
		: KSentence .
	mb rule
		< computation > Block(Num:Nat, ?, L:List{C}) => listToK(L:List{C}) ...</ computation > 
		< blockHistoryGoto > . => ListItem(Num:Nat) ...</ blockHistoryGoto >
		--- < declarationStack >... (.).List => ListItem((.).K) </ declarationStack >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > popBlock => (.).K ...</ computation >
		< nestingDepthGoto > sNat(N:Nat) => N:Nat </ nestingDepthGoto >
		< blockHistoryGoto > (?:ListItem => (.).List) ListItem(Num:Nat) ...</ blockHistoryGoto >
		: KSentence [metadata "structural"] .
		
	mb [StatementLoc]: rule
		< computation > StatementLoc(K:K, L:CabsLoc) => K:K ...</ computation >
		< currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		: KSentence .
	--- mb [DefinitionLoc]: rule
		--- < computation > DefinitionLoc(K:K, L:CabsLoc) => K:K ...</ computation >
		--- < currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		--- : KSentence .

	mb rule
		< computation > LocalDefinition(K:K) => (.).K ...</ computation >
		< declarationStack >... (.).List => ListItem(frozenDeclaration(Depth:Nat, BlockNum:Nat, LocalDefinition(K:K))) </ declarationStack >
		< nestingDepthGoto > Depth:Nat </ nestingDepthGoto >
		< blockHistoryGoto > ListItem(BlockNum:Nat) ...</ blockHistoryGoto >
		: KSentence [metadata "structural"] .
		
	mb rule 
		< computation > L:KLabel(Args:List{K}) => (.).K ...</ computation >
		if false
		orBool L:KLabel ==Bool 'Nop
		orBool L:KLabel ==Bool 'Computation
		orBool L:KLabel ==Bool 'Break
		orBool L:KLabel ==Bool 'Continue
		orBool L:KLabel ==Bool 'Return
		orBool L:KLabel ==Bool 'Goto
		orBool L:KLabel ==Bool 'CompGoto
		: KSentence [metadata "structural"] .
		
***(
	op Switch : K K -> PureStatement
	op Case : K K -> PureStatement
	op Default : K -> PureStatement
	op Label : Id K -> PureStatement
	
	op Sequence : K K -> PureStatement --- still don't know what this is
	
	--- gcc specific
	op CaseRange : K K K -> PureStatement
	op CompGoto : K -> PureStatement
	op TryExcept : K K K -> PureStatement
	op TryFinally : K K -> PureStatement	
***)


	--- c1x 6.8.5:4 Code jumped over is not executed. In particular, the controlling expression of a for or while statement is not evaluated before entering the loop body, nor is clause-1 of a for statement
	---- dowhile, while, and for are all basically the same here
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> For(E1:K, E2:K, E3:K, S:K) ~> (. => popLoop) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< blockHistoryGoto > ListItem(Num:Nat) ...</ blockHistoryGoto >
		< loopStackGoto > (. => ListItem(kpair(Num:Nat, (K:K ~> Tail:K)))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> For(E1:K, E2:K, E3:K, S:K) => (.).K) ~> popLoop ~> K:K </ computation >
		--- < computationTail > Tail:K </ computationTail >
		--- < loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> DoWhile(E:K, S:K) ~> (. => popLoop) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< blockHistoryGoto > ListItem(Num:Nat) ...</ blockHistoryGoto >
		< loopStackGoto > (. => ListItem(kpair(Num:Nat, (K:K ~> Tail:K)))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> DoWhile(E:K, S:K) => (.).K) ~> popLoop ~> K:K </ computation >
		--- < computationTail > Tail:K </ computationTail >
		--- < loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (. => S:K ~> loopMarked) ~> While(E:K, S:K) ~> (. => popLoop) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< blockHistoryGoto > ListItem(Num:Nat) ...</ blockHistoryGoto >
		< loopStackGoto > (. => ListItem(kpair(Num:Nat, (K:K ~> Tail:K)))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (loopMarked ~> While(E:K, S:K) => (.).K) ~> popLoop ~> K:K </ computation >
		--- < computationTail > Tail:K </ computationTail >
		--- < loopStackGoto > (ListItem((K:K ~> Tail:K)) => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (Switch(?, E:K, S:K) => S:K ~> popLoop) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< blockHistoryGoto > ListItem(Num:Nat) ...</ blockHistoryGoto >
		< loopStackGoto > (. => ListItem(kpair(Num:Nat, (K:K ~> Tail:K)))) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > popLoop => (.).K ...</ computation >
		< loopStackGoto > (?:ListItem => .) ...</ loopStackGoto >
		: KSentence [metadata "structural"] .
		
	mb rule
		< computation > (Label(Target:Id, S:K) => S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > LoopStack:List </ loopStackGoto >
		< declarationStack > DeclStack:List </ declarationStack >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map => M:Map[gotoObject(Depth:Nat, BlockHistory:List, (S:K ~> K:K ~> Tail:K), LoopStack:List, DeclStack:List) / Target:Id])) ...</ gotoMap >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< nestingDepthGoto > Depth:Nat </ nestingDepthGoto >
		< blockHistoryGoto > BlockHistory:List </ blockHistoryGoto >
		if notBool $hasMapping(M:Map, Target:Id)
		: KSentence [metadata "structural"] .	
		
	mb rule
		< gotoCalculation >
			< computation > (IfThenElse(?, S1:K, S2:K) => (.).K) ~> K:K </ computation >
			< computationTail > Tail:K </ computationTail >
			B:Bag
		</ gotoCalculation >
		(. =>
			< gotoCalculation > 
				< computation > S1:K </ computation > 
				< computationTail > Tail:K ~> K:K </ computationTail >
				B:Bag 
			</ gotoCalculation >
		)
		(. =>
			< gotoCalculation > 
				< computation > S2:K </ computation >
				< computationTail > Tail:K ~> K:K </ computationTail >
				B:Bag 
			</ gotoCalculation >
		)
		
		: KSentence [metadata "structural"] .
	
	mb rule
		< computation > (Case(SwitchNum:Nat, tv(I:Int, T:Type), S:K) => S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > LoopStack:List </ loopStackGoto >
		< declarationStack > DeclStack:List </ declarationStack >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map => M:Map[gotoObject(Depth:Nat, BlockHistory:List, (S:K ~> K:K ~> Tail:K), LoopStack:List, DeclStack:List) / genLabel(SwitchNum:Nat, tv(I:Int, T:Type))])) ...</ gotoMap >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< nestingDepthGoto > Depth:Nat </ nestingDepthGoto >
		< blockHistoryGoto > BlockHistory:List </ blockHistoryGoto >
		if notBool $hasMapping(M:Map, genLabel(SwitchNum:Nat, tv(I:Int, T:Type)))
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< computation > (Default(SwitchNum:Nat, S:K) => S:K) ~> K:K </ computation >
		< computationTail > Tail:K </ computationTail >
		< loopStackGoto > LoopStack:List </ loopStackGoto >
		< declarationStack > DeclStack:List </ declarationStack >
		< gotoMap >... kpair(Tu:K, F:Id) |-> Map((M:Map => M:Map[gotoObject(Depth:Nat, BlockHistory:List, (S:K ~> K:K ~> Tail:K), LoopStack:List, DeclStack:List) / genLabel(SwitchNum:Nat, l('Default))])) ...</ gotoMap >
		< currentFunction > F:Id </ currentFunction >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< nestingDepthGoto > Depth:Nat </ nestingDepthGoto >
		< blockHistoryGoto > BlockHistory:List </ blockHistoryGoto >
		if notBool $hasMapping(M:Map, genLabel(SwitchNum:Nat, l('Default)))
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-RETURN is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb [erase-loc]: rule
		< k > deleteLoc(sym(Block:Nat) +Nat ?) => (.).K ...</ k >
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .
	
	mb [return-clean-local]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> Return(?) ...</ k >
		< localAddresses >... SetItem(Loc:Nat) => (.).Set ...</ localAddresses >	
		: KSentence [metadata "structural"] .
		
	mb [fetch-all-locals]: rule
		< k > Return(?) ...</ k >
		< localAddresses > (.).Set => Addresses:Set </ localAddresses >
		< blockStack > List(< stackFrame > 
			?
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
			=> (.).List
		...</ blockStack >
		: KSentence [metadata "structural"] .

	--- --- this is used for threads
	--- mb [return-nostack]: rule 
		--- < k > [L:KLabel(?) ~> ? => .K] </ k >
		--- < callStack > .List </ callStack >
		--- if L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- : KSentence [metadata "structural"] .

	--- this is used for returns with no return value as well, since we return "emptyValue", which will hopefully be cast to void
	mb [return]: rule 
		< control >
			< k > Return(V:Value) ~> ? 
				=> sequencePoint 
				~> cast(T:Type, V:Value) 
				~> K:K
			</ k >
			--- these cells get replaced by the ones in C:Bag, so we can delete them when we match them
			(< local >... < localAddresses > (.).Set </ localAddresses > ...</ local > => (.).Bag)
			--- i can't say the below line alone, but i want to :(
			--- (< localAddresses > (.).Set </ localAddresses > => (.).Bag)
			(< currentFunction > F:Id </ currentFunction > => (.).Bag)
			(< currentTranslationUnit > Tu:K </ currentTranslationUnit > => (.).Bag)
			(< blockStack > (.).List </ blockStack > => (.).Bag)
			(? => C:Bag)
		</ control >
		< gtypes >... Tu:K |-> Map((? (F:Id |-> functionType(T:Type, ?)))) ...</ gtypes >
		< callStack >
			List(
				< stackFrame >
					C:Bag
					< continuation > K:K </ continuation >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BLOCKS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	
	mb rule 
		< k > BlockStatement(Block:K)
			=> pushBlock ~> Block:K ~> popBlock
		...</ k >
		: KSentence .
	
	mb [push-block]: rule
		< k > pushBlock => (.).K ...</ k >
		--- < loopStack > ListItem(((. => popBlock) ~> ?)) ...</ loopStack >
		< local >
			C:Bag
			< localVariables > Vars:List => (.).List </ localVariables >
			< localAddresses > Addresses:Set => (.).Set </ localAddresses >
			< nestingDepth > N:Nat => sNat(N:Nat) </ nestingDepth >
		</ local >
		< blockStack > (.).List 
			=> List(< stackFrame > C:Bag 
			< nestingDepth > N:Nat </ nestingDepth > 
			< localVariables > Vars:List </ localVariables >
			< localAddresses > Addresses:Set </ localAddresses >
			</ stackFrame >)
		...</ blockStack >
		: KSentence [metadata "structural"] .
		
	mb [pop-block-free-memory]: rule
		< k > (. => deleteLoc(Loc:Nat)) ~> popBlock ...</ k >
		< localAddresses >... (SetItem(Loc:Nat) => (.).Set) ...</ localAddresses >
		: KSentence [metadata "structural"] .
		
	mb [pop-block]: rule
		< k > popBlock => (.).K ...</ k >
		< local > 
			(? => C:Bag)
			(< localAddresses > (.).Set </ localAddresses > => (.).Bag)
		</ local >
		--- < loopStack > ListItem(((popBlock => .) ~> ?)) ...</ loopStack > --- okay, this is awkward.
		< blockStack > List(< stackFrame > C:Bag </ stackFrame >) => (.).List ...</ blockStack >
		: KSentence [metadata "structural"] .
	
	
	mb [dissolve-block]: rule
		< k > Block(BlockNum:Nat, ?, Statements:List{C}) => listToK(Statements:List{C}) ...</ k >
		< blockHistory > (.).List => ListItem(BlockNum:Nat) ...</ blockHistory >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-STATEMENTS is
	including COMMON-SEMANTICS-STATEMENTS-INCLUDE .
	including COMMON-SEMANTICS-IF-THEN .
	including COMMON-SEMANTICS-FOR .
	including COMMON-SEMANTICS-WHILE .
	including COMMON-SEMANTICS-SWITCH .
	including COMMON-SEMANTICS-GOTO .
	including COMMON-SEMANTICS-RETURN .
	including COMMON-SEMANTICS-BLOCKS .
	including COMMON-SEMANTICS-DO-WHILE .
	
	mb rule Nop => . : KSentence [metadata "structural"] .

	--- skip labels
	mb [skip-label]: 
		rule < k > Label(L:Id, K:K) => K:K ...</ k >
		: KSentence [metadata "structural"] .

	--- dissolve expression statements that are finished evaluating
	mb [expression-statement]: rule < k > Computation(K:K) => K:K ~> discard ~> sequencePoint ...</ k > : KSentence [metadata "structural"] .
	
	mb [popLoop]: rule
		< k > popLoop ~> ? => K:K </ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		< loopStack > ListItem(kpair(Num:Nat, K:K)) => (.).List ...</ loopStack >
		--- < xmessages >... (. => "Poplooping in " +String toString(Num:Nat)) </ xmessages >
		: KSentence [metadata "structural"] .

	mb [popLoop]: rule
		< k > (. => popBlock) ~> popLoop ...</ k >
		< blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		< loopStack > ListItem(kpair(Num':Nat, ?)) ...</ loopStack >
		--- < xmessages >... (. => "Adding a popBlock to get rid of " +String toString(Num:Nat) +String ".  Looking for " +String toString(Num':Nat)) </ xmessages >
		if Num':Nat =/=Bool Num:Nat
		: KSentence [metadata "structural"] .
	
	--- mb [break]: rule
		--- < k > Break ~> ? => K:K </ k >
		--- --- < loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		--- < blockHistory > ListItem(Num:Nat) ...</ blockHistory >
		--- < loopStack > ListItem(kpair(Num:Nat, K:K)) => (.).List ...</ loopStack >
		--- : KSentence [metadata "computational rule"] . --- nondet
	mb [break]: rule
		< k > Break => popLoop ...</ k >
		--- < xmessages >... (. => "Break encountered, turning into popLoop") </ xmessages >
		: KSentence [metadata "structural"] .
		
	--- mb [break]: rule
		--- < k > Break ~> ? => K:K </ k >
		--- < loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		--- : KSentence [metadata "computational rule"] . --- nondet
	
	mb [continue]: rule
		< k > Continue ~> ((L:KLabel)(?) => .) ...</ k >
		if L:KLabel =/=Bool 'loopMarked
		andBool L:KLabel =/=Bool 'popBlock
		andBool L:KLabel =/=Bool 'pushBlock
		andBool L:KLabel =/=Bool 'popLoop
		: KSentence [metadata "structural"] . --- nondet
	mb [continue]: rule
		< k > Continue ~> popBlock 
			=> popBlock
			~> Continue
		...</ k >
		: KSentence [metadata "structural"] . --- nondet
	--- mb [continue-done]: rule
		--- < k > (Continue => Post:K ~> discard) ~> loopMarked ~> For(?, ?, Post:K, ?) ...</ k >
		--- : KSentence [metadata "structural"] . --- nondet
	--- mb [continue-done]: rule
		--- < k > (Continue => .) ~> loopMarked ~> L:KLabel(?) ...</ k >
		--- if L:KLabel =/=Bool 'For
		--- : KSentence [metadata "structural"] . --- nondet
		
	--- mb [continue]: rule
		--- < k > Continue ~> ((L:KLabel)(?) => .) ...</ k >
		--- if L:KLabel =/=Bool 'loopMarked
		--- : KSentence [metadata "structural"] .
	mb [continue-done]: rule
		< k > (Continue => Post:K ~> discard) ~> loopMarked ~> For(?, ?, Post:K, ?) ...</ k >
		: KSentence [metadata "structural"] . --- nondet
	mb [continue-done]: rule
		< k > (Continue => .) ~> loopMarked ~> L:KLabel(?) ...</ k >
		if L:KLabel =/=Bool 'For
		: KSentence [metadata "structural"] . --- nondet
		
endm
