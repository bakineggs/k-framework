in ../../../../k-prelude
in exp-type-inference-syntax
in ../exp-programs

mod EXP-TYPE-INFERENCE-SEMANTICS is including EXP-DESUGARED-SYNTAX + K .
--- We need type values/results when we define the type system
  sorts BasicType TypeVar Type UniversalType .
  subsort TypeVar < Type < Exp KResult .
  subsort Exp UniversalType List{TypeVar} < K .

  ops int bool : -> BasicType .
  subsort BasicType < Type .
  op t : Nat -> TypeVar .
  op _+Type_ : TypeVar Nat -> TypeVar .
  eq t(N) +Type M = t(N +Nat M) .
  op _->_ : Type Type -> Type .

  ops tenv eqns nextType : -> CellLabel .
  mb configuration < T >
                     < k > .K </ k >
                     < tenv > .Map </ tenv >
                     < eqns > .Set </ eqns >
                     < nextType > t(0) </ nextType >
                   </ T > : KSentence .

--- this should be defined on types, not on K's ...
  op _=_ : K K -> SetItem [prec 30 comm] .

  mb rule < k > [X => T] ...</ k > < tenv >... X |-> T ...</ tenv > : KSentence .
  mb rule < k > [L(T1,,T2) => int] ...</ k > < eqns >... [.Set => T1 = int T2 = int] ...</ eqns > 
       if L ==Bool '_+_ orBool L ==Bool '_-_ orBool L ==Bool '_*_ orBool L ==Bool '_/_ orBool L ==Bool '_%_ : KSentence .
  mb rule < k > [- T => int] ...</ k > < eqns >... [.Set => T = int] ...</ eqns > : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > < eqns >... [.Set => T1 = int T2 = int] ...</ eqns > 
       if L ==Bool '_<_ orBool L ==Bool '_<=_ orBool L ==Bool '_>_ orBool L ==Bool '_>=_ orBool L ==Bool '_==_ orBool L ==Bool '_!=_ : KSentence .
  mb rule < k > [L(T1,,T2) => bool] ...</ k > < eqns >... [.Set => T1 = bool T2 = bool] ...</ eqns >
       if L ==Bool '_and_ orBool L ==Bool '_or_ : KSentence .
  mb rule < k > [not T => bool] ...</ k > < eqns >... [.Set => T = bool] ...</ eqns > : KSentence .

  op mkFunType : TypeVar -> K .
  mb rule < k > [lambda X . E => E ~> mkFunType(Tv) ~> tenv(TEnv)] ...</ k > < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule [T ~> mkFunType(Tv) => Tv -> T] : KSentence .
  mb rule < k > [T1 T2 => Tv] ...</ k > < eqns >... [.Set => T1 = (T2 -> Tv)] ...</ eqns > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .

  op _?=_ : Exp Type -> K [metadata "strict(1)"] .
  mb rule < k > [mu X . E => E ?= Tv] ...</ k > < tenv > [TEnv => TEnv[Tv / X]] </ tenv > < nextType > [Tv => Tv +Type 1] </ nextType > : KSentence .
  mb rule < k > [T1 ?= T2 => .K] ...</ k > < eqns >... [.Set => T1 = T2] ...</ eqns > : KSentence .

  op let : TypeVar Id Exp -> K .
  op forall_._ : List{TypeVar} Type -> UniversalType .
  mb rule < k > [let X = E in E' => E ~> let(Tv,X,E')] ...</ k > < nextType > Tv </ nextType > : KSentence .
  mb rule < k > [T ~> let(Tv,X,E') => E' ~> tenv(TEnv)] ...</ k > < tenv > [TEnv => TEnv[forall newVars(T,Tv) . T / X]] </ tenv > : KSentence .
  mb rule < k > [X => T[| Tvl | from Tv / Tvl]] ...</ k > < tenv >... X |-> forall Tvl . T ...</ tenv >
          < nextType > [Tv => Tv +Type | Tvl |] </ nextType > : KSentence .

  mb rule < k > [if T then T1 else T2 => T1] ...</ k > < eqns >... [.Set => T = bool T1 = T2] ...</ eqns > : KSentence .

---
  var T T1 T2 : Type .  var Tv Tv' Tv1 Tv2 Tv1' Tv2' : TypeVar .  var L : KLabel .  var N M : Nat .  var X : Id .  var E E' : Exp .  var TEnv : Map .  var Eqns : Set .
  var BT : BasicType .  var Tvl Tvl' Tvl1 Tvl2 Tvl1' Tvl2' : List{TypeVar} .
--- type environment recovery
  op tenv : Map -> K .
  mb rule < k > T ~> [tenv(TEnv) => .K] ...</ k > < tenv > [? => TEnv] </ tenv > : KSentence [metadata "structural"] .

--- newVars should take a Type as first argument ...
  op newVars : K TypeVar -> List{TypeVar} .
  eq newVars(BT,Tv) = .List{TypeVar} .
  eq newVars(t(N),t(M)) = if N >=Nat M then t(N) else .List{TypeVar} fi .
  eq newVars((T1 -> T2), Tv) = newVars(T1,Tv),newVars(T2,Tv) .
  eq Tv,Tvl,Tv = Tv,Tvl .

  op |_| : List{TypeVar} -> Nat [strat(1 0)] .
  eq | Tv,Tvl | = 1 + | Tvl | .
  eq | .List{TypeVar} | = 0 .

  op _from_ : Nat TypeVar -> List{TypeVar} .
  eq 0 from Tv = .List{TypeVar} .
  eq (sNat N) from t(M) = t(M),(N from t(sNat M)) .

--- to be defined ...
  op _[_] : Set Type -> Type .

  op _[_/_] : Type List{TypeVar} List{TypeVar} -> Type [prec 2] .
  eq T[Tv1,Tv2,Tvl / Tv1',Tv2',Tvl'] = T[Tv1 / Tv1'][Tv2,Tvl / Tv2',Tvl'] .
  eq BT[Tv / Tv'] = BT .
  eq Tv1[Tv / Tv'] = if Tv ==Bool Tv then Tv' else Tv1 fi .
  eq (T1 -> T2)[Tv / Tv'] = T1[Tv / Tv'] -> T2[Tv / Tv'] .

--- List{TypeVar}
  sort List{TypeVar} .
  subsort TypeVar < List{TypeVar} .
  op .List{TypeVar} : -> List{TypeVar} .
  op _,_ : List{TypeVar} List{TypeVar} -> List{TypeVar} [prec 70 assoc id: .List{TypeVar}] .
endm

mod EXP-TYPE-INFERENCE is including EXP-TYPE-INFERENCE-SEMANTICS + EXP-PROGRAMS .
endm
