mod EXP-PROGRAMS is including EXP-SYNTAX .
  ops a b c d e f g h i j k l m n o p q r s u v w x y z : -> Id .
  ops p1 p2 p3 p4 p5 p6 p7 p8 p9 p9 p9 p10 p11 p12 : -> Exp .
  ops f00 f01 f02 f03 f04 f05 f06 f07 f08 f09 f10 f11 f12 f13 f14 : -> Id .

  eq p1 = (
    letrec f x = if x <= 0 then 1 else x * f(x - 1)
    in f (f 5)
  ) .

  eq p2 = (
    let x = 1
    in let f = lambda a . x
       in let x = 2
          in f 3
  ) .
  
  eq p3 = (
    let f = lambda x . x
    in f 1
  ) .

  eq p4 = (
    lambda x . (x x)
  ) .

  eq p5 = (
    let f = lambda x . x
    in if f true then f 3 else f 4 
  ) .

  eq p6 = (
    letrec f x = 3
    in f
  ) .
  
  eq p7 = (
    let f = let g = lambda x . x
            in let h = lambda x . lambda y . (g g)
	       in h
    in f
  ) .

  eq p8 = (
    let f = lambda x . x
    in f f
  ) .

  eq p9 = (
    let f00 = lambda x . lambda y . x in
      let f01 = lambda x . f00 (f00 x) in
        let f02 = lambda x . f01 (f01 x) in
          let f03 = lambda x . f02 (f02 x) in
            let f04 = lambda x . f03 (f03 x) in
              let f05 = lambda x . f04 (f04 x) in
                let f06 = lambda x . f05 (f05 x) in
                  let f07 = lambda x . f06 (f06 x) in
                    let f08 = lambda x . f07 (f07 x) in
                       f08
  ) .

  eq p10 = (
    letrec f x = if x < 1 then 0 else f(x - 1) + 1
    in f 100
  ) .

  eq p11 = (
    (lambda z . z z)(lambda x . lambda y . x y)
  ) .

--- this program tests that the fix point uses its own closure
  eq p12 = (
    let y = 0
    in letrec f x = if x == 0 then y else let y = 1 in f(x - 1)
       in f 1
  ) .

endm
