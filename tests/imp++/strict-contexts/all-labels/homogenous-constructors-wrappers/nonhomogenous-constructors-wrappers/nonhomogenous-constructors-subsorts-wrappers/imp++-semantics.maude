mod IMP++-SEMANTICS is
  including IMP++-SYNTAX .
  including CONFIG .
  including K-MAP-EXTRAS .
  op `[_;_`] : Nat Nat -> KList .
  op env : -> CellLabel .
  op k : -> CellLabel .
  op nextLoc : -> CellLabel .
  op output : -> CellLabel .
  op restore : Map -> K .
  op result : -> CellLabel .
  op store : -> CellLabel .
  op thread : -> CellLabel .
  op threads : -> CellLabel .
  eq <_>_</_>(T,__(Top:Set,<_>_</_>(output,Output:List,output),<_>_</_>(threads,.s,threads)),T)
    = <_>_</_>(result,Output:List,result) [metadata "keq"] .
  eq <_>_</_>(thread,__(Thread:Set,<_>_</_>(k,.k,k)),thread)
    = .s [metadata "keq"] .
  eq __(<_>_</_>(k,_~>_(restore(Env:Map),K:K),k),<_>_</_>(env,Env':Map,env))
    = __(<_>_</_>(k,_~>_(.k,K:K),k),<_>_</_>(env,Env:Map,env)) [metadata "keq"] .
  eq __(<_>_</_>(nextLoc,N:Nat,nextLoc),<_>_</_>(threads,__(AnyVar21:Set,<_>_</_>(thread,__(AnyVar22:Set,<_>_</_>(k,_~>_(vars_;_(Xl:KList,S:K),K:K),k),<_>_</_>(env,Env:Map,env)),thread)),threads),<_>_</_>(store,__(Store:Map,.m),store))
    = __(<_>_</_>(nextLoc,_+Int_(N:Nat,length_(Xl:KList)),nextLoc),<_>_</_>(threads,__(AnyVar21:Set,<_>_</_>(thread,__(AnyVar22:Set,<_>_</_>(k,_~>_(_~>_(S:K,restore(Env:Map)),K:K),k),<_>_</_>(env,_`[_<-_`](Env:Map,Xl:KList,`[_;_`](N:Nat,_+Int_(N:Nat,length_(Xl:KList)))),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(`[_;_`](N:Nat,_+Int_(N:Nat,length_(Xl:KList))),0)),store)) [metadata "keq"] .
  eq `[_;_`](N1:Nat,N2:Nat)
    = if_then_else_fi(_>=Int_(N1:Nat,N2:Nat),.kl,_`,_(N1:Nat,`[_;_`](sNat_(N1:Nat),N2:Nat))) [metadata "keq"] .
  rl skip
    => .k [metadata "krl"] .
  rl <_>_</_>(k,_~>_(halt,K:K),k)
    => <_>_</_>(k,.k,k) [metadata "krl"] .
  rl <_>_</_>(k,_~>_(while_do_(B:K,S:K),K:K),k)
    => <_>_</_>(k,_~>_(if_then_else_(B:K,_;_(S:K,while_do_(B:K,S:K)),skip),K:K),k) [metadata "krl"] .
  rl _+_(I1:Int,I2:Int)
    => _+Int_(I1:Int,I2:Int) [metadata "krl"] .
  rl _;_(S1:K,S2:K)
    => _~>_(S1:K,S2:K) [metadata "krl"] .
  rl _<=_(I1:Int,I2:Int)
    => _<=Int_(I1:Int,I2:Int) [metadata "krl"] .
  rl __(.s,<_>_</_>(thread,__(Thread:Set,<_>_</_>(k,_~>_(spawn_(S:K),K:K),k),<_>_</_>(env,Env:Map,env)),thread))
    => __(<_>_</_>(thread,__(<_>_</_>(k,S:K,k),<_>_</_>(env,Env:Map,env)),thread),<_>_</_>(thread,__(Thread:Set,<_>_</_>(k,_~>_(.k,K:K),k),<_>_</_>(env,Env:Map,env)),thread)) [metadata "krl"] .
  rl __(<_>_</_>(output,_`,_(Output:List,.l),output),<_>_</_>(threads,__(AnyVar7:Set,<_>_</_>(thread,__(AnyVar8:Set,<_>_</_>(k,_~>_(print_(I:Int),K:K),k)),thread)),threads))
    => __(<_>_</_>(output,_`,_(Output:List,l(I:Int)),output),<_>_</_>(threads,__(AnyVar7:Set,<_>_</_>(thread,__(AnyVar8:Set,<_>_</_>(k,_~>_(.k,K:K),k)),thread)),threads)) [metadata "krl"] .
  rl __(<_>_</_>(threads,__(AnyVar12:Set,<_>_</_>(thread,__(AnyVar13:Set,<_>_</_>(k,_~>_(X:VarId,K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,I:Int)),store))
    => __(<_>_</_>(threads,__(AnyVar12:Set,<_>_</_>(thread,__(AnyVar13:Set,<_>_</_>(k,_~>_(I:Int,K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,I:Int)),store)) [metadata "krl"] .
  rl __(<_>_</_>(threads,__(AnyVar13:Set,<_>_</_>(thread,__(AnyVar14:Set,<_>_</_>(k,_~>_(++_(X:VarId),K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,I:Int)),store))
    => __(<_>_</_>(threads,__(AnyVar13:Set,<_>_</_>(thread,__(AnyVar14:Set,<_>_</_>(k,_~>_(_+Int_(I:Int,1),K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,_+Int_(I:Int,1))),store)) [metadata "krl"] .
  rl __(<_>_</_>(threads,__(AnyVar13:Set,<_>_</_>(thread,__(AnyVar14:Set,<_>_</_>(k,_~>_(_:=_(X:VarId,I1:Int),K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,I2:Int)),store))
    => __(<_>_</_>(threads,__(AnyVar13:Set,<_>_</_>(thread,__(AnyVar14:Set,<_>_</_>(k,_~>_(.k,K:K),k),<_>_</_>(env,__(Env:Map,m(X:VarId,L:Int)),env)),thread)),threads),<_>_</_>(store,__(Store:Map,m(L:Int,I1:Int)),store)) [metadata "krl"] .
  rl _and_(false,B:K)
    => false [metadata "krl"] .
  rl _and_(true,B:K)
    => B:K [metadata "krl"] .
  rl if_then_else_(false,S1:K,S2:K)
    => S2:K [metadata "krl"] .
  rl if_then_else_(true,S1:K,S2:K)
    => S1:K [metadata "krl"] .
  rl not_(T:Bool)
    => notBool_(T:Bool) [metadata "krl"] .
  crl _/_(I1:Int,I2:Int)
    => _/Int_(I1:Int,I2:Int)
    if _=/=Bool_(I2:Int,0)= true [metadata "krl"] .
endm
