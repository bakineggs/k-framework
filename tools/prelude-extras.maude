***(
    This file is part of the K-Maude tool

    Copyright (C) 2009-2010 Traian Florin Șerbănuță

    This file is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
)

fmod NAT-LIST-EXTRAS is
  including NAT-LIST .
  including INT .
  including EXT-BOOL .
  sort IntList NeIntList .
  subsort NatList < IntList .
  subsort Int NeNatList < NeIntList < IntList .
  op __ : IntList IntList -> IntList [ditto] .
  op __ : NeIntList IntList -> NeIntList [ditto] .
  op __ : IntList NeIntList -> NeIntList [ditto] .

  vars M N : Int . vars Ints Ints' : IntList .

  op sortAbs : IntList ~> IntList .
  ceq sortAbs(Ints M N Ints') = sortAbs(Ints N M Ints') if abs(M) > abs(N) .
  eq sortAbs(Ints) = Ints [owise] .

  --- precondition first argument should be at most succesor of the second
  op seq : Nat Nat ~> NatList .
  eq seq(N, M) = if N > M then nil else N seq(s(N), M) fi .

  op _in_ : Int IntList -> Bool .
  eq N in M Ints = N == M or-else N in Ints .
  eq N in nil = false .
endfm

fmod STRING-EXTRAS is including MAP{String, String} + LIST{String} .
	including QID-LIST . including EXT-BOOL .
  op stripSpaces : String -> String .
  var S : String . var N : Nat .
  ceq stripSpaces(S) = stripSpaces(substr(S, 1, length(S))) 
   if " " = substr(S,0,1) .
  ceq stripSpaces(S) = stripSpaces(substr(S, 0, N)) 
   if s(N) := length(S) 
   /\ " " = substr(S,N,1) .
  eq stripSpaces(S) = S [owise] .

  op replace : String Char String Nat String -> String .
  var ToRepl : Char . var Repl Default : String . var Occ : NzNat .
  ceq replace(S, ToRepl, Repl, s(Occ), Default)
    = substr(S, 0, s(N)) 
    + replace(substr(S, s(N), length(S)), ToRepl, Repl, Occ, Default) 
   if N := find(S, ToRepl, 0) .
  ceq replace(S, ToRepl, Repl, 1, Default)
    = substr(S, 0, s(N)) + Repl + substr(S, s(s(N)), length(S)) 
   if s(N) := find(S, ToRepl, 0) .
  ceq replace(S, ToRepl, Repl, 1, Default)
    = Repl + substr(S, 1, length(S)) 
   if 0 := find(S, ToRepl, 0) .
   eq replace(S, ToRepl, Repl, N, Default) = S + Default [owise] .

  op insertBeforeOrAppend : String String String -> String .
  vars Source With What : String . vars L : Nat . var F : FindResult .
  ceq insertBeforeOrAppend(Source, What, With) 
    = substr(Source, 0, N) + With + substr(Source, N, L)
   if L := length(Source) 
   /\ F := rfind(Source, What, L) 
   /\ N := if F :: Nat then F else L fi .

--- replaces all occurences of the second string by the third in the first
   op replace : String String String -> String .
   ceq replace(Source, What, With) 
     = if F :: Nat then 
         substr(Source, 0, F) + With 
       + replace(substr(Source, F + length(What), length(Source)), What, With) 
       else Source fi 
    if F := find(Source, What, 0) .

  var StrM : Map{String,String} .
  op replaceAll : String Map{String,String} -> String .
  eq replaceAll(Source, ((What |-> With), StrM))
   = replaceAll(replace(Source, What, With), StrM) .
  
  eq replaceAll(Source, empty) = Source .
  
  op makeInfix : String Nat -> String .
  eq makeInfix(Source, 0) = Source .
  ceq makeInfix(Source, L) = Source 
   if N := find(Source, "_", 0) .
  eq makeInfix(Source, s(N)) = makeInfix(Source, N) + "_" [owise] .

  op tokenize : String -> QidList .
  ceq tokenize(S) 
    = qid(substr(S,0,N)) tokenize(stripSpaces(substr(S, N + 1, length(S))))
   if N := find(S, " ", 0) . 
  eq tokenize("") = nil .
  eq tokenize(S) = qid(S) [owise] .

  op latexify : Qid -> Qid .
  eq latexify(Q) = qid(latexify(string(Q))) .
  
  op latexify : String -> String .
  eq latexify(S) = replaceAll(S,("#" |-> "\\#", "%" |-> "\\%", "$" |-> "\\$", "&" |-> "\\&", ---("_" |-> "\\_",---)
 "'" |-> "", "`" |-> "", "{" |-> "\\{", "}" |-> "\\}", "\\" |-> "$\\backslash$", "~" |-> "\\verb$~$", "^" |-> "\\verb$^$")) .
 

  var Q : Qid . var QIL : QidList .
  op untokenize : QidList -> String .
  eq untokenize(nil) = "" .
  eq untokenize(Q QIL) = unqidify(string(Q)) + untokenize(QIL) .

  op unqidify : String -> String .
  eq unqidify("\\s") = " " .
  eq unqidify("\\t") = "  " .
  eq unqidify("\\n") = " " .
  eq unqidify("\\r") = "" .
  eq unqidify("\\g") = "" .
  eq unqidify("\\y") = "" .
  eq unqidify("\\b") = "" .
  eq unqidify("\\m") = "" .
  eq unqidify("\\c") = "" .
  eq unqidify("\\u") = "" .
  eq unqidify("\\!") = "" .
  eq unqidify("\\o") = "" .
  eq unqidify("`(") = "(" .
  eq unqidify("`)") = ")" .
  eq unqidify("`{") = "{" .
  eq unqidify("`}") = "}" .
  eq unqidify("`[") = "[" .
  eq unqidify("`]") = "]" .
  eq unqidify("`,") = "," .
  eq unqidify(S) = S [owise] .

 op all-letters : String -> Bool .
  eq all-letters(S) = S == "" or-else (isLetter(substr(S,0,1)) and-then all-letters(substr(S,1,length(S)))) .
  
  op isLetter : Char -> Bool .
  eq isLetter(C) = ("A" <= C and-then C <= "Z") or-else ("a" <= C and-then C <= "z") .


---  replace each left pair char in the map by its corresponding right pair char
---  in the given input string
  op replace : String Map{String,String} -> String . 
  var M : Map{String, String} . var C : Char .
  eq replace("", M) = "" .
  eq replace(S, M) 
   = replaceOne(substr(S,0,1), M) + replace(substr(S,1, length(S)), M) .
  op replaceOne : Char Map{String, String} -> String .
  eq replaceOne(C, ((C |-> S), M)) = S .
  eq replaceOne(C, M) = C [owise] .
  
  op allCaps : String -> String .
  eq allCaps(S) = replace(S, ("a" |-> "A", "b" |-> "B", "c" |-> "C", "d" |-> "D", "e" |-> "E", "f" |-> "F", "g" |-> "G", "h" |-> "H", "i" |-> "I", "j" |-> "J", "k" |-> "K", "l" |-> "K", "m" |-> "M", "n" |-> "N", "o" |-> "O", "p" |-> "P", "q" |-> "Q", "r" |-> "R", "s" |-> "S", "t" |-> "T", "u" |-> "U", "v" |-> "V", "w" |-> "W", "x" |-> "X", "y" |-> "Y", "z" |-> "Z")) .
endfm

fmod QID-EXTRAS is
  pr QID-LIST .

  op qidList2Qid : QidList -> Qid .

  var  Q QI : Qid .
  var  QIL : QidList .
  vars St St' : String .
  var  N : Nat .
  var  F : FindResult .

  eq qidList2Qid(('\s QIL)) = qid(" " + string(qidList2Qid(QIL))) .
  eq qidList2Qid((QI QIL)) 
    = qid(string(QI) + " " + string(qidList2Qid(QIL))) 
    [owise] .
  eq qidList2Qid(nil) = qid("") .

  op trimQidList : QidList -> QidList .
  eq trimQidList(' QIL) = trimQidList(QIL) .
  eq trimQidList(QI QIL) = QI trimQidList(QIL) [owise] .
  eq trimQidList(nil) = nil .

  op string2qidList : String -> QidList .
  op string2qidListAux : String -> QidList .
  
  eq string2qidList(St) = trimQidList(string2qidListAux(St)) .
  
  eq string2qidListAux("") = nil .
  ceq string2qidListAux(St)
    = if F == notFound
      then qid(substr(St, findNonSpace(St), length(St))) 
      else qid(substr(St, findNonSpace(St), F)) 
           if substr(St, findNonSpace(St) + F, 1) =/= " "
           then qid(substr(St, findNonSpace(St) + F, 1))
           else nil
           fi 
           string2qidListAux(substr(St, findNonSpace(St) + F + 1, length(St)))
      fi
    if F := myfind(substr(St, findNonSpace(St), length(St)), " (){}[],", 0)
    [owise] .
  
  op findNonSpace : String -> Nat .
  op findNonSpace : String Nat -> Nat .
  ---- returns the length of the string if not found
  eq findNonSpace(St) = findNonSpace(St, 0) .

  eq findNonSpace(St, N)  
    = if N < length(St)
      then if substr(St, N, 1) == " " 
           then findNonSpace(St, N + 1)  
           else N
           fi 
      else length(St)
      fi .
      
  op myfind : String String Nat -> FindResult .
  eq myfind(St, St', N)
    = if N < length(St) 
      then if find(St', substr(St, N, 1), 0) =/= notFound
           then N
           else myfind(St, St', N + 1)
           fi
      else notFound 
      fi .

  op genQids : Nat QidList -> QidList .
  eq genQids(0,QIL) = nil .
  eq genQids(s(N),QIL) = QIL genQids(N, QIL) .

  op upTo : QidList Qid ~> QidList .
  eq upTo(Q':Qid QIL,Q) = Q':Qid if Q == Q':Qid then nil else upTo(QIL,Q) fi .
endfm

fmod META-TERM-EXTRAS is
  including META-TERM .
  var V : Variable . var Trl' Trl Trl'' : TermList .  var Tr Tr' : Term .
  var C : Constant . var Nz : NzNat . var N : Nat .  var Q : Qid .
  var Subst : Substitution .  var T : Type . 

  op countTerms : TermList -> Nat .
  eq countTerms(empty) = 0 .
  eq countTerms((T:Term,TL:TermList)) = s(countTerms(TL:TermList)) .

  --- retrieves a list of all vars in the term, top-bottom, left-right
  op getVars : TermList -> TermList .
  eq getVars((V,Trl)) = V,getVars(Trl) .
  eq getVars((C,Trl)) = getVars(Trl) .
  eq getVars((Q[Trl],Trl')) = getVars((Trl, Trl')) .
  eq getVars(empty) = empty .

  --- eliminates term/variable duplicates (keeps only the leftmost occurrences
  op noDuplicates : TermList -> TermList .
  eq noDuplicates((Trl,Tr,Trl',Tr,Trl'')) = noDuplicates((Trl,Tr,Trl',Trl'')) .
  eq noDuplicates(Trl) = Trl [owise] .


  --- retrieves the nth var in a term. uses getVars
  op getVar : TermList NzNat ~> Term .
  eq getVar((V,Trl),1) = V .
  eq getVar((V,Trl),s(Nz)) = getVar(Trl,Nz) .
  eq getVar(Tr,Nz) = getVar(getVars(Tr), Nz) [owise] .


  --- retrieves the position of a variable in a term by its name, 
  --- uses getVars
  op getVarPos : TermList Qid ~> NzNat .
  eq getVarPos((V, Trl), Q) 
   = if Q == getName(V)  then 1 else s(getVarPos(Trl, Q)) fi .
  eq getVarPos(Tr,Q) = getVarPos(getVars(Tr), Q) [owise] .


  op _<-_ : Term Term -> Assignment [ditto] .

  op _[_] : TermList Substitution ~> Term .
  eq empty[Subst] = empty .
  eq (Tr,Trl)[(Tr <- Tr') ; Subst] = Tr', (Trl[(Tr <- Tr') ; Subst]) .
  eq (Q[Trl],Trl')[Subst] = Q[Trl[Subst]],(Trl'[Subst]) [owise] .
  eq (V,Trl)[Subst] = V,(Trl[Subst]) [owise] .
  eq (C,Trl)[Subst] = C,(Trl[Subst]) [owise] .

  op mkConstant : Qid Type -> Constant .
  eq mkConstant(Q, T) = qid(string(Q) + "." + string(T)) .

  op mkVariable : Qid Type -> Variable .
  eq mkVariable(Q, T) = qid(string(Q) + ":" + string(T)) .
endfm

fmod META-MODULE-EXTRAS is
  including META-MODULE .
  including NAT-LIST-EXTRAS .
  including META-TERM-EXTRAS .

  sort ViewExp .
  subsorts Sort < ViewExp < ModuleExpression NeParameterList .

  op mtViewExp : -> ViewExp .
  op _{_} : Sort ParameterList -> ViewExp [ctor prec 37].
  op _;;_ : ViewExp ViewExp -> ViewExp 
       [assoc id: mtViewExp] .                       *** view composition  _;_
      
  op moduleError : QidList -> [Module] .
  

  op nullHeader : -> Header .

  op setName : Module ModuleExpression -> Module .
  op setImports : Module ImportList -> Module .
  op setSorts : Module SortSet -> Module .
  op setSubsorts : Module SubsortDeclSet -> Module .
  op setOps : Module OpDeclSet -> Module .
  op setMbs : Module MembAxSet -> Module .
  op setEqs : Module EquationSet -> Module .
  op setRls : Module RuleSet -> Module .
  
  op addImports : ImportList Module -> Module .
  op addSorts : SortSet Module -> Module .
  op addSubsorts : [SubsortDeclSet] Module -> Module .
  op addOps : [OpDeclSet] Module -> Module .
  op addMbs : MembAxSet Module -> Module .
  op addEqs : EquationSet Module -> Module .
  op addRls : RuleSet Module -> Module .

  op addModule : Module Module -> Module .
  eq addModule(M, M')
   = addRls(getRls(M),addEqs(getEqs(M),addMbs(getMbs(M),addOps(getOps(M),addSubsorts(getSubsorts(M),addSorts(getSorts(M),addImports(getImports(M), M'))))))) .

  op removeSorts : SortSet SortSet -> SortSet .
  eq removeSorts(SS ; S, SS' ; S) = removeSorts(SS, SS' ; S) .
  eq removeSorts(SS, SS') = SS [owise print "remaining sorts: " SS] .

  op removeSorts : Module SortSet -> Module .
  eq removeSorts(M, SS) = setSorts(M, removeSorts(getSorts(M), SS)) .
 
  op removeSubsorts : SubsortDeclSet SubsortDeclSet -> SubsortDeclSet .
  eq removeSubsorts(SSDS SSD, SSDS' SSD) = removeSubsorts(SSDS, SSDS' SSD) .
  eq removeSubsorts(SSDS, SSDS') = SSDS [owise] . 

  op removeSubsorts : SubsortDeclSet SortSet -> SubsortDeclSet .
  eq removeSubsorts(SSDS (subsort S < S' .), S ; SS)
   = removeSubsorts(SSDS, S ; SS) .
  eq removeSubsorts(SSDS, SS) = SSDS [owise] .

  op removeSubsorts : Module SubsortDeclSet -> Module .
  eq removeSubsorts(M, SSDS) 
   = setSubsorts(M, removeSubsorts(getSubsorts(M),SSDS)) .
  
  op removeOps : OpDeclSet OpDeclSet -> OpDeclSet .
  eq removeOps(OPDS (op Q : Tl -> T [AS] .), OPDS' (op Q : Tl -> T [AS'] .))
   = removeOps(OPDS, OPDS' (op Q : Tl -> T [AS'] .)) .
  eq removeOps(OPDS, OPDS') = OPDS [owise] .

  op removeOps : Module OpDeclSet -> Module .
  eq removeOps(M, OPDS) = setOps(M, removeOps(getOps(M), OPDS)) .

  op removeImports : Module ImportList -> Module .
  eq removeImports(M, IL) = setImports(M, removeImports(getImports(M), IL)) .

  op removeImports : ImportList ImportList -> ImportList .
  eq removeImports(IL, nil) = IL .
  eq removeImports(IL I IL', I IL'') = removeImports(IL IL', I IL'') .
  eq removeImports(IL, I IL') = removeImports(IL, IL') [owise] .

  op getSubsorts : SubsortDeclSet SortSet -> SubsortDeclSet .
  eq getSubsorts(SSDS (subsort S < S' .), SS ; S') 
   = getSubsorts(SSDS, SS ; S')  (subsort S < S' .) .
  eq getSubsorts(SSDS, SS) = none [owise] .

  op getSupersorts : SubsortDeclSet SortSet -> SubsortDeclSet .
  eq getSupersorts(none, SS) = none .
  eq getSupersorts(SSDS, SS) = $getSupersorts(SSDS, SS, none) [owise] .

  op $getSupersorts : SubsortDeclSet SortSet SubsortDeclSet -> SubsortDeclSet .
  eq $getSupersorts(SSDS (subsort S < S' .), SS, SSDS') 
   = if S in SS then $getSupersorts(SSDS, SS, SSDS' (subsort S < S' .))
     else $getSupersorts(SSDS, SS, SSDS') fi .
  eq $getSupersorts(none, SS, SSDS) = SSDS .

  op getSupersorts : SubsortDeclSet -> SortSet .
  eq getSupersorts(SSDS (subsort S < S' .)) 
   = getSupersorts(SSDS) ; S' .
  eq getSupersorts(none) = none .

  op getSubsorts : SubsortDeclSet -> SortSet .
  eq getSubsorts(SSDS (subsort S < S' .)) 
   = getSubsorts(SSDS) ; S .
  eq getSubsorts(none) = none .

  op getOps : OpDeclSet SortSet -> OpDeclSet .
  eq getOps(OPDS (op Q : Tl -> S' [AS] .), SS ; S') 
   = getOps(OPDS, SS ; S') (op Q : Tl -> S' [AS] .)  .
  eq getOps(OPDS, SS) = none [owise] .

  op emptyFModule : -> FModule .
  op emptySModule : -> SModule .


  eq setName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MN') 
    = fth MN' is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN') 
    = th MN' is IL sorts SS . SSDS OPDS MAS EqS RlS endth .

  eq setName(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfth, MN) 
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN) 
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .


  eq setImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, IL')
    = mod H is IL' sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, IL')
    = th H is IL' sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS OPDS MAS EqS endfm .
  eq setImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS OPDS MAS EqS endfth .

  eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, OPDS')
    = mod H is IL sorts SS . SSDS OPDS' MAS EqS RlS endm .
  eq setOps(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, OPDS')
    = th MN is IL sorts SS . SSDS OPDS' MAS EqS RlS endth .
  eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, OPDS')
    = fmod H is IL sorts SS . SSDS OPDS' MAS EqS endfm .
  eq setOps(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, OPDS')
    = fth MN is IL sorts SS . SSDS OPDS' MAS EqS endfth .

  eq setSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SSDS')
    = mod H is IL sorts SS . SSDS' OPDS MAS EqS RlS endm . 
  eq setSubsorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SSDS')
    = th MN is IL sorts SS . SSDS' OPDS MAS EqS RlS endth .
  eq setSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SSDS')
    = fmod H is IL sorts SS . SSDS' OPDS MAS EqS endfm .
  eq setSubsorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SSDS')
    = fth MN is IL sorts SS . SSDS' OPDS MAS EqS endfth .

  eq setMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MAS')
    = mod H is IL sorts SS . SSDS OPDS MAS' EqS RlS endm .
  eq setMbs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MAS')
    = th MN is IL sorts SS . SSDS OPDS MAS' EqS RlS endth .
  eq setMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MAS')
    = fmod H is IL sorts SS . SSDS OPDS MAS' EqS endfm .
  eq setMbs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MAS')
    = fth MN is IL sorts SS . SSDS OPDS MAS' EqS endfth .

  eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, EqS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS' RlS endm .
  eq setEqs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, EqS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS' RlS endth .
  eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, EqS')
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS' endfm .
  eq setEqs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, EqS')
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS' endfth .

  op setRls : [Module] [RuleSet] -> [Module] .
  var U? : [Module] .

  eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, RlS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS' endm .
  eq setRls(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, RlS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS' endth .
  eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, RlS)
    = if RlS == none 
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setRls(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, RlS)
    = if RlS == none 
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      fi .

  eq setSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SS')
    = mod H is IL sorts SS' . SSDS OPDS MAS EqS RlS endm .
  eq setSorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SS')
    = th MN is IL sorts SS' . SSDS OPDS MAS EqS RlS endth .
  eq setSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SS')
    = fmod H is IL sorts SS' . SSDS OPDS MAS EqS endfm .
  eq setSorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SS')
    = fth MN is IL sorts SS' . SSDS OPDS MAS EqS endfth .

  eq addSorts(SS, U) = setSorts(U, (SS ; getSorts(U))) .
  eq addSubsorts(SSDS, U) = setSubsorts(U, (SSDS getSubsorts(U))) .
  eq addOps(OPDS, U) = setOps(U, (OPDS getOps(U))) .
  eq addMbs(MAS, U) = setMbs(U, (MAS getMbs(U))) .
  eq addEqs(EqS, U) = setEqs(U, (EqS getEqs(U))) .
  eq addRls(RlS, U) = setRls(U, (RlS getRls(U))) .
  eq addImports(IL, U) = setImports(U, (getImports(U) IL)) .

  eq emptyFModule 
    = fmod nullHeader is nil sorts none . none none none none endfm .
  eq emptySModule
    = mod nullHeader is nil sorts none . none none none none none endm . 

  op notMatchingSortsList : TypeList SortSet -> NatList .
  eq notMatchingSortsList(Tl,SS) = notMatchingSortsList(Tl, SS, 1) .
 
  op notMatchingSortsList : TypeList SortSet Nat -> NatList .
  eq notMatchingSortsList(nil,SS,N) = nil .
  eq notMatchingSortsList(S Tl, SS, N)
   = if S in SS then notMatchingSortsList(Tl,SS,s(N)) 
     else N notMatchingSortsList(Tl,SS,s(N)) fi .

  op arity : TypeList -> Nat .
  eq arity(nil) = 0 .
  eq arity(T Tl) = s(arity(Tl)) .

  op dup : Type Nat -> TypeList .
  eq dup(T, 0) = nil .
  eq dup(T, s(N)) = dup(T, N) T .

  op _in_ : Type TypeSet -> Bool .
  eq T in (T ; TS) = true .
  eq T in TS = false [owise] .

  op _in_ : SubsortDecl SubsortDeclSet -> Bool .
  eq SSD in (SSD SSDS) = true .
  eq SSD in SSDS = false [owise] .

  op _in_ : OpDecl OpDeclSet -> Bool .
  eq Op in (Op OPDS) = true .
  eq Op in OPDS = false [owise] .

  op intersection : TypeSet TypeSet -> TypeSet .
  op $intersect : TypeSet TypeSet TypeSet -> TypeSet .
  var A : TypeSet .

  eq intersection (TS, none) = none .
  eq intersection (TS, TS') = $intersect (TS, TS', none) [owise] .
  eq $intersect (none, TS', A) = A .
  eq $intersect (T ; TS, TS', A) = $intersect (TS, TS', if T in TS' then T ; A else A fi) .

  op removeSorts : SortSet SortSet -> SortSet .
  eq removeSorts(SS, none) = SS .
  eq removeSorts(SS, SS') = $removeSorts(SS, SS', none) [owise] .
  op $removeSorts : SortSet SortSet SortSet -> SortSet .
  eq $removeSorts(none, SS', A) = A .
  eq $removeSorts(S ; SS, SS', A) = $removeSorts(SS, SS', if S in SS' then A else S ; S fi) .


  op assoc : AttrSet -> Bool .
  eq assoc(AS assoc) = true .
  eq assoc(AS) = false [owise] .

  sort ModuleSet .
  subsort Module < ModuleSet .
  op __ : ModuleSet ModuleSet -> ModuleSet [assoc id: empty] .
  op empty : -> ModuleSet .


  op addSuffix : Qid ImportList -> ImportList .
  eq addSuffix(Q, IL (including Q' .))
   = addSuffix(Q, IL) (including qid(string(Q') + string(Q)) .) .
  eq addSuffix(Q, IL (protecting Q' .))
   = addSuffix(Q, IL) (protecting qid(string(Q') + string(Q)) .) .
  eq addSuffix(Q, IL (extending Q' .))
   = addSuffix(Q, IL) (extending qid(string(Q') + string(Q)) .) .
  eq addSuffix(Q, nil) = nil .

  op suffixImports : Qid Module ImportList ~> Module .
  eq suffixImports(Q, M, IL) 
   = addImports(addSuffix(Q, IL), removeImports(M, IL)) .

  op removeNaryAttrs : AttrSet -> AttrSet .
  eq removeNaryAttrs(Attr AS) = if naryAttr(Attr) then removeNaryAttrs(AS) else Attr removeNaryAttrs(AS) fi .
  eq removeNaryAttrs(none) = none .

  op naryAttr : Attr -> Bool .
  eq naryAttr(assoc) = true .  eq naryAttr(comm) = true .  eq naryAttr(idem) = true .  eq naryAttr(iter) = true .  eq naryAttr(id(Trm)) = true .  eq naryAttr(left-id(Trm)) = true .  eq naryAttr(right-id(Trm)) = true .  eq naryAttr(strat(NNl)) = true .  eq naryAttr(memo) = true .  eq naryAttr(prec(N)) = true .  eq naryAttr(gather(QIL)) = true .  eq naryAttr(format(QIL)) = true .  eq naryAttr(frozen(NNl)) = true .  eq naryAttr(poly(NNl)) = true .  eq naryAttr(special(NHl:NeHookList)) = true .
  eq naryAttr(Attr) = false [owise] .

  op getImportNames : ImportList ~> SortSet .
  eq getImportNames(I IL) = getImportName(I) ; getImportNames(IL) .
  eq getImportNames(nil) = none .

  op getImportName : Import ~> SortSet .
  eq getImportName(including ME .) = getImportName(ME) .
  eq getImportName(protecting ME .) = getImportName(ME) .
  eq getImportName(extending ME .) = getImportName(ME) .
  
  op getImportName : ModuleExpression ~> SortSet .
  eq getImportName(ME + ME') = getImportName(ME) ; getImportName(ME') .
  eq getImportName(Q) = Q .

  op getImportNames : Module ~> SortSet .
  eq getImportNames(M) = getImportNames(getImports(M)) .

  op getImportNameList : ImportList ~> QidList .
  eq getImportNameList(I IL) = getImportNameL(I)  getImportNameList(IL) .
  eq getImportNameList(nil) = nil .

  op getImportNameL : Import ~> QidList .
  eq getImportNameL(including ME .) = getImportNameL(ME) .
  eq getImportNameL(protecting ME .) = getImportNameL(ME) .
  eq getImportNameL(extending ME .) = getImportNameL(ME) .
  
  op getImportNameL : ModuleExpression ~> QidList .
  eq getImportNameL(ME + ME') = getImportNameL(ME)  getImportNameL(ME') .
  eq getImportNameL(Q) = Q .

  op getImportNameList : Module ~> QidList .
  eq getImportNameList(M) = getImportNameList(getImports(M)) .



  op generateImports : SortSet ~> ImportList .
  eq generateImports(none) = nil .
  eq generateImports(S ; SS) = (including S .) generateImports(SS) .


  op coGetOps : OpDeclSet SortSet ~> OpDeclSet .
  eq coGetOps(none, SS) = none .
  eq coGetOps(OPDS, SS) = $coGetOps(OPDS, SS, none) [owise] .

  op $coGetOps : OpDeclSet SortSet OpDeclSet ~> OpDeclSet .
  eq $coGetOps(none, SS, OPDS) = OPDS .
  eq $coGetOps(OPDS Op, SS, OPDS') = if taintedOp(Op, SS) then $coGetOps(OPDS, SS, Op OPDS') else $coGetOps(OPDS, SS, OPDS') fi .

  op taintedOp : OpDecl SortSet -> Bool .
  eq taintedOp((op Q : Tl -> T [AS] .), SS) = (intersection(list2set(Tl), SS) =/= none) .

  op list2set : TypeList -> TypeSet .
  eq list2set((T, Tl)) = T ; list2set(Tl) .
  eq list2set(nil) = none .

  op getPoly : AttrSet -> NatList .
  eq getPoly(poly(Nl) AS) = Nl .
  eq getPoly(AS) = nil [owise] .


  op getPolyConsts : Module ~> SortSet .
  eq getPolyConsts(M) = getPolyConsts(getOps(M)) .

  op getPolyConsts : OpDeclSet ~> SortSet .
  eq getPolyConsts(Op OPDS) = getPolyConsts(Op, OPDS) .
  eq getPolyConsts(none) = none .
  
  op getPolyConsts : OpDecl OpDeclSet ~> SortSet .
  eq getPolyConsts(op Q : nil -> T [poly(0) AS] ., OPDS) 
   = Q ; getPolyConsts(OPDS) .
  eq getPolyConsts(Op, OPDS) = getPolyConsts(OPDS) [owise] .
  
  op getTypes : Nat OpDecl ~> TypeList .
  eq getTypes(N, (op Q : Tl -> T [AS] .))
   = getTypes(N,Tl, arity(Tl), AS) .

  op getTypes : Nat TypeList Nat AttrSet ~> TypeList .
  eq getTypes(N,Tl,N,AS) = Tl .
  eq getTypes(N,T Tl,N',assoc AS) = dup(T,N) .


  op mergeTypes : TypeList TypeList Nat NatList -> TypeList .
  eq mergeTypes((T Tl), (T' Tl'), N, Nl)
   = if N in Nl then T else T' fi mergeTypes(Tl, Tl', s N, Nl) .
  eq mergeTypes(nil, nil, N, Nl) = nil .


  op tupleType : TypeList ~> Type .
  eq tupleType(Tl) = qid($tupleType(Tl)) .

  op $tupleType : TypeList ~> String .
  eq $tupleType(nil) = "" .
  eq $tupleType(T NTl) = string(T) + "*" + $tupleType(NTl) .
  eq $tupleType(T) = string(T) .


  op disambiguate : OpDecl -> OpDecl .
  eq disambiguate(op Q : Tl -> T [AS] .) 
   = (op qid(string(Q) + ":" + string(tupleType(Tl)) + "->" + string(T)) : Tl -> T [AS] .) .


  op labelled : MembAx -> Bool .
  op labelled : Equation -> Bool .
  op labelled : Rule -> Bool .
  eq labelled(mb Trm : T [AS label(Q)] .) = true .
  eq labelled(cmb Trm : T if Cond [AS label(Q)] .) = true .
  eq labelled(Mb) = false [owise] . 
  eq labelled(eq T1 = T2 [AS label(Q)] .) = true .
  eq labelled(ceq T1 = T2 if Cond [AS label(Q)] .) = true .
  eq labelled(Eq) = false [owise] . 
  eq labelled(rl T1 => T2 [AS label(Q)] .) = true .
  eq labelled(crl T1 => T2 if Cond [AS label(Q)] .) = true .
  eq labelled(Rl) = false [owise] . 

  op getLabel : MembAx ~> Qid .
  op getLabel : Equation ~> Qid .
  op getLabel : Rule ~> Qid .
  eq getLabel(mb Trm : T [AS label(Q)] .) = Q .
  eq getLabel(cmb Trm : T if Cond [AS label(Q)] .) = Q .
  eq getLabel(mb Trm : T [AS label(Q)] .) = Q .
  eq getLabel(cmb Trm : T if Cond [AS label(Q)] .) = Q .
  eq getLabel(eq T1 = T2 [AS label(Q)] .) = Q .
  eq getLabel(ceq T1 = T2 if Cond [AS label(Q)] .) = Q .
  eq getLabel(rl T1 => T2 [AS label(Q)] .) = Q .
  eq getLabel(crl T1 => T2 if Cond [AS label(Q)] .) = Q .

  op clearReductionAttrs : OpDeclSet ~> OpDeclSet .
 ceq clearReductionAttrs(OPDS op Q : Tl -> T [special(NHl:NeHookList) AS] .)
   = clearReductionAttrs(OPDS) (op Q : Tl -> T [clearReductionAttrs(AS)] .) 
  if Q == '_==Bool_ or-else Q == '_=/=Bool_ or-else Q == 'if_then_else_fi .
  eq clearReductionAttrs(OPDS op Q : Tl -> T [AS] .)
   = clearReductionAttrs(OPDS) (op Q : Tl -> T [clearReductionAttrs(AS)] .) 
  [owise] .
  eq clearReductionAttrs((none).OpDeclSet) = none .
  op clearReductionAttrs : AttrSet ~> AttrSet .
  eq clearReductionAttrs(strat(Nl:NeNatList) AS) = clearReductionAttrs(AS) .
  eq clearReductionAttrs(AS) = AS [owise] .


  op getAttrs : MembAx -> AttrSet .
  op getAttrs : OpDecl -> AttrSet .
  op getAttrs : Rule -> AttrSet .
  op getAttrs : Equation -> AttrSet .
  eq getAttrs(mb Trm : S [AS] .) = AS .
  eq getAttrs(cmb Trm : S if Cond [AS] .) = AS .
  eq getAttrs(op Q : Tl -> T [AS] .) = AS .
  eq getAttrs(eq T1 = T2 [AS] .) = AS .
  eq getAttrs(ceq T1 = T2 if Cond [AS] .) = AS .
  eq getAttrs(rl T1 => T2 [AS] .) = AS .
  eq getAttrs(crl T1 => T2 if Cond [AS] .) = AS .


  op genXVars : TypeList -> TermList .
  eq genXVars(nil) = empty .
  eq genXVars(T Tl) = mkVariable('X,T),genXVars(Tl) .

  op _#_ : TypeListSet TypeSet -> TypeListSet .
  eq (Tl ; TlS) # (T ; TS) = (Tl T) ; (Tl # TS) ; (TlS # (T ; TS)) .
  eq none # TS = none .
  eq TlS # none = none .

  var  M M' : Module .  var Trm T1 T2 : Term .  var Cond : Condition .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .  vars SSD : SubsortDecl .
  vars OPDS OPDS' : OpDeclSet .  var Op : OpDecl .
  vars MAS MAS' : MembAxSet .  var Mb : MembAx .
  vars EqS EqS' : EquationSet . var Eq : Equation .
  vars RlS RlS' : RuleSet . var Rl : Rule .
  vars SS SS' : SortSet .  var S S' : Sort .
  vars TS TS' : TypeSet .  var TlS : TypeListSet .
  vars IL IL' IL'' : ImportList .  var I : Import .
  vars U U' : Module .
  var  H MN MN' : Header .  vars ME ME' : ModuleExpression .
  vars PDL PDL' : ParameterDeclList .
  var QIL : QidList .  var Q Q' : Qid . 
  var Tl Tl' : TypeList .  var NTl : NeTypeList .  var T T' : Type . 
  var AS AS' : AttrSet .  var Attr : Attr .
  var NNl : NeNatList . var Nl : NatList . var N N' : Nat .
endfm

fmod METADATA-EXTRAS is
  including META-MODULE .
  var S S' : String .  var AS : AttrSet .
  eq metadata(S) metadata(S') = metadata(S + " " + S') .

  op metadataString : AttrSet -> String .
  eq metadataString(AS metadata(S)) = S .
  eq metadataString(AS) = "" [owise] .
endfm

fmod META-LEVEL-EXTRAS is
  including META-LEVEL .
  including META-MODULE-EXTRAS .
  including NAT-LIST-EXTRAS .

  var M M' : Module . var T T' T'' : Type . var K : Kind . var Tl Tl' : TypeList .
  var OPDS OPDS' : OpDeclSet .  var Op Op' : OpDecl .
  var AS AS' : AttrSet . var Q Q' : Qid .  var Ct : Constant .
  var Trm Trm' : Term . var Trms : TermList .  var Nl : NatList .
  var S S' : Sort  . var SS SS' : SortSet . var NeSS : NeSortSet .
  var N N' : Nat .  var IL : ImportList .  var MS : ModuleSet .
  var QIL : QidList .

  op maximalAritySet : Module Term ~> TypeListSet .
  eq maximalAritySet(M, Q[Trms])
   = maximalAritySetAux(M, Q, leastSorts(M, Trms), leastSort(M, Q[Trms])) .
  eq maximalAritySet(M, Trm) = none [owise] .

  op maximalAritySetAux : Module Qid TypeList TypeSet ~> TypeListSet .
  eq maximalAritySetAux(M, Q, Tl, S) = maximalAritySet(M, Q, Tl, S) .
  eq maximalAritySetAux(M, Q, Tl, K) 
   = maximalAritySetAux(M, Q, Tl, maximalSorts(M, K)) [owise] .
  eq maximalAritySetAux(M, Q, Tl, S ; NeSS)
   = maximalAritySet(M, Q, Tl, S) ; maximalAritySetAux(M, Q, Tl, NeSS) .
  eq maximalAritySet(M, Q, Tl, S)  = none [owise] .


  op leastSorts : Module TermList ~> TypeList .
  eq leastSorts(M,empty) = nil .
  eq leastSorts(M, (Trm, Trms)) = leastSort(M,Trm)  leastSorts(M, Trms) .

  op sortsLeq : Module TypeList TypeList Nat NatList ~> Bool .
  eq sortsLeq(M, (T' Tl'), (T Tl), N, Nl) 
   = (N in Nl or-else T == T' or-else sortLeq(M, T', T)) 
     and-then sortsLeq(M, Tl', Tl, s N, Nl) .
  eq sortsLeq(M, nil, nil, N, Nl) = true .
  
  op sortsLeq : Module TypeList TypeList ~> Bool .
--- assuming Universal means Polymorfic
---  eq sortsLeq(M, T' Tl', ('Universal Tl))
---   = sortsLeq(M, Tl', Tl) .
  eq sortsLeq(M, (T Tl'), (T Tl)) 
   = sortsLeq(M, Tl', Tl) .
---  [owise] .
  eq sortsLeq(M, (T' Tl'), (T Tl)) 
   = sortLeq(M, T', T) and-then sortsLeq(M, Tl', Tl) 
  [owise] .
  eq sortsLeq(M, nil,nil) = true .

  op findOp : Module OpDeclSet Qid TypeList Type ~> OpDecl .
  eq findOp(M, OPDS, Q, nil, 'FiniteFloat)
   =  (op Q : nil -> 'FiniteFloat [none] .) .
  eq findOp(M, OPDS, Q, nil, 'String)
   =  (op Q : nil -> 'String [none] .) .
  eq findOp(M, OPDS, Q, nil, 'Char)
   =  (op Q : nil -> 'Char [none] .) .
  eq findOp(M, OPDS, '_==Bool_, T T', T'')
   =  (op '_==Bool_ : dup(lubSorts(M,T,T'),2) -> 'Bool [none] .) .
  eq findOp(M, OPDS, '_=/=Bool_, T T', T'')
   =  (op '_=/=Bool_ : dup(lubSorts(M,T,T'),2) -> 'Bool [none] .) [print "_=/=Bool_: " T "\/" T' ] .
 ceq findOp(M, OPDS (op 'sNat_ : Tl' -> T' [AS] .), Q, Tl, T)
   =  (op 'sNat_ : Tl' -> T' [AS] .)
  if substr(string(Q), 0, length("sNat_^")) = "sNat_^" .
 ceq findOp(M, OPDS (op Q : T' T' -> T' [AS assoc] .), Q, Tl, S)
   = (op Q : T' T' -> T' [AS assoc] .) 
  if sortLeq(M,S,T') and-then sortsLeq(M,Tl, dup(T',arity(Tl))) .
 ceq findOp(M, OPDS (op Q : T' T' -> T' [AS assoc] .), Q, Tl, T)
   = (op Q : T' T' -> T' [AS assoc] .) 
  if sameKind(M,T,T') and-then sortsLeq(M,Tl, dup(T',arity(Tl))) [owise] .
 ceq findOp(M, OPDS (op Q : Tl' -> T' [AS] .), Q, Tl, T)
   = (op Q : mergeTypes(Tl, Tl', 1, getPoly(AS)) -> mergeTypes(T, T', 0, getPoly(AS)) [AS] .)
  if sortsLeq(M, T' Tl, T Tl', 0, getPoly(AS)) [owise] .

  op getTopOp : Module Term ~> OpDecl .
  eq getTopOp(M, Q[Trms]) = (op Q : getTermKinds(M, Trms) -> getTermKind(M, Q[Trms]) [none] .) .
  eq getTopOp(M, Ct) = (op getName(Ct) : nil -> getType(Ct) [none] .) .

  op getTermKind : Module Term -> Type .
  eq getTermKind(M,Trm) = getKind(M,leastSort(M,Trm)) .

  op getTermKinds : Module TermList -> TypeList .
  eq getTermKinds(M,(Trm,Trms)) = getTermKind(M,Trm) getTermKinds(M,Trms) .
  eq getTermKinds(M,empty) = nil . 



  op matchTermSorts : Module TermList TypeList ~> Bool .
  eq matchTermSorts(M, Trms, Tl) = sortsLeq(M, leastSorts(M, Trms), Tl) .

  op greaterSorts : Module Sort -> SortSet .
  eq greaterSorts(M, S) = greaterSorts(M, S, lesserSorts(M, getKind(M, S))) .
  op greaterSorts : Module Sort SortSet -> SortSet .
  eq greaterSorts(M, S, S' ; SS)  
   = greaterSorts(M, S, SS) ; if sortLeq(M, S, S') then S' else none fi .
  eq greaterSorts(M, S, none) = none .

  op lubSorts : Module Type Type -> TypeSet .
  eq lubSorts(M, S, S') = minimalSort(M, intersection(greaterSorts(M, S), greaterSorts(M, S'))) .
  eq lubSorts(M, S, T) = T [owise] .
  eq lubSorts(M, T, S') = T [owise] .
 ceq lubSorts(M, T, T') = completeName(M,T) if sameKind(M, T, T') [owise] .

  op minimalSort : Module SortSet ~> SortSet .
  ceq minimalSort(M, S ; S' ; SS) = minimalSort(M, S' ; SS) if sortLeq(M, S',S) .
  eq minimalSort(M, SS) = SS [owise] .

  op lubSort : Module Term Term ~> Sort .
  eq lubSort(M, Trm, Trm') = lubSorts(M, leastSort(M, Trm), leastSort(M, Trm')) .

  op getSubsorts : Module SortSet -> SortSet .
  eq getSubsorts(M, SS) = getSubsorts(M, getSorts(M), SS) .
  
  op getSubsorts : Module SortSet SortSet -> SortSet .
  eq getSubsorts(M, S ; SS, SS') 
   = if sortLeq(M, S, SS') then S ; getSubsorts(M, SS, SS') 
     else getSubsorts(M, SS, SS') fi .
  eq getSubsorts(M, none, SS') = none .

  eq sortLeq(M, S, S' ; NeSS) = sortLeq(M, S, S') or-else sortLeq(M, S, NeSS) .
  eq sortLeq(M, S, none) = false .

  op upImports : ImportList -> ModuleSet .
  eq upImports(nil) = empty .
  eq upImports((including Q .) IL) = upModule(Q,true) upImports(IL) .
  eq upImports((protecting Q .) IL) = upModule(Q,true) upImports(IL) .
  eq upImports((extending Q .) IL) = upModule(Q,true) upImports(IL) .

  op getAllImportsBut : Qid SortSet ~> ModuleSet .
  eq getAllImportsBut(Q, SS) 
   = getAllImportsBut(Q, SS, empty) .

  op getAllImportsBut : QidList SortSet ModuleSet ~> ModuleSet .
  eq getAllImportsBut(nil, SS, MS) = MS .
  eq getAllImportsBut(Q QIL, SS', MS)
   = if Q in SS' then getAllImportsBut(QIL, SS', MS)
     else getAllImportsBut(upModule(Q, false), QIL, SS' ; Q, MS) fi .

  op getAllImportsBut : Module QidList SortSet ModuleSet ~> ModuleSet .
  eq getAllImportsBut(M, QIL, SS', MS) 
   = getAllImportsBut(QIL getImportNameList(M), SS', MS M) .

  op flatten : Module ~> Module .
  eq flatten(M) = flatten(setImports(M,nil), getAllImportsBut(getImportNameList(M),none, empty)) .

  op flatten : Module ModuleSet ~> Module .
  eq flatten(M, empty) = M .
  eq flatten(M, M' MS) = flatten(addModule(setImports(M',nil),M), MS) .

  op getMaximalSorts : Module SortSet -> SortSet .
  eq getMaximalSorts(M, none) = none .
  eq getMaximalSorts(M, S ; SS) = $maximalSorts(M, SS, S) [owise] .

  op $maximalSorts : Module SortSet SortSet -> SortSet .
  eq $maximalSorts(M, none, SS) = SS .
  eq $maximalSorts(M, S ; SS, SS')
   = $maximalSorts(M, SS, filterMaximal(M, S, SS')) .

  op filterMaximal : Module Sort SortSet ~> SortSet .
  eq filterMaximal(M, S, none) = S .
  eq filterMaximal(M, S, S' ; SS) 
   = if sortLeq(M, S, S') then S' ; SS 
     else if sortLeq(M, S', S) then filterMaximal(M, S, SS)
          else S' ; filterMaximal(M, S, SS) fi fi .

  op makeSubsorts : Module SortSet SortSet ~> SubsortDeclSet .
  eq makeSubsorts(M, none, SS) = none .
  eq makeSubsorts(M, S ; SS, SS') 
   = makeSubsorts(M, SS, SS') makeSubsort(M, S, SS') .

  op makeSubsort : Module Sort SortSet ~> SubsortDeclSet .
  eq makeSubsort(M, S, none) = none .
  eq makeSubsort(M, S, S ; SS) = makeSubsort(M, S, SS) .
  eq makeSubsort(M, S, S' ; SS) 
   = if S in getSorts(M) and-then S' in getSorts(M) and-then sortLeq(M, S, S') then (subsort S < S' .) makeSubsort(M, S, SS) else makeSubsort(M,S, SS) fi
  [owise] .

  op generateSubsorts : Module SortSet SortSet ~> SubsortDeclSet .
  eq generateSubsorts(M, none, SS) = none .
  eq generateSubsorts(M, S ; SS, SS') 
   = if S in getSorts(M) then generateSubsorts(M, SS, SS') generateSubsort(M, S, SS') 
     else generateSubsorts(M, SS, SS') fi .

  op generateSubsort : Module Sort SortSet ~> SubsortDeclSet .
  eq generateSubsort(M, S, none) = none .
  eq generateSubsort(M, S, S ; SS) = makeSubsort(M, S, SS) .
  eq generateSubsort(M, S, S' ; SS) 
   = if S' in getSorts(M) then (subsort S < S' .) generateSubsort(M, S, SS) else generateSubsort(M,S, SS) fi
  [owise] .

  op minimalOps : Module OpDeclSet ~> OpDeclSet .
  eq minimalOps(M, none) = none .
  eq minimalOps(M, Op) = Op .
  eq minimalOps(M, Op OPDS) = $minimalOps(M, Op, OPDS, none) [owise] .

  op $minimalOps : Module OpDecl OpDeclSet OpDeclSet ~> OpDeclSet .
  eq $minimalOps(M, Op, Op' OPDS, OPDS') 
   = $minimalOps(M, Op, Op', isGreater(M, Op, Op'), OPDS, OPDS') .
  eq $minimalOps(M, Op, none, OPDS') = Op minimalOps(M, OPDS') .

  op $minimalOps : Module OpDecl OpDecl Bool OpDeclSet OpDeclSet ~> OpDeclSet .
  eq $minimalOps(M, Op, Op', true, OPDS, OPDS')
   = $minimalOps(M, Op', OPDS, OPDS') .
  eq $minimalOps(M, Op, Op', false, OPDS, OPDS')
   = $minimalOps(M, Op, OPDS, OPDS') .
  eq $minimalOps(M, Op, Op', B:[Bool], OPDS, OPDS')
   = $minimalOps(M, Op, OPDS, Op' OPDS') [owise] .

  op isGreater : Module OpDecl OpDecl ~> Bool .
 ceq isGreater(M, op Q : Tl -> T [AS] ., op Q : Tl' -> T' [AS'] .)
   = true
  if sortsLeq(M, Tl' T', Tl T) .
 ceq isGreater(M, op Q : Tl -> T [AS] ., op Q : Tl' -> T' [AS'] .)
   = false
  if sortsLeq(M, Tl T, Tl' T') .

  op leastOp : Module OpDecl OpDeclSet ~> OpDecl .
  eq leastOp(M, Op, none) = Op .
  eq leastOp(M, Op, Op' OPDS) = leastOp(M, Op, Op', isGreater(M, Op, Op'), OPDS) .

  op leastOp : Module OpDecl OpDecl Bool OpDeclSet ~> OpDecl .
  eq leastOp(M, Op, Op', true, OPDS) = Op' .
  eq leastOp(M, Op, Op', B:[Bool], OPDS) = leastOp(M, Op, OPDS) [owise] .

  op relatedOps : Module OpDecl OpDeclSet ~> OpDeclSet .
  eq relatedOps(M, Op, none) = none .
  eq relatedOps(M, Op, Op' OPDS) = if isRelated(M, Op, Op') then Op' relatedOps(M, Op, OPDS) else relatedOps(M, Op, OPDS) fi .


  op isRelated : Module OpDecl OpDecl -> Bool .
  eq isRelated(M, op Q : Tl -> T [AS] ., op Q' : Tl' -> T' [AS'] .)
   = Q == Q' and-then sameKinds(M, T Tl, getPoly(AS), T Tl', getPoly(AS')) 
   [print Q Tl T AS "<->" Q' Tl' T' AS'] .

  op sameKinds : Module TypeList NatList TypeList NatList -> Bool .
  eq sameKinds(M, Tl, Nl, Tl', Nl') = sameKinds(M, 0, Tl, Nl, Tl', Nl') .
  op sameKinds : Module Nat TypeList NatList TypeList NatList -> Bool .
  eq sameKinds(M, N, nil, Nl, nil, Nl') = true .
  eq sameKinds(M, N, T Tl, Nl1 N Nl2, T' Tl', Nl') 
   = sameKinds(M, s N, Tl, Nl1 Nl2, Tl', Nl') .
  eq sameKinds(M, N, T' Tl', Nl', T Tl, Nl1 N Nl2) 
   = sameKinds(M, s N, Tl', Nl', Tl, Nl1 Nl2) .
  eq sameKinds(M, N, T Tl, Nl, T' Tl', Nl') 
   = sameKind(M, T, T') and-then sameKinds(M, s N, Tl, Nl, Tl', Nl') [owise] .

  var Nl1 Nl2 Nl' : NatList .
endfm

