%% Grammar for Simple
module Simple[Atom]
imports Common %% For Comments and whitespace
exports
context-free start-symbols
	Exported

context-free syntax
	
Language -> Exported {cons("Syntax")}
	
Exp -> Language
Stmts -> Language

Decl -> Sentence
Stmt -> Sentence
Sentence* -> Stmts {right}


%% Statements
"{" Stmts "}" -> Stmt {cons("Block")}
"return" Exp  ";" -> Stmt {cons("Return")}
"return" -> ID {reject}

Exp ";" -> Stmt {cons("ExpStmt")}
"while" Exp "do" Stmt -> Stmt {cons("While")}
"while" -> ID {reject}
"do" -> ID {reject}

"if" Exp "then" Stmt "else" Stmt -> Stmt {cons("IfThenElse")}
"if" Exp "then" Stmt -> Stmt {cons("IfThen")}
"if" -> ID {reject}
"then" -> ID {reject}
"else" -> ID {reject}

"for" ID "=" Exp "to" Exp "do" Stmt -> Stmt {cons("For")}
"for" -> ID {reject}
"to" -> ID {reject}
"do" -> ID {reject}

"write" "(" Exp ")" ";" -> Stmt {cons("Write")}
"write" -> ID {reject}

"try" Stmt "catch" "(" ID ")" Stmt -> Stmt {cons("TryCatch")}
"try" -> ID {reject}
"catch"-> ID {reject}

"throw" Exp ";" -> Stmt {cons("Throw")}
"throw" -> ID {reject}

"spawn" Stmt -> Stmt {cons("Spawn")}
"spawn" -> ID {reject}
"acquire" Exp ";" -> Stmt {cons("Acquire")}
"acquire" -> ID {reject}
"release" Exp ";" -> Stmt {cons("Release")}
"release" -> ID {reject}
"rendezvous" Exp ";" -> Stmt {cons("Rendezvous")}
"rendezvous" -> ID {reject}

"var" ListOfExp ";" -> Decl {cons("VarDecl")}
"var" -> ID {reject}


"function" ID "(" ListOfId ")" Stmt -> Decl {cons("FunDecl")}
"function" -> ID {reject}


INT -> Exp {cons("SyntaxInt"), avoid}
BOOL -> Exp {cons("SyntaxBool"), avoid}
ID -> Exp {cons("SyntaxId"), avoid}

"-" Exp -> Exp {cons("Negative")}

"sizeOf" "(" Exp ")" -> Exp {cons("Sizeof")}
"sizeOf" -> ID {reject}

"read" "(" ")" -> Exp {cons("Read")}
"read" -> ID {reject}

"(" Exp ")" -> Exp {bracket}

{ID ","}* -> ListOfId
{Exp ","}* -> ListOfExp


context-free priorities
{ 
	"++" Exp -> Exp {cons("PreIncrement")}
} > {
	Exp "[" ListOfExp "]" -> Exp {cons("Array")}
} > {
	Exp "(" ListOfExp ")" -> Exp {cons("Application")}
} > {	
	Exp "*" Exp -> Exp {left, cons("Mult")}
	Exp "/" Exp -> Exp {left, cons("Div")}
	Exp "%" Exp -> Exp {left, cons("Mod")}
} > {
	Exp "+" Exp -> Exp {left, cons("Add")}
	Exp "-" Exp -> Exp {left, cons("Sub")}
} > {
	Exp "<" Exp -> Exp {cons("LT")}
	Exp "<=" Exp -> Exp {cons("LTE")}
	Exp ">" Exp -> Exp {cons("GT")}
	Exp ">=" Exp -> Exp {cons("GTE")}
	Exp "==" Exp -> Exp {cons("Eq")}
	Exp "!=" Exp -> Exp {cons("Neq")}
} > {
	"not" Exp -> Exp {cons("Not")}
	"not" -> ID {reject}
} > {
	Exp "and" Exp -> Exp {left, cons("And")}
	"and" -> ID {reject}
	Exp "or" Exp -> Exp {left, cons("Or")}
	"or" -> ID {reject}
} > {
	Exp "=" Exp -> Exp {right, cons("Assign")}
}

lexical syntax


