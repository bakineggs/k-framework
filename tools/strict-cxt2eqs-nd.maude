mod STRICTCXT2EQS is
  including K-SORTS .
  including K-META-OPS .
  including STRICT-ATTRS .
  including K-STRICTNESS-OPS .
  including META-TERM-EXTRAS .
  including STRING-EXTRAS .
  including META-MODULE-EXTRAS .
  including META-K-MODULE .
  including META-K-CONTEXTS .
  including META-K-COOL .
  var T : Term . var V : Variable .  var Trl : TermList .  
  var Sort S : Sort .  var Ss : SortSet .
  var AS : AttrSet . var MAS : MembAxSet . var Mb : MembAx .
  var Eqs : EquationSet . var Rls : RuleSet . var Q : Qid .
  vars Type Type' : Type .  var OPDS : OpDeclSet . var KCS : KContextSplit .
  vars T1 T2 : Term . var Cond : TermList .
  sort MASEqsPair .


  op strictCxt2eqs : Qid Qid Module Module SortSet ~> Module .
  var Syntax StrictEqs : Qid . var M Flat : Module .

  eq strictCxt2eqs(Syntax,StrictEqs,M,Flat, Ss) = strictCxt2eqs(Syntax,StrictEqs,strictCxt2eqs(Flat, getMbs(M)), Ss) . --- [print "Syntax: " Syntax ", StrictEqs: " StrictEqs ", StrictCxt: " M] .

  op strictCxt2eqs : Qid Qid MASEqsPair SortSet ~> Module .
  eq strictCxt2eqs(Syntax, StrictEqs, {MAS,Eqs, Rls}, Ss) 
   = addOps(coolOps,setMbs(addRls(Rls, addEqs(defaultCoolEqs(Ss), addEqs(Eqs, addImports((including Syntax . including 'K-STRICTNESS .), setName(emptySModule, StrictEqs))))), MAS)) .


  op coolOps : -> OpDeclSet .
  eq coolOps 
   = (op 'cool : K -> K [none] .) 
     (op '_~>_ : KProper K -> KProper [prec(100) assoc id(nilK) ] .) .

  op defaultCoolEqs : SortSet -> EquationSet .
  eq defaultCoolEqs(S ; Ss)
   = (eq mkCell(cool(S), mkVariable('K,K)) 
       = mkCell(S, 'cool[mkVariable('K,K)]) 
      [metadata("super cooling start")] .)
     defaultCoolEqs(Ss) .
  eq defaultCoolEqs(none) 
   = (eq 'cool[mkVariable('zk,K)] = mkVariable('zk,K) 
      [owise metadata("super cooling end")] .) .

  op {_,_,_} : MembAxSet EquationSet RuleSet -> MASEqsPair [ctor] .

  op strictCxt2eqs : Module MembAxSet ~> MASEqsPair .
  eq strictCxt2eqs(M,MAS) = strictCxt2eqs(M, MAS, none, none) .
  op strictCxt2eqs : Module MembAxSet EquationSet RuleSet ~> MASEqsPair . 
 ceq strictCxt2eqs(M, Mb MAS, Eqs, Rls)
   = strictCxt2eq(M, MAS, Eqs, Rls, getContents(KCS), getAttrs(KCS), getCondition(KCS))
  if KCS := splitKContext(Mb) .
  eq strictCxt2eqs(M, MAS,Eqs, Rls) = {MAS,Eqs, Rls} [owise] . 

  op strictCxt2eq : Module MembAxSet EquationSet RuleSet Term AttrSet TermList ~> MASEqsPair .
  eq strictCxt2eq(M, MAS, Eqs, Rls, T, none, Cond)
   = strictCxt2eq(M, MAS, Eqs, Rls, T, kstrict(nil,klabel), Cond) .
  
  eq strictCxt2eq(M, MAS, Eqs, Rls, T, kstrict(nil,Q), Cond) 
   = strictCxt2eqs(M, MAS, Eqs coolingEqs(M, T, Q), Rls heatingRls(M, T, Q, Cond)) .

  op heatingRls : Module Term Qid TermList -> RuleSet .
  eq heatingRls(M, T, Q, Cond)
   = strictCxt2eqHeat(kWrap(Q, T[hole <- mkVariable('Kcxt,KProper)]), kWrap(Q, kra(mkVariable('Kcxt,KProper), freezeTerm(M, T))), Cond[hole <- mkVariable('Kcxt,KProper)]) .

  op coolingEqs : Module Term Qid -> EquationSet .
  eq coolingEqs(M, T, Q)
   =  (eq kWrap(Q, kra(mkVariable('Kcxt,KResult), freezeTerm(M, T)))
        = kWrap(Q, T[hole <- mkVariable('Kcxt,KResult)])
       [metadata("cooling")] .) 
      (eq 'cool[kra(kra(mkVariable('Kcxt,K), freezeTerm(M, T)),'Rest:K)]
        = 'cool[kra(T[hole <- 'cool[mkVariable('Kcxt,K)]],'Rest:K)]
       [metadata("super cooling")] .) .

  op strictCxt2eqHeat : Term Term TermList ~> Rule .
  eq strictCxt2eqHeat(T1,T2,empty)
   = (rl T1 => T2 [metadata("heating")] .) .
  eq strictCxt2eqHeat(T1,T2,T)
   = (crl T1 => T2 if T = trueCt [metadata("heating")] .) .

  op freezeTerm : Module Term -> Term .
  eq freezeTerm(M, T) = kApply(
   freezeLabel(untokenize(metaPrettyPrint(M,T, mixfix flat number rat))),
   freezeVariables(M, removeHole(noDuplicates(getVars(T))))) .

  op freezeVariables : Module TermList ~> TermList .
  op freezeVariable : Module Variable ~> Variable .
  eq freezeVariables(M, (V,Trl)) 
   = (freezeVariable(M, V),freezeVariables(M, Trl)) .
  eq freezeVariables(M, empty) = empty .

  eq freezeVariable(M, V) = freezeVariable(string(V),makeK(M,V, getType(V))) .

  op makeK : Module Variable Type ~> Term . 
  eq makeK(M, V, Type) = makeK(M, V, Type, sortLeq(M, Type, KList)) .

  op makeK : Module Variable Type Bool ~> Term . 
  eq makeK(M, V, Type, true) = V .
  eq makeK(M, V, Type, B:[Bool]) 
   = kApply(findWrapper(getOps(M), Type)[V],empty) .

  op findWrapper : OpDeclSet Type ~> Qid .
  eq findWrapper(OPDS op Q : Type -> Type' [AS metadata("builtin wrapper")] ., Type) = Q .

endm

