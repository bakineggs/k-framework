load prelude-extras
load meta-k
load metadata-parsing.maude
load printing

mod DECL-META-LATEX-PRINT is
  pr K-META-OPEN-CELLS .
  pr META-K-RULES .
  pr META-K-CONTEXTS .
  pr META-LEVEL .
  pr CONVERSION .
  pr NAT-LIST-EXTRAS .
  pr META-MODULE-EXTRAS .
  pr PARSE-METADATA .
  pr QID-EXTRAS .
  pr META-K-LATEX .

  var  St Pattern OpenPar ClosingPar : String .
  vars Left R N OpenPars ClosingPars : Nat .
  var Label : Qid .  var Contents : Term . var B : Multiplicity .

  ---- finds a pattern out of balanced parentheses 
  ---- findOut("S{P1, P2{P21, P22}, P3}", ",", "{", "}", 6) returns 18, not 12
  op findOut : String String String String Nat -> FindResult .
  op findOut : String String String String Nat Nat -> FindResult .

  eq findOut(St, Pattern, OpenPar, ClosingPar, N)
    = findOut(St, Pattern, OpenPar, ClosingPar, 0, N) .

  eq findOut(St, Pattern, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 and-then substr(St, N, length(Pattern)) == Pattern
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findOut(St, Pattern, OpenPar, ClosingPar, 
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findOut(St, Pattern, OpenPar, ClosingPar, 
                            sd(OpenPars, 1), N + 1)
                     else findOut(St, Pattern, OpenPar, ClosingPar, 
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the first closing unbalanced parenthesis 
  ---- findOut("P1, P2{P21, P22}, P3}", "{", "}", 6) returns 21, not 16
  op findClosing : String String String Nat -> FindResult .
  op findClosing : String String String Nat Nat -> FindResult .

  eq findClosing(St, OpenPar, ClosingPar, N)
    = findClosing(St, OpenPar, ClosingPar, 0, N) .

  eq findClosing(St, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 
              and-then substr(St, N, length(ClosingPar)) == ClosingPar
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findClosing(St, OpenPar, ClosingPar, 
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findClosing(St, OpenPar, ClosingPar, 
                            sd(OpenPars, 1), N + 1)
                     else findClosing(St, OpenPar, ClosingPar, 
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the last opening unbalanced parenthesis 
  ---- findOpening("S{P1, P2{P21, P22}, P3}", "{", "}", 21) returns 1, not 8
  op findOpening : String String String Nat -> FindResult .
  op findOpening : String String String Nat Nat -> FindResult .

  eq findOpening(St, OpenPar, ClosingPar, N)
    = findOpening(St, OpenPar, ClosingPar, 0, N) .

  eq findOpening(St, OpenPar, ClosingPar, ClosingPars, N)
    = if N == 0
      then notFound
      else if ClosingPars == 0 
              and-then substr(St, N, length(ClosingPar)) == OpenPar
           then N
           else if substr(St, N, length(OpenPar)) == ClosingPar
                then findOpening(St, OpenPar, ClosingPar, 
                       ClosingPars + 1, sd(N, 1))
                else if substr(St, N, length(ClosingPar)) == OpenPar
                     then findOpening(St, OpenPar, ClosingPar, 
                            sd(ClosingPars, 1), sd(N, 1))
                     else findOpening(St, OpenPar, ClosingPar, 
                            ClosingPars, sd(N, 1))
                     fi
                fi
           fi
      fi .


  op getSort : Kind -> Sort .
  eq getSort(K:Kind) 
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind), 
                      2, 
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind), 
                      2, 
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
      fi .



  op attrSet2QidList : AttrSet -> QidList .
  op hookList2QidList : HookList -> QidList .
  op termList2QidList : TermList -> QidList .
  op intList2QidList : IntList -> QidList .
  op typeList2QidList : TypeList -> QidList .

  eq attrSet2QidList(none) = nil .
  eq attrSet2QidList((assoc AtS)) = ('\attr '`{ 'assoc '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((comm AtS))  = ('\attr '`{ 'comm '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((idem AtS))  = ('\attr '`{ 'idem '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((iter AtS))  = ('\attr '`{ 'iter '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((id(T) AtS)) 
    = ('\idTerm '`{ termList2QidList(T) '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((right-id(T) AtS)) 
    = ('right-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((left-id(T) AtS))  
    = ('left-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((poly(NL) AtS))
    = ('poly '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((strat(NL) AtS))
    = ('strat '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((memo AtS))  = ('memo attrSet2QidList(AtS)) .
  eq attrSet2QidList((prec(N) AtS))  
    = (---('\prec '`{ intList2QidList(N) '`}---) attrSet2QidList(AtS)) .
  eq attrSet2QidList((gather(QIL) AtS)) 
    = (---('gather QIL---) attrSet2QidList(AtS)) .
  eq attrSet2QidList((format(QIL) AtS)) 
    = ('\format '`{ QIL '`} attrSet2QidList(AtS)) .
  eq attrSet2QidList((ctor AtS))  = ('ctor attrSet2QidList(AtS)) .
  eq attrSet2QidList((frozen(NL) AtS))
    = ('frozen '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((config AtS))  = ('config attrSet2QidList(AtS)) .
  eq attrSet2QidList((object AtS))  = ('object attrSet2QidList(AtS)) .
  eq attrSet2QidList((msg AtS))  = ('msg attrSet2QidList(AtS)) .
  eq attrSet2QidList((special(HkL) AtS))
    = ('special '`( hookList2QidList(HkL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((none).AttrSet) = nil .

  eq hookList2QidList((id-hook(QI, QIL) HkL))
    = ('id-hook QI '`, '`( QIL '`) hookList2QidList(HkL)) .
  eq hookList2QidList((op-hook(QI, QI', QIL, QI'') HkL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookList2QidList(HkL)) .
  eq hookList2QidList((term-hook(QI, T) HkL))
    = ('term-hook '`( QI '`, termList2QidList(T) '`) hookList2QidList(HkL)) .

  sort Printable Printables .
  subsort Printable < Printables .
 
  op empty : -> Printables .
  op __ : Printables Printables -> Printables [assoc id: empty] .  

  var P P1 P2 : Printable . var Prints : Printables .  var N1 N2 : Nat .

  op loc : Int Printable -> Printable .
  eq loc(-1, P) = P .
  ceq loc(N1,P1) loc(N2,P2) = loc(N2,P2) loc(N1,P1) if N2 < N1 .

  op op : OpDecl -> Printable .
  op mb : MembAx -> Printable .
  op eq : Equation -> Printable .
  op rl : Rule -> Printable .
  op ss : SubsortDecl -> Printable .

---(
  op subsorts : SubsortDeclSet -> Printables .
  eq subsorts(SSD SSDS) = ss(SSD) subsorts(SSDS) .
  eq subsorts(none) = empty .
  var SSD : SubsortDecl .  
---)
var Eq : Equation .  var Eqs : EquationSet .
  var Rl : Rule . var Rls : RuleSet .

  op ops : OpDeclSet -> Printables .
  eq ops(Op OPDS) = loc(getBeginningLocation(getLocation(Op)),op(Op)) ops(OPDS) .
  eq ops(none) = empty .


  op mbs : MembAxSet -> Printables .
  eq mbs(Mb MAS) = loc(getBeginningLocation(getLocation(Mb)),mb(Mb)) mbs(MAS) .
  eq mbs(none) = empty .

  op eqs : EquationSet -> Printables .
  eq eqs(Eq Eqs) = loc(getBeginningLocation(getLocation(Eq)),eq(Eq)) eqs(Eqs) .
  eq eqs(none) = empty .

  op rls : RuleSet -> Printables .
  eq rls(Rl Rls) = loc(getBeginningLocation(getLocation(Rl)),rl(Rl)) rls(Rls) .
  eq rls(none) = empty .


  op eMetaLatexPrint : Sort -> QidList .
---  op eMetaLatexPrint : SortSet -> QidList .
  op eMetaLatexPrint : TypeList -> QidList .
---  op eMetaLatexPrint : SubsortDeclSet -> QidList .
---  op eMetaLatexPrint : Module OpDeclSet -> QidList .
---  op eMetaLatexPrintVars : OpDeclSet -> QidList .
---  op eMetaLatexPrint : Module MembAxSet -> QidList .
---  op eMetaLatexPrint : Module EquationSet -> QidList .
---  op eMetaLatexPrint : Module RuleSet -> QidList .
  op eMetaLatexPrint : Module Condition -> QidList .
  op eMetaLatexPrint : Module Term -> QidList .
  op eMetaLatexPrint : Module Printables -> QidList .

  eq eMetaLatexPrint(U, T) =  printTerm(U,T) . 
  eq eMetaLatexPrint(U, (empty).Printables) = nil . 

  var NeTl : NeTermList .  var C : Constant . var Q : Qid . vars T1 T2 : Term .
  var V : Variable .
  op printTerm : Module Term -> QidList .
  op printTermL : Module NeTermList -> QidList .
  eq printTermL(U,(T,NeTl)) = printTerm(U,T) '`, printTermL(U,NeTl) .
  eq printTermL(U,T) = printTerm(U,T) .
  ops \constant`{_`} \variable`{_`} : QidList -> Term .
---(  ops \kprefix`{_`}`{_`} \ksuffix`{_`}`{_`} \kmiddle`{_`}`{_`} : Constant Term -> Term .
---)
  op \configCell`{_`}`{_`}`{_`} : Constant Term AttrSet -> Term .
  ops \kcell`{_`}`{_`}`{_`} : Term Term Ellipses -> Term .
  ops \reduce`{_`}`{_`} \ereduce`{_`}`{_`} : Term Term -> Term .
  op merge : QidList TermList -> Term .
  op splitMixFix : String -> QidList .
  op prefixOp : Qid Term -> Term .
  op latexOp : Qid Term -> Term .
  op genCommas : Nat -> QidList .
  eq genCommas(s(N)) = genQids(N, '`,) .
  op mixfix : Qid -> Bool .
  op latexCmd : Qid -> Bool .
  op \value{_} : Term -> Term .
  op \myquote{_} : String -> QidList .

  ceq printTerm(U,C) = \myquote{string(getName(C))} if getType(C) == 'String or getType(C) == 'Char  .
  
  eq printTerm(U,C) = \constant{getName(getOps(U),getName(C), getType(C))} [owise] .
  eq printTerm(U,V) = \variable{ getName(V) } .

  op getName : OpDeclSet Qid Type -> Qid .
  eq getName( (op Q : nil -> Ty [AS metadata("builtin wrapper")] .) OPDS, Q, Ty) = '_ .
  eq getName( (op Q : nil -> Ty [AS metadata(Str) ] .) OPDS, Q, Ty)
   = getName(Q, metadataParse(Str)) [owise] .
 ceq getName(OPDS, Q, Ty) 
   = getLabelName(OPDS, qid(substr(string(Q),1,length(string(Q))))) 
  if substr(string(Q),0,1) = "'" .
  eq getName(OPDS, Q, Ty) = Q [owise] .

  op getLabelName : OpDeclSet Qid -> Qid .
  eq getLabelName( (op Q : TyL -> Ty [AS metadata("builtin wrapper") ] .) OPDS, Q) = '_ .
  eq getLabelName( (op Q : TyL -> Ty [AS metadata(Str) ] .) OPDS, Q)
   = addParams(getName(Q, metadataParse(Str)),arity(TyL)) [owise] .
  eq getLabelName( (op Q : TyL -> Ty [AS] .) OPDS, Q)
   = addParams(getName(Q, none),arity(TyL)) [owise] .
  eq getLabelName(OPDS, Q) = Q [owise] .
   
  op addParams : Qid Nat -> Qid .
  eq addParams(Q, N) = if latexCmd(Q) then qidList2Qid('\ensuremath '`{ qid(string(Q)+ "NoSpace") genQids(N, '`{ '\_ '`}) '`}) else qid(replaceAll(string(Q),"_" |-> "\\_")) fi .

  var Q' : Qid . var  AS1 AS2 : AttrSet .
  op getName : Qid AttrSet -> Qid .
  eq getName(Q, AS1 klatex(AS2 krenameTo(Q') ) ) = Q' [print Q " renamed to " Q'].
  eq getName(Q, AS) = latexify(Q) [owise] .

---  eq printTerm(U,Q[NeTl]) 
---   = Q '`( printTermL(U, NeTl) '`) .
  ceq  printTerm(U,T)
    =  printTerm(U,\kcell{Label}{Contents}{AS[ellipses]})
    if {Label, Contents, AS} := splitKCell(T) .

  var Ellipses : Ellipses .

  ceq printTerm(U,Q[T1,T2]) = 
     printTerm(U,\reduce{T1}{T2}) 
   if Q = replaceS .
  ceq printTerm(U, Q['0.Zero]) = printTerm(U, qid(string(N,10) + ".Nat")) 
   if N := getNat(string(Q)) .
  ceq printTerm(U, '_`(_`)[Q,'_`,`,_[NeTl]]) = printTerm(U,Q'[NeTl])
   if substr(string(getName(Q)),0,1) = "'" 
   /\ Q' := qid(substr(string(getName(Q)),1,length(string(Q)))) .
---(
  ceq printTerm(U, '_`(_`)[Ct,T]) = printTerm(U,Ct)
   if sortLeq(U,getType(Ct),KLabel) /\ T = nilKList .
  ceq printTerm(U, '_`(_`)[V,T]) = printTerm(U,V)
   if sortLeq(U,getType(V),KLabel) /\ T = nilKList .
---)
  ceq printTerm(U, '_`(_`)[Q,T]) = printTerm(U,Q'[T])
   if substr(string(getName(Q)),0,1) = "'" 
   /\ Q' := qid(substr(string(getName(Q)),1,length(string(Q)))) [owise] .

  op getNat : String -> [Nat] .
  var Str : String .
  ceq getNat(Str) 
    = rat(substr(Str, length("sNat_^"), length(Str)), 10) 
   if substr(Str, 0, length("sNat_^")) =  "sNat_^" .
  eq getNat("sNat_") = 1 .
  
  eq printTerm(U, T)
    = printTerm1(U,T) [owise] . 

  var TyL' : TypeList .  var Ty' : Type .
  op getRenamedQid : Qid OpDeclSet -> [Qid] .
  eq getRenamedQid(Q, (op Q : TyL -> Ty [AS metadata("builtin wrapper") ] .) OPDS) = '_ .
  eq getRenamedQid(Q, (op Q : TyL -> Ty [AS metadata(Str) ] .) OPDS) = getName(Q,metadataParse(Str)) [owise print Q " -> " Str "?"] .
  eq getRenamedQid(Q, OPDS) = latexify(Q) [owise] . --- print Op:[OpDecl]] .
 
  op printTerm1 : Module Term -> QidList .

 ceq printTerm1(U, Q[Ct]) = tokenize(downTerm(Ct,"")) if Q == latexS .
 ceq printTerm1(U, '__[Tl1:TermList, Q[Ct], Tl2:TermList])
   = printTerm(U,merge(genQids(s countTerms(Tl1:TermList), '\somespace), Tl1:TermList))
     tokenize(downTerm(Ct,""))
     printTerm(U,merge(genQids(s countTerms(Tl2:TermList), '\somespace), Tl2:TermList))
  if Q == latexS .
 ceq printTerm1(U,Q[NeTl,T])
   = printTerm(U,Q[Q[NeTl],T])
  if mixfix(Q) /\ size(splitMixFix(string(Q))) = 3 /\ 1 < countTerms(NeTl) [owise print "normalizing"] .
  ceq printTerm1(U, F[NeTl]) 
   =  '`{ printTerm(U, if mixfix(Q) 
    then merge(splitMixFix(string(Q)), NeTl)
    else if latexCmd(Q) 
     then latexOp(Q, merge(genQids(s countTerms(NeTl), '), NeTl))
     else prefixOp(Q, merge('`( genCommas(countTerms(NeTl)) '`), NeTl))
    fi fi) '`} 
  if Q := getRenamedQid(F, relatedOps(U, getTopOp(U, F[NeTl]), getOps(U))) [owise] .
  eq printTerm(M, T:[Term]) = 'error 
     [owise print "error in Print Term for " T:[Term]] .
 
  op eMetaLatexPrint : Module AttrSet -> QidList .
  op eMetaLatexPrint : IntList -> QidList .
---  op eMetaLatexPrint : AttrDeclSet -> QidList .
  op eMetaLatexPrint : Module HookList -> QidList .

  vars QI QI' QI'' F L : Qid .
  var  QIL : QidList .
  var  M : Module .
  var  U : Module .
  vars SS : SortSet .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  Hk : Hook .
  var  HkL : HookList .
  var  I : Int .
  var  NL : IntList .
  vars T T' T'' T3 : Term .
  var  Cond : Condition .
  var  Knd : Kind .

---  ceq eMetaLatexPrint(VE) = viewExp2QidList(VE) if not VE :: TypeList .

  --- eq eMetaLatexPrint(Ty) = Ty .

  op \sort{_} : Sort -> QidList .
  eq eMetaLatexPrint(S) = \sort{S} .
---(
    = if getPars(S) == empty
      then S
      else getName(S) '`{ parameterList2QidList(getPars(S)) '`}
      fi .
---)
  eq eMetaLatexPrint(Knd) = '\kind '`{ eMetaLatexPrint(getSort(Knd)) '`} . 

  eq eMetaLatexPrint((S ; SS)) 
    = (eMetaLatexPrint(S) eMetaLatexPrint(SS))
    [owise] .
  eq eMetaLatexPrint((none).SortSet) = nil .

  var NeTyL : NeTypeList .
  eq eMetaLatexPrint(Ty NeTyL) 
    = eMetaLatexPrint(Ty) '\times eMetaLatexPrint(NeTyL) 
    [owise] .
  eq eMetaLatexPrint((nil).TypeList) = nil .

---  op \subsort{_}{_} : Sort Sort -> SubsortDecl [ctor] .
  op \terminal{_} : Qid -> QidList [ctor] .
  op \nterminal{_} : Type -> QidList [ctor] .
  op syntax : QidList QidList AttrSet -> Printable .
  op \cellLabel{_}{_} : Qid AttrSet -> OpDecl .
  eq op(op F : nil -> 'CellLabel [AS] .) = empty .
  eq op(op F : TyL -> Ty [ metadata("generated label") AS] .) = empty .
  eq op(op F : TyL -> Ty [ metadata(St) AS] .)
   = op(op F : TyL -> Ty [ metadataParse(St) AS] .) [owise] .

  eq metadata("builtin wrapper") = none .

  op subsort(_, _) : QidList QidList -> Printable .
  var Sort Sort' : Sort .
  eq ss(subsort Sort < Sort' .) = subsort(\nterminal{Sort}, \nterminal{Sort'}) .

 ceq op(op Q : TyL -> Ty [AS] .)
   = syntax(\nterminal{Ty},
      if latexCmd(F) then  F mergeTypes(genQids(s arity(TyL), '), TyL)
      else mergeTypes(splitMixFix(string(F)), TyL)
      fi, #Types(arity(TyL)) AS)
  if F := getName(Q, AS) 
 [owise] .
  op #Types : Nat -> Attr .

  op mergeTypes : QidList TypeList -> TypeList .
  var Op : OpDecl .
  op \algebraicOp{_}{_}{_}{_} : Qid TypeList  Type AttrSet -> OpDecl .

  op eMetaLatexPrint1 : Module AttrSet -> QidList .
  eq eMetaLatexPrint1(M,(none).AttrSet) = nil .
  eq eMetaLatexPrint1(M,AtS)
   =  '`[ eMetaLatexPrint(M,AtS) '`] .

  ops rule : String KRuleSplit -> Printable .
  ops mequation : String Term Term -> Printable .
  ops mrule : String Term Term -> Printable .
  ops cmrule : String Term Term Condition -> Printable .
  ops cmequation : String Term Term Condition -> Printable .
 
  op config : Term -> Printable .
  op latex : String -> Printable .
  op context : String KContextSplit -> Printable . 
  var AS : AttrSet .

  op getLabel : AttrSet -> String .
  eq getLabel( label(Q) AS) = string(Q) .
  eq getLabel(AS) = "\\!" [owise] .

  var KRS : KRuleSplit .  var KCS : KContextSplit . 
  var Mb : MembAx .  var MAS' : MembAxSet .
  eq mb(mb 'configuration_[T] : 'KSentence [AS] .) = config(T) .
  eq mb(mb 'latex_[T] : 'KSentence [AS] .) = latex(downTerm(T,"")) .
 ceq mb(Mb) = rule(getLabel(getAttrs(Mb)),KRS)
  if KRS := splitKRule(metadataParse(Mb)) .
 ceq mb(Mb) = context(getLabel(getAttrs(Mb)),KCS) 
  if KCS := splitKContext(metadataParse(Mb)) .

---(

  eq eMetaLatexPrint(M, mb(mb T : S [none] .) Prints)
    = ('\n 'mb eMetaLatexPrint(M, T) 
                   ': eMetaLatexPrint(S) '. 
       eMetaLatexPrint(M, Prints)) [owise] .
  eq eMetaLatexPrint(M, mb(mb T : S [AtS] .) Prints)
    = ('\n 'mb eMetaLatexPrint(M, T) 
                   ': eMetaLatexPrint(S) 
               '`[ eMetaLatexPrint(M, AtS) '`] '. 
       eMetaLatexPrint(M, Prints)) 
    [owise] .
  eq eMetaLatexPrint(M, mb(cmb T : S if Cond [none] .) Prints)
    = ('\n 'cmb eMetaLatexPrint(M, T) 
                   ': eMetaLatexPrint(S) 
       '\n 'if eMetaLatexPrint(M, Cond) '. 
       eMetaLatexPrint(M, Prints)) [owise] .
  eq eMetaLatexPrint(M, mb(cmb T : S if Cond [AtS] .) Prints)
    = ('\n 'cmb eMetaLatexPrint(M, T) 
                   ': eMetaLatexPrint(S) 
       '\n 'if eMetaLatexPrint(M, Cond) 
           '`[ eMetaLatexPrint(M, AtS) '`] '. 
       eMetaLatexPrint(M, Prints)) 
    [owise] .
---)

  eq loc(I,empty) = empty .
  eq eq(eq T = T' [metadata("simplify")] .) = empty .
  eq eq(eq T = T' [AtS] .) = mequation(getLabel(AtS),T,T') [owise] .
  eq eMetaLatexPrint(M, mequation(Str, T, T') Prints)
    = ('\n '\mequation '`{ qid(Str) '`} '`{ eMetaLatexPrint(M, T) 
       '`} '`{ eMetaLatexPrint(M, T') 
           '`} 
       eMetaLatexPrint(M, Prints)) 
    [owise] .
  eq eq(ceq T = T' if Cond [AtS] .) = cmequation(getLabel(AtS), T, T', Cond) .
  eq eMetaLatexPrint(M, cmequation(Str, T, T', Cond) Prints) 
    = ('\n '\cmequation '`{ qid(Str) '`} '`{ eMetaLatexPrint(M, T) 
        '`} '`{ eMetaLatexPrint(M, T') '`} 
        '`{ eMetaLatexPrint(M, Cond) '`} 
       eMetaLatexPrint(M, Prints))  .

  eq rl(rl T => T' [AtS] .) = mrule(getLabel(AtS), T, T') .
  eq  eMetaLatexPrint(M, mrule(Str, T, T') Prints) 
    = ('\n '\mrule '`{ qid(Str) '`} '`{ eMetaLatexPrint(M, T) 
        '`} '`{ eMetaLatexPrint(M, T') '`} 
       
       eMetaLatexPrint(M, Prints)) .
  eq rl(crl T => T' if Cond [AtS] .) =  cmrule(getLabel(AtS), T, T', Cond) .
  eq  eMetaLatexPrint(M, cmrule(Str, T, T', Cond) Prints) 
    = ('\n '\cmrule '`{ qid(Str) '`} '`{ eMetaLatexPrint(M, T) 
        '`} '`{ eMetaLatexPrint(M, T') '`} 
        '`{ eMetaLatexPrint(M, Cond) '`} 
       
       eMetaLatexPrint(M, Prints)) .

  var Ct : Constant .
  eq eMetaLatexPrint(M, T = 'true.Bool) 
   = printTerm(M, T) .
  eq eMetaLatexPrint(M, T = T') 
    = (printTerm(M, T) '= printTerm(M, T')) [owise] .
  eq eMetaLatexPrint(M, T : S) 
    = (printTerm(M, T) ': eMetaLatexPrint(S)) .
  eq eMetaLatexPrint(M, T := T') 
    = (printTerm(M, T) ':= printTerm(M, T')) .
  eq eMetaLatexPrint(M, T => T') 
    = (printTerm(M, T) '=> printTerm(M, T')) .

  eq eMetaLatexPrint(M, T = 'true.Bool /\ Cond)
    = (printTerm(M, T) 
      '$ '\ 'and '\ '$ eMetaLatexPrint(M, Cond)) [owise] .
  eq eMetaLatexPrint(M, T = T' /\ Cond)
    = (printTerm(M, T) '= printTerm(M, T') 
      '$ '\ 'and '\ '$ eMetaLatexPrint(M, Cond)) 
    [owise] .
  eq eMetaLatexPrint(M, T : S /\ Cond)
    = (printTerm(M, T) ': eMetaLatexPrint(S) 
      '/\ eMetaLatexPrint(M, Cond)) 
    [owise] .
  eq eMetaLatexPrint(M, T := T' /\ Cond)
    = (printTerm(M, T) ':= printTerm(M, T') 
      '/\ eMetaLatexPrint(M, Cond)) 
    [owise] .
  eq eMetaLatexPrint(M, T => T' /\ Cond)
    = (printTerm(M, T) '=> printTerm(M, T') 
      '/\ eMetaLatexPrint(M, Cond)) 
    [owise] .
  eq eMetaLatexPrint(M, (assoc AtS))  
    = ('assoc eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (comm AtS))   
    = ('comm eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (memo AtS))   
    = ('memo eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (idem AtS))   
    = ('idem eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (id(T) AtS))
    = ('id: eMetaLatexPrint(M, T) '\s eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (right-id(T) AtS))
    = ('right 'id: eMetaLatexPrint(M, T) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (left-id(T) AtS))
    = ('left 'id: eMetaLatexPrint(M, T) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (poly(NL) AtS))
    = ('poly '`( eMetaLatexPrint(NL) '`) 
       eMetaLatexPrint(M, AtS)) .

  eq eMetaLatexPrint(M, (karity(N) AtS))
    = ('arity eMetaLatexPrint(N)  
       eMetaLatexPrint(M, AtS)) .

---(
  eq eMetaLatexPrint(M, (vstrict(QIL) AtS))
    = ('strict '`( QIL '`) 
       eMetaLatexPrint(M, AtS)) .
---)
---  op \wrapping{_} : Qid -> QidList .
  op \renameTo{_} : Qid -> QidList .

---(
  eq eMetaLatexPrint(M, (kwrapping(Q) AtS))
    = (\wrapping{Q} 
       eMetaLatexPrint(M, AtS)) .
---)
  op eMetaLatexPrint : Module Nat AttrSet -> QidList .
  eq eMetaLatexPrint(M, N, (krenameTo(Q) AtS))
    = (\renameTo{getRenamedKOp(Q, N, getOps(M))} 
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, N, AtS) = eMetaLatexPrint(M, AtS) [owise] .

  op getRenamedKOp : Qid Nat OpDeclSet -> Qid .
  eq getRenamedKOp(Q, N, OPDS) 
   = getRenamedKOp(Q, manyK(N), OPDS) .

  op manyK : Nat -> TypeList .
  eq manyK(0) = nil .
  eq manyK(s(N)) = 'K manyK(N) .
  
  op getRenamedKOp : Qid TypeList OpDeclSet -> Qid .
  eq getRenamedKOp(Q, TyL,  (op Q : TyL -> Ty [AS] .) OPDS)
   = getRenamedKOp(Q, AS) .
  eq getRenamedKOp(Q, TyL, OPDS) = Q [owise] .
 
  op getRenamedKOp : Qid AttrSet -> Qid .
  eq getRenamedKOp(Q, AS metadata("builtin wrapper") ) 
   = '_ .
  eq getRenamedKOp(Q, AS metadata(Str) ) 
   = getName(Q, metadataParse(Str)) [owise] .

  eq eMetaLatexPrint(M, (kaux AtS))
    = ('aux eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (kditto AtS))
    = ('ditto eMetaLatexPrint(M, AtS)) .


  op strictCells : QidList -> QidList .
  eq strictCells('k) = nil .
  eq strictCells(nil) = nil .
  eq strictCells(QIL) = 'in '`( QIL '`) [owise] .

  var NNL : NeNatList .
  eq eMetaLatexPrint(M, (kstrict(nil,QIL) AtS))
    = ('strict strictCells(QIL) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (klocation(Str) AtS)) 
   = eMetaLatexPrint(M, AtS) .
  eq eMetaLatexPrint(M, (kstrict(NNL, QIL) AtS))
    = ('strict '`( eMetaLatexPrint(NNL) '`) strictCells(QIL)
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (seqkstrict(nil,QIL) AtS))
    = ('seqstrict strictCells(QIL) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (seqkstrict(NNL,QIL) AtS))
    = ('seqstrict '`( eMetaLatexPrint(NNL) '`) strictCells(QIL)
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (khybrid AtS))   
    = ('hybrid eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (strat(NL) AtS))
    = ('strat '`( eMetaLatexPrint(NL) '`) 
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (memo AtS))   
    = ('memo eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (prec(I) AtS))
    = (---('prec eMetaLatexPrint(I)---) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (klatex(AS) AtS))
    = (---('prec eMetaLatexPrint(I)---) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (gather(QIL) AtS))
    = (---('gather '`( QIL '`)---) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (format(QIL) AtS))
    = (---('format '`( QIL '`)---) eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (ctor AtS))   
    = ('ctor eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (frozen(NL) AtS)) 
    = ('frozen '`( eMetaLatexPrint(NL) '`) 
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (iter AtS))   
    = ('iter eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (special(HkL) AtS))
    = (---('special '`( eMetaLatexPrint(M, HkL) '`)---) 
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (config AtS))   
    = ('config eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (object AtS))   
    = ('object eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (msg AtS))   
    = ('msg eMetaLatexPrint(M, AtS)) .

  eq eMetaLatexPrint(M, (label(QI) AtS))
    = ('label QI eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (metadata(St) AtS))
    = ('metadata qid("\"" + St + "\"") 
       eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (nonexec AtS))
    = ('nonexec eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (owise AtS))
    = ('owise eMetaLatexPrint(M, AtS)) .
  eq eMetaLatexPrint(M, (print(QIL) AtS))
    = ('print QIL eMetaLatexPrint(M, AtS)) .

  eq eMetaLatexPrint(M, (none).AttrSet) = nil .

  ceq eMetaLatexPrint(M, (Hk HkL)) 
    = (eMetaLatexPrint(M, Hk) eMetaLatexPrint(M, HkL)) 
    if HkL =/= nil .
  eq eMetaLatexPrint(M, id-hook(QI, nil)) = ('id-hook QI) .
  eq eMetaLatexPrint(M, id-hook(QI, QIL))
    = ('id-hook QI '`( QIL '`) ) 
    [owise] .
  eq eMetaLatexPrint(M, op-hook(QI, QI', nil, QI''))
    = ('op-hook QI '`( QI' ': '~> QI'' '`) '\o) .
  eq eMetaLatexPrint(M, op-hook(QI, QI', QIL, QI''))
    = ('op-hook QI '`( QI' ': QIL '~> QI'' '`) '\o) 
    [owise] .
  eq eMetaLatexPrint(M, term-hook(QI, T))
    = ('term-hook QI '`( eMetaLatexPrint(M, T) '`) '\o) .

  eq eMetaLatexPrint((I NL)) = (qid(string(I, 10)) eMetaLatexPrint(NL)) .
  eq eMetaLatexPrint((nil).NatList) = nil .

endm



*******************************************************************************

***
*** 8.2.2 Meta Latex Printing of Modules
***

*** In the following module, the \texttt{meta-pretty-print} function is
*** defined on sort \texttt{Module}.

mod UNIT-META-LATEX-PRINT is
  pr DECL-META-LATEX-PRINT .
  pr MOD-NAME-TO-QID .

  op eMetaLatexPrint : Module Module -> QidList .

  op eMetaLatexPrint : Module Module -> QidList .
  op eMetaLatexPrint : Header -> QidList .
  op eMetaLatexPrint : ParameterDeclList -> QidList .
  op eMetaLatexPrint : ImportList -> QidList .

  var  M : Module .
  vars QI F F' L L' : Qid .
  var  QIL : QidList .
  var  ME : ModuleExpression .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  var  SS : SortSet .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  vars IL IL' : ImportList .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  U : Module .
  var  AtS : AttrSet .
  var  MN : ModuleExpression .

  ceq eMetaLatexPrint(ME) 
    = if QI == '`) or QI == '`] or QI == '`} 
      then QIL QI 
      else QIL QI 
      fi
    if QIL QI := header2QidList(ME) .


  var I : Import .
  op removeKModules : ModuleExpression ImportList -> ImportList .
  eq removeKModules(ME, (including 'K-RULES .) IL) = removeKModules(ME, IL) .
  eq removeKModules(ME, (including 'BOOL .) IL) = removeKModules(ME, IL) .
  ceq removeKModules(ME, (including Q .) IL) 
    = removeKModules(ME, IL) 
   if string(Q) == string(ME) + "-K-CONFIGURATION" .
  eq removeKModules(ME, I IL) = I removeKModules(ME, IL) [owise] .
  eq removeKModules(ME, nil) = nil .
 
  eq eMetaLatexPrint(M, mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\n          
       '\begin '`{ 'module '`} '`{ eMetaLatexPrintME(ME) '`} 
          eMetaLatexPrint(removeKModules(ME,IL)) 
          (if SS == none
           then nil
           else ('\n '\sorts '`{ eMetaLatexPrint(SS) '`} '\o)
           fi)
          eMetaLatexPrint(M, ---(subsorts(SSDS)---)
                             ops(OPDS) mbs(MAS) eqs(EqS) rls(RlS))
       '\n '\end '`{ 'module '`} '\n) .
---(
  eq eMetaLatexPrint(M, mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\n 
       'mod eMetaLatexPrint(ME) (if PDL == nil 
                                      then nil
                                      else '`{ eMetaLatexPrint(PDL) '`} 
                                      fi) 'is 
          eMetaLatexPrint(IL) 
          (if SS == none
           then nil
           else ('\n 'sorts eMetaLatexPrint(SS) '. '\o)
           fi) 
          eMetaLatexPrint(SSDS) 
          eMetaLatexPrint(M, OPDS) 
          eMetaLatexPrint(M, MAS) 
          eMetaLatexPrint(M, EqS) 
          eMetaLatexPrint(M, RlS) 
       '\n 'endm '\n) .
  eq eMetaLatexPrint(M, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = ('\n 
       'th eMetaLatexPrint(MN) 'is 
          eMetaLatexPrint(IL) 
          (if SS == none
           then nil
           else ('\n 'sorts eMetaLatexPrint(SS) '. '\o)
           fi) 
          eMetaLatexPrint(SSDS) 
          eMetaLatexPrint(M, OPDS)
          eMetaLatexPrint(M, MAS) 
          eMetaLatexPrint(M, EqS) 
          eMetaLatexPrint(M, RlS) 
       '\n 'endth '\n) .
  eq eMetaLatexPrint(M, fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\n 
       'fmod eMetaLatexPrint(ME) 'is 
           eMetaLatexPrint(IL) 
           (if SS == none
            then nil
            else ('\n 'sorts eMetaLatexPrint(SS) '. '\o)
            fi)  
           eMetaLatexPrint(SSDS) 
           eMetaLatexPrint(M, OPDS)
           eMetaLatexPrint(M, MAS) 
           eMetaLatexPrint(M, EqS) 
       '\n 'endfm '\n) .
  eq eMetaLatexPrint(M, fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\n 
       'fmod eMetaLatexPrint(ME) (if PDL == nil 
                                       then nil
                                       else '`{ eMetaLatexPrint(PDL) '`} 
                                       fi) 'is 
           eMetaLatexPrint(IL) 
           (if SS == none
            then nil
            else ('\n 'sorts eMetaLatexPrint(SS) '. '\o)
            fi)  
           eMetaLatexPrint(SSDS)          
           eMetaLatexPrint(M, OPDS)
           eMetaLatexPrint(M, MAS)          
           eMetaLatexPrint(M, EqS) 
       '\n 'endfm '\n) .
  eq eMetaLatexPrint(M, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = ('\n 
       'fth eMetaLatexPrint(MN) 'is 
          eMetaLatexPrint(IL)
          (if SS == none
           then nil
           else ('\n 'sorts eMetaLatexPrint(SS) '. '\o)
           fi)  
          eMetaLatexPrint(SSDS) 
          eMetaLatexPrint(M, OPDS)
          eMetaLatexPrint(M, MAS) 
          eMetaLatexPrint(M, EqS) 
       '\n 'endfth '\n) .
---)

  eq eMetaLatexPrint((including ME .) IL)
    = ('\n '\including '`{ eMetaLatexPrintME(ME) '`} 
       eMetaLatexPrint(IL)) .
  eq eMetaLatexPrint((extending ME .) IL)
    = ('\n '\extending '`{ eMetaLatexPrintME(ME) '`} 
       eMetaLatexPrint(IL)) .
  eq eMetaLatexPrint((protecting ME .) IL)
    = ('\n 
       '\protecting '`{ eMetaLatexPrintME(ME) ''`} eMetaLatexPrint(IL)) .
  eq eMetaLatexPrint((nil).ImportList) = nil .

  eq eMetaLatexPrint((QI :: ME, PDL))
    = (QI '::  eMetaLatexPrintME(ME) '`, eMetaLatexPrint(PDL))
    [owise] .
  eq eMetaLatexPrint((QI :: ME)) = (QI '::  eMetaLatexPrintME(ME)) .
  eq eMetaLatexPrint((nil).ParameterDeclList) = (nil).QidList .

  op eMetaLatexPrintME : ModuleExpression -> QidList .
  var ME' : ModuleExpression .
  eq eMetaLatexPrintME(ME' + ME:ModuleExpression)
    = eMetaLatexPrintME(ME') '\modulePlus '`{ '`} eMetaLatexPrintME(ME:ModuleExpression) .
  eq eMetaLatexPrintME(ME * (RnS:RenamingSet))
    = eMetaLatexPrintME(ME) '* '`( renamingSet2QidList(RnS:RenamingSet) '`) .
  var PL : ParameterList . var NePL : NeParameterList .
  eq eMetaLatexPrintME(ME{PL})
   = eMetaLatexPrintME(ME) '\ '`{ eMetaLatexPrintPL(PL) '\ '`} .
  op eMetaLatexPrintPL : ParameterList -> QidList .
  eq eMetaLatexPrintPL((QI,NePL)) = \moduleName{QI} '`, eMetaLatexPrintPL(NePL) .
  eq eMetaLatexPrintPL(QI) = \moduleName{QI} .
  var Q : Qid .
  op \moduleName{_} : Qid -> Qid .
  eq eMetaLatexPrintME(Q) = \moduleName{Q} .

  op renamingSet2QidList : RenamingSet -> QidList .
  eq renamingSet2QidList(((op F to F' [AtS]), RS:RenamingSet))
    = if AtS == none 
      then ('op F 'to F' '`, renamingSet2QidList(RS:RenamingSet))
      else ('op F 'to F' '`[ attrSet2QidList(AtS) '`] '`, 
            renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F to F' [AtS]))
    = if AtS == none 
      then ('op F 'to F')  
      else ('op F 'to F' '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq renamingSet2QidList(((op F : TyL -> Ty to F' [AtS]), RS:RenamingSet))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`, 
            renamingSet2QidList(RS:RenamingSet))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`] '`, 
            renamingSet2QidList(RS:RenamingSet))
      fi 
    [owise] .
  eq renamingSet2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq renamingSet2QidList(((sort S to S'), RS:RenamingSet))
    = ('sort S 'to S' '`, 
       renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((sort S to S')) = ('sort S 'to S') .

  eq renamingSet2QidList(((label L to L'), RS:RenamingSet))
    = ('label L 'to L' '`, renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((label L to L')) = ('label L 'to L') .
endm



mod LATEX-PRINT-META is
  including UNIT-META-LATEX-PRINT .
  sort ProductionType .
  op \textsf{_} : Qid -> Qid [ctor] .

  var Ty : Type . var Tyl : TypeList . var NTyl : NeTypeList .
  eq printTerm(M, merge(Q Ql, NeTl))
   = printEndTerminal(Q)
     printTerm(M, mergeT(Ql,NeTl)) .
  eq printTerm(M, mergeT(Ql,(T, Tl)))
   = '`{ printTerm(M, T) '`} printTerm(M, mergeQ(Ql, Tl)) .
  eq printTerm(M, mergeQ(Q, empty)) 
   = printEndTerminal(Q) .
  eq printTerm(M, mergeQ(Q Ql,NeTl)) 
   = printTerminal(Q) printTerm(M, mergeT(Ql, NeTl)) .

  ops mergeT mergeQ : QidList TermList -> Term .

  op printTerminal : Qid -> QidList .
  eq printTerminal(Q) = if Q == ' then nil else if latexTerminal(Q) then printQid(Q) else ('\mathrel '`{ '\terminal '`{ if Q == '\enspace then nil else printQid(Q) fi '`} '`}) fi fi [print "terminal " Q] .

  op latexTerminal : Qid -> Bool .
  eq latexTerminal(Q) = (substr(string(Q), _-_(length(string(Q)), 1), 1) == "{" and substr(string(Q), _-_(length(string(Q)), 2), 1) == "`")  or-else (substr(string(Q), 1, 1) == "}" and substr(string(Q), 0, 1) == "`") .

  op printEndTerminal : Qid -> QidList .
  eq printEndTerminal(Q) 
   = if Q == '\enspace  then nil else printTerminal(Q) fi .

  eq mergeTypes(Q, nil) = printTerminal(Q) .
  eq mergeTypes(Q, NTyl) = printTerminal(Q) mergeTypes('`( genCommas(arity(NTyl)) '`), NTyl) .
  eq mergeTypes(Q Ql, NTyl) 
   = printEndTerminal(Q) mergeTypesT(Ql, NTyl) [owise] .

  ops mergeTypesT mergeTypesQ : QidList TypeList -> QidList .
  eq mergeTypesT(Ql,Ty Tyl) 
   = '`{ \nterminal{Ty} '`} mergeTypesQ(Ql,Tyl) .

  eq mergeTypesQ(Q Ql, NTyl) = printTerminal(Q) mergeTypesT(Ql, NTyl) .
  eq mergeTypesQ(Q , nil) = printEndTerminal(Q) .
 
  var T : Term . var Cond : Condition . var AS : AttrSet .
  var T1 T2 : Term . var POS : PrintOptionSet . var Ct : Constant .
  var Q Q' : Qid . var Ql : QidList .
  
  eq \constant{'?} = \variable{'AnyVar} .
  eq \constant{'`[HOLE`]} = \variable{'`[HOLE`]} .
  eq \variable{'`[HOLE`]} = \variable{'\ensuremath`{\square`}} .
  eq \variable{'?} = \variable{'AnyVar} .
  eq \variable{'AnyVar} = '\AnyVar .
  eq printVariable("Rho") = printVariable("\\ensuremath{\\rho}") .
  eq printVariable("Sigma") = printVariable("\\ensuremath{\\sigma}") .
---  eq \constant{'.empty} = '\kdot .
---  eq \constant{'.K} = '\kdot .
---  eq \constant{'.nil} = '\kdot .
  op printOpQid : Qid -> Qid .
  eq printOpQid(Q) = printQid(Q) .
---  eq \wrapping{Q} = 'wrapping printQid(Q) .
  eq \renameTo{'AnyVar} = 'renameTo .
  eq \renameTo{Q} = 'renameTo printOpQid(Q) [owise] .
  eq \variable{Q} = '\variable '`{ printVariable(replaceAll(string(Q), ("$" |-> "\\$"))) '`} [owise] .
  eq \constant{Q} = '\constant '`{ printQid(Q) '`} [owise] .
  eq printTerm(M, prefixOp(Q, T))
   = '\prefixOp '`{ printQid(Q)  '`} printTerm(M, T) .
  eq printTerm(M, latexOp(Q,T)) = Q printTerm(M,T) .

  vars St St' St'' : String .
  op printVariable : String -> QidList .
  ceq printVariable(St) 
    =  if I:[Int] :: Nat 
       then printIndexedVariable(substr(St, 0, _-_(length(St), 1)), St') 
       else if St' == "'" then ('\ensuremath '`{ printVariable(substr(St,0,_-_(length(St),1))) '' '`}) else string2qidList(St) fi fi
   if St' := substr(St, _-_(length(St),1), 1)
   /\ I:[Int] := rat(St',10) .

  op printIndexedVariable : String String -> QidList .
  ceq printIndexedVariable(St, St'')
    =  if I:[Int] :: Nat 
       then printIndexedVariable(substr(St, 0, _-_(length(St),1)), St'' + St') 
       else '\ensuremath '`{  '`{ printVariable(St) '`} '_ '`{ string2qidList(St'') '`} '`} fi
   if St' := substr(St, _-_(length(St), 1), 1)
   /\ I:[Int] := rat(St',10) .

  eq \moduleName{Q} = '\moduleName '`{ printQid(Q) '`} .

  eq \textsf{'} = '\enspace .
  eq \textsf{'\} = '\ensuremath`{\backslash`} .
---  eq \textsf{'|->} = '\mapsto .
---  eq \textsf{'<-} = '\leftarrow .
---  eq \textsf{'&} = \textsf{'\&} .
---  eq \textsf{'#} = ' .
---  eq \textsf{'->} = '\kra .
  eq \textsf{'==} = '= .
  eq \textsf{Q} = Q [owise] .
  eq \myquote{Str} 
   = '\myquote '`{ printStr(replaceAll(latexify(replace(substr(Str,1, _-_(length(Str), 2)),"\\","\\textbackslash")),("\\n" |-> "\\textbackslash n", "\"" |-> "\\mysinglequote{}", "_" |-> "\\_"))) '`} .
  op printQid : Qid -> QidList .
  eq printQid(Q) 
   = if Q == ' then nil else 
     if latexCmd(Q) then '\ensuremath '`{ Q '`} 
     else printStr(string(Q)) fi fi .
 
  op printStr : String -> QidList .
  eq printStr(Str) = string2qidList(Str ---replaceAll(Str,("#" |-> "\\#", "%" |-> "\\%", "$" |-> "\\$", "&'" |-> "\\&", "_" |-> "\\_", "'" |-> "", "`" |-> ""))
) .
 
  var Color : String . var Multiplicity : Multiplicity . var Ellipses : Ellipses .
  eq printTerm(M, \kcell{Ct}{T}{Ellipses}) 
   = if Ellipses == right then '\kprefix 
     else if Ellipses == left then '\ksuffix 
     else if Ellipses == both then '\kmiddle
     else '\kall 
     fi fi fi 
     '`{ getColor(M,getName(Ct)) '`} '`{ getName(Ct) '`} '`{ printTerm(M, T) '`} [print "printing cell " Ct] .

  eq printTerm(M, \reduce{T1}{T2}) = if getName(M) == 'STRUCTURAL then '\reduceS else '\reduce fi '`{ printTerm(M, T1) '`} '`{ printTerm(M, T2) '`} .
  eq printTerm(M, \value{T}) = '\kvalue '`{ printTerm(M, T) '`} .

  op getColor : Module Qid -> Qid .
  eq getColor(M, Q) 
   = getColor(getOps(M), Q, 'CellLabel) [print "getting color for " Q] .

  op getColor : OpDeclSet Qid Qid -> Qid .
  eq getColor((op Q : nil -> Q' [AS metadata(Str) ] .) OPDS, Q, Q')
   = getLatexColor(metadataParse(Str)) [print "found metadata for the cellLabel " Q ": " Str] .
  eq getColor(OPDS, Q, Q') = 'white [owise print "did not find metadata for cellLabel " Q " among " OPDS ] .

  op getLatexColor : AttrSet -> Qid .
  var  AS1 : AttrSet .
  eq getLatexColor(AS1 klatex(kcolor(Q) AS) ) = Q [print "found color " Q] .
  eq getLatexColor(AS) = 'white [owise print "color not found among " AS] .

  op length : TermList -> Nat .
  var Tl : TermList .
  eq length(empty) = 0 .
  eq length((T, Tl)) = s(length(Tl)) .


  eq mixfix(Q) =  find(string(Q), "_", 0) :: Nat .
  ceq latexCmd(Q) = substr(Str,0,1) == "\\" and-then all-letters(substr(Str,1,length(Str))) 
   if Str := string(Q) [print "testying for LaTeX " Str] .

   var Str : String . var N : Nat . var Nz : NzNat . var NeTl : NeTermList .
  ceq splitMixFix(Str) 
    = \textsf{qid(substr(Str, 0, N))} splitMixFix(substr(Str, N + 1, length(Str)))
   if N := find(Str, "_", 0) .
  eq splitMixFix(Str) = \textsf{qid(Str)} [owise] .

  var M : Module .  var MAS : MembAxSet . var OPDS : OpDeclSet .
  var QIL QIL' : QidList .
  var P : Printable . var Prints : Printables .
  eq eMetaLatexPrint(M, loc(N,P) Prints) = eMetaLatexPrint(M, P Prints) [print Prints] .
  eq eMetaLatexPrint(M, syntax(QIL, QIL', #Types(N) AS) Prints)
   = ('\n '\syntax '`{ QIL '`} '`{ QIL' '`} '`{ eMetaLatexPrint(M, N, AS)  '`} eMetaLatexPrintQ(M, QIL, Prints)) [owise] .
---  eq \subsort{QIL}{QIL'} = \syntax{QIL'}{QIL}{none} .


  op eMetaLatexPrintQ : Module QidList Printables -> QidList .
  eq eMetaLatexPrintQ(M, QIL, loc(N,P) Prints) = eMetaLatexPrintQ(M, QIL,  P Prints) .
  eq eMetaLatexPrintQ(M, QIL, syntax(QIL, QIL', #Types(N) AS) Prints)
   = ('\n '\syntaxCont '`{ QIL '`} '`{ 
      QIL' '`} '`{ eMetaLatexPrint(M, N, AS) '`} eMetaLatexPrintQ(M, QIL, Prints)) .
  eq eMetaLatexPrintQ(M, QIL, Prints) = eMetaLatexPrint(M, Prints) [owise] . 

  var F : Qid .  var TyL : TypeList . var AtS : AttrSet .

---  op eMetaLatexPrint : ProductionType -> QidList .
  eq (\nterminal{Ty}) 
   = '\nonTerminal '`{ eMetaLatexPrint(Ty) '`} .
  eq (\terminal{Q}) = ---('\terminal '`{---) printQid(Q) . --- '`} .
  eq \sort{Q} = '\sort '`{ printSortQid(Q) '`} .

  op printSortQid : Qid -> QidList .
  eq printSortQid(Q) = printQid(qid(replaceAll(string(Q), ("`{" |-> "\\{", "`}" |-> "\\}")))) .

   var C : Constant .  var V : Variable . var SC : SplitCell .
   op printConfig : Module Term -> QidList .
  ceq  printConfig(M,T)
    =  printConfig(M,\configCell{getName(SC)}{getContents(SC)}{getAttributes(SC)})
    if SC := splitKCell(T)  .

   eq printConfig(M, \configCell{Q}{T}{AS})
    =  '\kallLarge '`{ getColor(M,Q) '`} '`{ Q if AS[multiplicity] == one then nil else qid(symbolM(AS[multiplicity])) fi  '`} '`{ printConfig(M,T) '`} [owise] .
   eq printConfig(M, Q[Tl]) 
    = if Q == ctor(Bag) then printConfigL(M,Tl) else printTerm(M,Q[Tl]) fi [owise print "Escaping to terms if Q is not __. Q: " Q "[" Tl "]"] .
   eq printConfig(M, C) 
    = printTerm(M, C) if getName(C) == '. then eMetaLatexPrint(getType(C)) else nil fi [owise] .
   eq printConfig(M, V) = printTerm(M,V) .


  op printConfigL : Module TermList -> QidList .
  eq printConfigL(M, (T, NeTl)) 
   = printConfig(M, T) '\mathrel '`{ '`} printConfigL(M, NeTl) .
  eq printConfigL(M, T) = printConfig(M,T) [owise] .
  var MAS' : MembAxSet .
  eq eMetaLatexPrint(M, latex(Str) Prints) 
   = ('\n '\n '\medskip tokenize(stripSpaces(Str)) '\medskip ) eMetaLatexPrint(M, Prints) .
  eq eMetaLatexPrint(M, config(T) Prints)
    = ('\n '\kconfig '`{ printConfig(M, T) 
                   '`} 
       eMetaLatexPrint(M, Prints)) .

  var Cnd : Term .
  eq eMetaLatexPrint(M, rule(Str, {krl,T,empty, kstructural AS}) Prints)
    = ('\n '\kequation '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm0(setName(M,'STRUCTURAL), T, AS) 
                   '`} 
       eMetaLatexPrint(M, Prints)) .
  eq eMetaLatexPrint(M, rule(Str, {kcrl,T,Cnd, kstructural AS}) Prints)
    = ('\n '\kcequation '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm0(setName(M,'STRUCTURAL), T, AS) 
                   '`} '`{ '\ensuremath printTerm(M, Cnd) '`} 
       eMetaLatexPrint(M, Prints)) .
  eq eMetaLatexPrint(M, (rule(Str, {krl,T, empty, AS})) Prints)
    = ('\n '\krule '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm0(M, T, AS) 
                   '`} 
       eMetaLatexPrint(M, Prints)) [owise] .
  eq eMetaLatexPrint(M, (rule(Str, {kcrl,T, Cnd, AS})) Prints)
    = ('\n '\kcrule '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm0(M, T, AS) 
                   '`} '`{ '\ensuremath printTerm(M, Cnd) '`} 
       eMetaLatexPrint(M, Prints)) [owise] .
  eq eMetaLatexPrint(M, (context(Str, {kcxt,T, empty, AS})) Prints)
    = ('\n '\kcontext '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm(M, T) 
                   '`} 
       eMetaLatexPrint(M, Prints)) [owise] .
  eq eMetaLatexPrint(M, (context(Str, {kccxt,T, Cnd, AS})) Prints)
    = ('\n '\kccontext '`{ printStr(latexify(Str)) '`} '`{ '\ensuremath printTerm(M, T) 
                   '`} '`{ '\ensuremath printTerm(M, Cnd) '`} 
       eMetaLatexPrint(M, Prints)) [owise] .

  op printTerm0 : Module Term AttrSet -> QidList .
  eq printTerm0(M, T, AS klarge )
   = '\kLarge '`{ printTerm0(M,T) '`} .
  eq printTerm0(M, T, AS )
   = printTerm0(M,T) [owise] .
  op printTerm0 : Module Term -> QidList .
 ceq printTerm0(M, Q[T1,T2]) 
   = if getName(M) == 'STRUCTURAL then '\reduceTopS else '\reduceTop fi '`{ printTerm(M, T1) '`}  '`{ printTerm(M, T2) '`}
  if Q == replaceS .
  eq printTerm0(M,T) = printTerm(M,T) [owise] .

  op latexPrint : Module Module -> QidList .
  var FM : [Module] .
---(
  eq latexPrint(M,
(fmod 'SYNTAX-ERROR is nil sorts none . none (OPDS (op 'error : nil -> 'Error 
      [metadata(Str)] .))
      none none 
endfm)) = tokenize(Str) '\n eMetaLatexPrint(setMbs(setRls(setEqs(M,none),none),none),OPDS) .
---)
  var StrL : List{String} .
  op stringList2qidList : List{String} -> QidList .
  eq stringList2qidList(St StrL) 
   = string2qidList(St) '\n stringList2qidList(StrL) .
  eq stringList2qidList(nil) = nil .

  eq latexPrint(FM, M) = eMetaLatexPrint(setMbs(setRls(setEqs(FM,none),none), none), M)  [print "red latexPrint((" FM "),(" M ")) ."] .


  op latexPrint : Qid -> QidList .
  eq latexPrint(Q) = $latexPrint(Q,upModule(Q,true)) .
  op $latexPrint : Qid [Module] -> QidList .
  eq $latexPrint(Q, FM) = if FM :: Module 
     then latexPrint(FM, upModule(Q,false)) 
     else (
       '\begin '`{ 'module '`} '`{ eMetaLatexPrintME(Q) '`} 
          '\mbox '`{ '\sc '\ '\s 'does 'not 'exist 
                     'or 'is 'not 'valid. '`}
       '\n '\end '`{ 'module '`} '\n) 
     fi .
endm

mod LATEX-PRINT-LOOP is including LOOP-MODE + LATEX-PRINT-META .
  op latex-print : -> System .
  op idle : -> State .
  var Q : Qid . var QIL QIL' : QidList .
  eq latex-print = [nil, idle, 'Usage: 'print '<Name> '.] .

  op error : -> [Module] .
---(
  rl ['print Q QIL, idle, QIL'] 
   => [QIL, idle, latexPrint(Q)] .
---)

  rl [Q QIL, idle, QIL'] 
   => [nil, idle, handle(Q QIL)] .

  op handle : QidList -> QidList .
  eq handle('print Q QIL) = latexPrint(Q) .
  eq handle(QIL) = QIL [owise] .
endm

