fmod MAKE-K-RULES is
  including META-MODULE-EXTRAS .
  including  META-K-RULES .
  including META-LEVEL-EXTRAS .
  var M Flat : Module .  var T T1 T2 : Term .  var AS : AttrSet . 
  var C : Term . var S : Sort . var Ct : Constant . var V : Variable .
  var O : Qid . var N : Nat . var Tl : TermList .
  var KRuleType : KRuleKind .  var Split : KRuleSplit .
  var Mas : MembAxSet . var Max : MembAx .
  
  op resolveKRules : Qid Module Module -> Module .
  eq resolveKRules(O, M, Flat) = setName(resolveReplace(setOps(setEqs(setRls(Flat,none),none),clearReductionAttrs(getOps(Flat))), setMbs(removeImports(M, (including 'K-RULES .)),none), getMbs(M)), O) .

  op resolveReplace : Module Module MembAxSet -> Module .
  eq resolveReplace(Flat, M, none) = M .
  eq resolveReplace(Flat, M, Max Mas)
   = resolveReplace(Flat, M, Max, Mas) .
  op resolveReplace : Module Module MembAx MembAxSet -> Module .
 ceq resolveReplace(Flat, M, Max, Mas)
   = resolveReplace(Flat, addReplace(Flat, M, Split), Mas)
  if Split := splitKRule(Max) .
  eq resolveReplace(Flat, M, Max, Mas) = resolveReplace(Flat, addMbs(Max, M), Mas) [owise] .

  op addReplace : Module Module KRuleSplit ~> Module .
  eq addReplace(Flat, M,{krl,T,empty,AS metadata("structural")})
   = addEqs((eq normalize(Flat,splitReplace(T,1)) = normalize(Flat,splitReplace(T,2)) [AS metadata("structural rule")] .), M) . 
  eq addReplace(Flat, M, {kcrl, T, C, AS metadata("structural")})
   = addEqs((ceq normalize(Flat,splitReplace(T,1)) = normalize(Flat,splitReplace(T,2)) if C = trueCt [AS metadata("structural rule")] .), M) .
  eq addReplace(Flat, M, {krl, T, empty, AS})
    = addRls((rl normalize(Flat,splitReplace(T,1)) => normalize(Flat,splitReplace(T,2)) [AS metadata("computational rule")] .), M) [owise] .
  eq addReplace(Flat, M, {kcrl, T, C, AS}) 
    = addRls((crl normalize(Flat,splitReplace(T,1)) => normalize(Flat, splitReplace(T,2)) if C = trueCt  [AS metadata("computational rule")] .), M) [owise] .
      
  op normalize : Module Term -> Term .
  eq normalize(Flat,T) = getTerm(metaReduce(Flat, T)) .


  op splitReplace : Term Nat -> Term .
 ceq splitReplace(O[T1, T2],N) = if N == 1 then T1 else T2 fi
  if O == replaceS .
  eq splitReplace(O[Tl],N) = O[splitReplaceL(Tl,N)] [owise] .
  eq splitReplace(Ct,N) = Ct .
  eq splitReplace(V, N) = V .

  op splitReplaceL : TermList Nat -> TermList .
  eq splitReplaceL((T, Tl),N) = splitReplace(T,N), splitReplaceL(Tl,N) .
  eq splitReplaceL(empty,N) = empty .
endfm

